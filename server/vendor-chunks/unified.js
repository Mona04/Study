"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unified";
exports.ids = ["vendor-chunks/unified"];
exports.modules = {

/***/ "(ssr)/./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unified: () => (/* binding */ unified)\n/* harmony export */ });\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bail */ \"(ssr)/./node_modules/bail/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-buffer */ \"(ssr)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(extend__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-obj */ \"(ssr)/./node_modules/unified/node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! trough */ \"(ssr)/./node_modules/trough/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vfile */ \"(ssr)/./node_modules/vfile/lib/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */ \n\n\n\n\n\n// Expose a frozen processor.\nconst unified = base().freeze();\nconst own = {}.hasOwnProperty;\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */ function base() {\n    const transformers = (0,trough__WEBPACK_IMPORTED_MODULE_3__.trough)();\n    /** @type {Processor['attachers']} */ const attachers = [];\n    /** @type {Record<string, unknown>} */ let namespace = {};\n    /** @type {boolean|undefined} */ let frozen;\n    let freezeIndex = -1;\n    // Data management.\n    // @ts-expect-error: overloads are handled.\n    processor.data = data;\n    processor.Parser = undefined;\n    processor.Compiler = undefined;\n    // Lock.\n    processor.freeze = freeze;\n    // Plugins.\n    processor.attachers = attachers;\n    // @ts-expect-error: overloads are handled.\n    processor.use = use;\n    // API.\n    processor.parse = parse;\n    processor.stringify = stringify;\n    // @ts-expect-error: overloads are handled.\n    processor.run = run;\n    processor.runSync = runSync;\n    // @ts-expect-error: overloads are handled.\n    processor.process = process;\n    processor.processSync = processSync;\n    // Expose.\n    return processor;\n    // Create a new processor based on the processor in the current scope.\n    /** @type {Processor} */ function processor() {\n        const destination = base();\n        let index = -1;\n        while(++index < attachers.length){\n            destination.use(...attachers[index]);\n        }\n        destination.data(extend__WEBPACK_IMPORTED_MODULE_1___default()(true, {}, namespace));\n        return destination;\n    }\n    /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */ function data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                assertUnfrozen(\"data\", frozen);\n                namespace[key] = value;\n                return processor;\n            }\n            // Get `key`.\n            return own.call(namespace, key) && namespace[key] || null;\n        }\n        // Set space.\n        if (key) {\n            assertUnfrozen(\"data\", frozen);\n            namespace = key;\n            return processor;\n        }\n        // Get space.\n        return namespace;\n    }\n    /** @type {Processor['freeze']} */ function freeze() {\n        if (frozen) {\n            return processor;\n        }\n        while(++freezeIndex < attachers.length){\n            const [attacher, ...options] = attachers[freezeIndex];\n            if (options[0] === false) {\n                continue;\n            }\n            if (options[0] === true) {\n                options[0] = undefined;\n            }\n            /** @type {Transformer|void} */ const transformer = attacher.call(processor, ...options);\n            if (typeof transformer === \"function\") {\n                transformers.use(transformer);\n            }\n        }\n        frozen = true;\n        freezeIndex = Number.POSITIVE_INFINITY;\n        return processor;\n    }\n    /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */ function use(value, ...options) {\n        /** @type {Record<string, unknown>|undefined} */ let settings;\n        assertUnfrozen(\"use\", frozen);\n        if (value === null || value === undefined) {\n        // Empty.\n        } else if (typeof value === \"function\") {\n            addPlugin(value, ...options);\n        } else if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                addList(value);\n            } else {\n                addPreset(value);\n            }\n        } else {\n            throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        }\n        if (settings) {\n            namespace.settings = Object.assign(namespace.settings || {}, settings);\n        }\n        return processor;\n        /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */ function add(value) {\n            if (typeof value === \"function\") {\n                addPlugin(value);\n            } else if (typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    const [plugin, ...options] = value;\n                    addPlugin(plugin, ...options);\n                } else {\n                    addPreset(value);\n                }\n            } else {\n                throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n            }\n        }\n        /**\n     * @param {Preset} result\n     * @returns {void}\n     */ function addPreset(result) {\n            addList(result.plugins);\n            if (result.settings) {\n                settings = Object.assign(settings || {}, result.settings);\n            }\n        }\n        /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */ function addList(plugins) {\n            let index = -1;\n            if (plugins === null || plugins === undefined) {\n            // Empty.\n            } else if (Array.isArray(plugins)) {\n                while(++index < plugins.length){\n                    const thing = plugins[index];\n                    add(thing);\n                }\n            } else {\n                throw new TypeError(\"Expected a list of plugins, not `\" + plugins + \"`\");\n            }\n        }\n        /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */ function addPlugin(plugin, value) {\n            let index = -1;\n            /** @type {Processor['attachers'][number]|undefined} */ let entry;\n            while(++index < attachers.length){\n                if (attachers[index][0] === plugin) {\n                    entry = attachers[index];\n                    break;\n                }\n            }\n            if (entry) {\n                if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(entry[1]) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(value)) {\n                    value = extend__WEBPACK_IMPORTED_MODULE_1___default()(true, entry[1], value);\n                }\n                entry[1] = value;\n            } else {\n                // @ts-expect-error: fine.\n                attachers.push([\n                    ...arguments\n                ]);\n            }\n        }\n    }\n    /** @type {Processor['parse']} */ function parse(doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Parser = processor.Parser;\n        assertParser(\"parse\", Parser);\n        if (newable(Parser, \"parse\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Parser(String(file), file).parse();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Parser(String(file), file) // eslint-disable-line new-cap\n        ;\n    }\n    /** @type {Processor['stringify']} */ function stringify(node, doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Compiler = processor.Compiler;\n        assertCompiler(\"stringify\", Compiler);\n        assertNode(node);\n        if (newable(Compiler, \"compile\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Compiler(node, file).compile();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Compiler(node, file) // eslint-disable-line new-cap\n        ;\n    }\n    /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */ function run(node, doc, callback) {\n        assertNode(node);\n        processor.freeze();\n        if (!callback && typeof doc === \"function\") {\n            callback = doc;\n            doc = undefined;\n        }\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n            transformers.run(node, vfile(doc), done);\n            /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */ function done(error, tree, file) {\n                tree = tree || node;\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(tree);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, tree, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['runSync']} */ function runSync(node, file) {\n        /** @type {Node|undefined} */ let result;\n        /** @type {boolean|undefined} */ let complete;\n        processor.run(node, file, done);\n        assertDone(\"runSync\", \"run\", complete);\n        // @ts-expect-error: we either bailed on an error or have a tree.\n        return result;\n        /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */ function done(error, tree) {\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n            result = tree;\n            complete = true;\n        }\n    }\n    /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */ function process(doc, callback) {\n        processor.freeze();\n        assertParser(\"process\", processor.Parser);\n        assertCompiler(\"process\", processor.Compiler);\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            const file = vfile(doc);\n            processor.run(processor.parse(file), file, (error, tree, file)=>{\n                if (error || !tree || !file) {\n                    done(error);\n                } else {\n                    /** @type {unknown} */ const result = processor.stringify(tree, file);\n                    if (result === undefined || result === null) {\n                    // Empty.\n                    } else if (looksLikeAVFileValue(result)) {\n                        file.value = result;\n                    } else {\n                        file.result = result;\n                    }\n                    done(error, file);\n                }\n            });\n            /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */ function done(error, file) {\n                if (error || !file) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(file);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['processSync']} */ function processSync(doc) {\n        /** @type {boolean|undefined} */ let complete;\n        processor.freeze();\n        assertParser(\"processSync\", processor.Parser);\n        assertCompiler(\"processSync\", processor.Compiler);\n        const file = vfile(doc);\n        processor.process(file, done);\n        assertDone(\"processSync\", \"process\", complete);\n        return file;\n        /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */ function done(error) {\n            complete = true;\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n        }\n    }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */ function newable(value, name) {\n    return typeof value === \"function\" && // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype && // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */ function keys(value) {\n    /** @type {string} */ let key;\n    for(key in value){\n        if (own.call(value, key)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */ function assertParser(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Parser`\");\n    }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */ function assertCompiler(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Compiler`\");\n    }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */ function assertUnfrozen(name, frozen) {\n    if (frozen) {\n        throw new Error(\"Cannot call `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");\n    }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */ function assertNode(node) {\n    // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n    // type-coverage:ignore-next-line\n    if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node) || typeof node.type !== \"string\") {\n        throw new TypeError(\"Expected node, got `\" + node + \"`\");\n    // Fine.\n    }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */ function assertDone(name, asyncName, complete) {\n    if (!complete) {\n        throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n    }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */ function vfile(value) {\n    return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_5__.VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */ function looksLikeAVFile(value) {\n    return Boolean(value && typeof value === \"object\" && \"message\" in value && \"messages\" in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */ function looksLikeAVFileValue(value) {\n    return typeof value === \"string\" || is_buffer__WEBPACK_IMPORTED_MODULE_0___default()(value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUV3QjtBQUNPO0FBQ0w7QUFDVTtBQUNSO0FBQ0Y7QUFFM0IsNkJBQTZCO0FBQ3RCLE1BQU1NLFVBQVVDLE9BQU9DLE1BQU0sR0FBRTtBQUV0QyxNQUFNQyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUU3QiwwQ0FBMEM7QUFDMUM7O0NBRUMsR0FDRCxTQUFTSDtJQUNQLE1BQU1JLGVBQWVQLDhDQUFNQTtJQUMzQixtQ0FBbUMsR0FDbkMsTUFBTVEsWUFBWSxFQUFFO0lBQ3BCLG9DQUFvQyxHQUNwQyxJQUFJQyxZQUFZLENBQUM7SUFDakIsOEJBQThCLEdBQzlCLElBQUlDO0lBQ0osSUFBSUMsY0FBYyxDQUFDO0lBRW5CLG1CQUFtQjtJQUNuQiwyQ0FBMkM7SUFDM0NDLFVBQVVDLElBQUksR0FBR0E7SUFDakJELFVBQVVFLE1BQU0sR0FBR0M7SUFDbkJILFVBQVVJLFFBQVEsR0FBR0Q7SUFFckIsUUFBUTtJQUNSSCxVQUFVUixNQUFNLEdBQUdBO0lBRW5CLFdBQVc7SUFDWFEsVUFBVUosU0FBUyxHQUFHQTtJQUN0QiwyQ0FBMkM7SUFDM0NJLFVBQVVLLEdBQUcsR0FBR0E7SUFFaEIsT0FBTztJQUNQTCxVQUFVTSxLQUFLLEdBQUdBO0lBQ2xCTixVQUFVTyxTQUFTLEdBQUdBO0lBQ3RCLDJDQUEyQztJQUMzQ1AsVUFBVVEsR0FBRyxHQUFHQTtJQUNoQlIsVUFBVVMsT0FBTyxHQUFHQTtJQUNwQiwyQ0FBMkM7SUFDM0NULFVBQVVVLE9BQU8sR0FBR0E7SUFDcEJWLFVBQVVXLFdBQVcsR0FBR0E7SUFFeEIsVUFBVTtJQUNWLE9BQU9YO0lBRVAsc0VBQXNFO0lBQ3RFLHNCQUFzQixHQUN0QixTQUFTQTtRQUNQLE1BQU1ZLGNBQWNyQjtRQUNwQixJQUFJc0IsUUFBUSxDQUFDO1FBRWIsTUFBTyxFQUFF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O0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTeEIsTUFBTTNCLEtBQUs7SUFDbEIsT0FBT29ELGdCQUFnQnBELFNBQVNBLFFBQVEsSUFBSTNCLHdDQUFLQSxDQUFDMkI7QUFDcEQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTb0QsZ0JBQWdCcEQsS0FBSztJQUM1QixPQUFPcUQsUUFDTHJELFNBQ0UsT0FBT0EsVUFBVSxZQUNqQixhQUFhQSxTQUNiLGNBQWNBO0FBRXBCO0FBRUE7OztDQUdDLEdBQ0QsU0FBUzZDLHFCQUFxQjdDLEtBQUs7SUFDakMsT0FBTyxPQUFPQSxVQUFVLFlBQVkvQixnREFBUUEsQ0FBQytCO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaWZpZWQvbGliL2luZGV4LmpzPzM5MzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLk5vZGV9IE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3ZmaWxlJykuVkZpbGVDb21wYXRpYmxlfSBWRmlsZUNvbXBhdGlibGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3ZmaWxlJykuVkZpbGVWYWx1ZX0gVkZpbGVWYWx1ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5Qcm9jZXNzb3J9IFByb2Nlc3NvclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QbHVnaW59IFBsdWdpblxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QcmVzZXR9IFByZXNldFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QbHVnZ2FibGV9IFBsdWdnYWJsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QbHVnZ2FibGVMaXN0fSBQbHVnZ2FibGVMaXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlRyYW5zZm9ybWVyfSBUcmFuc2Zvcm1lclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5QYXJzZXJ9IFBhcnNlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5Db21waWxlcn0gQ29tcGlsZXJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuUnVuQ2FsbGJhY2t9IFJ1bkNhbGxiYWNrXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlByb2Nlc3NDYWxsYmFja30gUHJvY2Vzc0NhbGxiYWNrXG4gKlxuICogQHR5cGVkZWYgQ29udGV4dFxuICogQHByb3BlcnR5IHtOb2RlfSB0cmVlXG4gKiBAcHJvcGVydHkge1ZGaWxlfSBmaWxlXG4gKi9cblxuaW1wb3J0IHtiYWlsfSBmcm9tICdiYWlsJ1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJ2lzLWJ1ZmZlcidcbmltcG9ydCBleHRlbmQgZnJvbSAnZXh0ZW5kJ1xuaW1wb3J0IGlzUGxhaW5PYmogZnJvbSAnaXMtcGxhaW4tb2JqJ1xuaW1wb3J0IHt0cm91Z2h9IGZyb20gJ3Ryb3VnaCdcbmltcG9ydCB7VkZpbGV9IGZyb20gJ3ZmaWxlJ1xuXG4vLyBFeHBvc2UgYSBmcm96ZW4gcHJvY2Vzc29yLlxuZXhwb3J0IGNvbnN0IHVuaWZpZWQgPSBiYXNlKCkuZnJlZXplKClcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaXJzdCBwcm9jZXNzb3IuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9jZXNzb3J9XG4gKi9cbmZ1bmN0aW9uIGJhc2UoKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IHRyb3VnaCgpXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydhdHRhY2hlcnMnXX0gKi9cbiAgY29uc3QgYXR0YWNoZXJzID0gW11cbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi9cbiAgbGV0IG5hbWVzcGFjZSA9IHt9XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gIGxldCBmcm96ZW5cbiAgbGV0IGZyZWV6ZUluZGV4ID0gLTFcblxuICAvLyBEYXRhIG1hbmFnZW1lbnQuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IG92ZXJsb2FkcyBhcmUgaGFuZGxlZC5cbiAgcHJvY2Vzc29yLmRhdGEgPSBkYXRhXG4gIHByb2Nlc3Nvci5QYXJzZXIgPSB1bmRlZmluZWRcbiAgcHJvY2Vzc29yLkNvbXBpbGVyID0gdW5kZWZpbmVkXG5cbiAgLy8gTG9jay5cbiAgcHJvY2Vzc29yLmZyZWV6ZSA9IGZyZWV6ZVxuXG4gIC8vIFBsdWdpbnMuXG4gIHByb2Nlc3Nvci5hdHRhY2hlcnMgPSBhdHRhY2hlcnNcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IudXNlID0gdXNlXG5cbiAgLy8gQVBJLlxuICBwcm9jZXNzb3IucGFyc2UgPSBwYXJzZVxuICBwcm9jZXNzb3Iuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IG92ZXJsb2FkcyBhcmUgaGFuZGxlZC5cbiAgcHJvY2Vzc29yLnJ1biA9IHJ1blxuICBwcm9jZXNzb3IucnVuU3luYyA9IHJ1blN5bmNcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IucHJvY2VzcyA9IHByb2Nlc3NcbiAgcHJvY2Vzc29yLnByb2Nlc3NTeW5jID0gcHJvY2Vzc1N5bmNcblxuICAvLyBFeHBvc2UuXG4gIHJldHVybiBwcm9jZXNzb3JcblxuICAvLyBDcmVhdGUgYSBuZXcgcHJvY2Vzc29yIGJhc2VkIG9uIHRoZSBwcm9jZXNzb3IgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yfSAqL1xuICBmdW5jdGlvbiBwcm9jZXNzb3IoKSB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBiYXNlKClcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICBkZXN0aW5hdGlvbi51c2UoLi4uYXR0YWNoZXJzW2luZGV4XSlcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi5kYXRhKGV4dGVuZCh0cnVlLCB7fSwgbmFtZXNwYWNlKSlcblxuICAgIHJldHVybiBkZXN0aW5hdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlY29yZDxzdHJpbmcsIHVua25vd24+fSBba2V5XVxuICAgKiBAcGFyYW0ge3Vua25vd259IFt2YWx1ZV1cbiAgICogQHJldHVybnMge3Vua25vd259XG4gICAqL1xuICBmdW5jdGlvbiBkYXRhKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFNldCBga2V5YC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGFzc2VydFVuZnJvemVuKCdkYXRhJywgZnJvemVuKVxuICAgICAgICBuYW1lc3BhY2Vba2V5XSA9IHZhbHVlXG4gICAgICAgIHJldHVybiBwcm9jZXNzb3JcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGBrZXlgLlxuICAgICAgcmV0dXJuIChvd24uY2FsbChuYW1lc3BhY2UsIGtleSkgJiYgbmFtZXNwYWNlW2tleV0pIHx8IG51bGxcbiAgICB9XG5cbiAgICAvLyBTZXQgc3BhY2UuXG4gICAgaWYgKGtleSkge1xuICAgICAgYXNzZXJ0VW5mcm96ZW4oJ2RhdGEnLCBmcm96ZW4pXG4gICAgICBuYW1lc3BhY2UgPSBrZXlcbiAgICAgIHJldHVybiBwcm9jZXNzb3JcbiAgICB9XG5cbiAgICAvLyBHZXQgc3BhY2UuXG4gICAgcmV0dXJuIG5hbWVzcGFjZVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ2ZyZWV6ZSddfSAqL1xuICBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgaWYgKGZyb3plbikge1xuICAgICAgcmV0dXJuIHByb2Nlc3NvclxuICAgIH1cblxuICAgIHdoaWxlICgrK2ZyZWV6ZUluZGV4IDwgYXR0YWNoZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgW2F0dGFjaGVyLCAuLi5vcHRpb25zXSA9IGF0dGFjaGVyc1tmcmVlemVJbmRleF1cblxuICAgICAgaWYgKG9wdGlvbnNbMF0gPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zWzBdID09PSB0cnVlKSB7XG4gICAgICAgIG9wdGlvbnNbMF0gPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtUcmFuc2Zvcm1lcnx2b2lkfSAqL1xuICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBhdHRhY2hlci5jYWxsKHByb2Nlc3NvciwgLi4ub3B0aW9ucylcblxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cmFuc2Zvcm1lcnMudXNlKHRyYW5zZm9ybWVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZyb3plbiA9IHRydWVcbiAgICBmcmVlemVJbmRleCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuXG4gICAgcmV0dXJuIHByb2Nlc3NvclxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UGx1Z2dhYmxlfG51bGx8dW5kZWZpbmVkfSBbdmFsdWVdXG4gICAqIEBwYXJhbSB7Li4udW5rbm93bn0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvY2Vzc29yfVxuICAgKi9cbiAgZnVuY3Rpb24gdXNlKHZhbHVlLCAuLi5vcHRpb25zKSB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPnx1bmRlZmluZWR9ICovXG4gICAgbGV0IHNldHRpbmdzXG5cbiAgICBhc3NlcnRVbmZyb3plbigndXNlJywgZnJvemVuKVxuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEVtcHR5LlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRQbHVnaW4odmFsdWUsIC4uLm9wdGlvbnMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYWRkTGlzdCh2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFByZXNldCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdXNhYmxlIHZhbHVlLCBub3QgYCcgKyB2YWx1ZSArICdgJylcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIG5hbWVzcGFjZS5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24obmFtZXNwYWNlLnNldHRpbmdzIHx8IHt9LCBzZXR0aW5ncylcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc29yXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4nKS5QbHVnZ2FibGU8dW5rbm93bltdPn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYWRkUGx1Z2luKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IFtwbHVnaW4sIC4uLm9wdGlvbnNdID0gdmFsdWVcbiAgICAgICAgICBhZGRQbHVnaW4ocGx1Z2luLCAuLi5vcHRpb25zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFByZXNldCh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdXNhYmxlIHZhbHVlLCBub3QgYCcgKyB2YWx1ZSArICdgJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ByZXNldH0gcmVzdWx0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkUHJlc2V0KHJlc3VsdCkge1xuICAgICAgYWRkTGlzdChyZXN1bHQucGx1Z2lucylcblxuICAgICAgaWYgKHJlc3VsdC5zZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oc2V0dGluZ3MgfHwge30sIHJlc3VsdC5zZXR0aW5ncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BsdWdnYWJsZUxpc3R8bnVsbHx1bmRlZmluZWR9IFtwbHVnaW5zXVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZExpc3QocGx1Z2lucykge1xuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgaWYgKHBsdWdpbnMgPT09IG51bGwgfHwgcGx1Z2lucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEVtcHR5LlxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0aGluZyA9IHBsdWdpbnNbaW5kZXhdXG4gICAgICAgICAgYWRkKHRoaW5nKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGxpc3Qgb2YgcGx1Z2lucywgbm90IGAnICsgcGx1Z2lucyArICdgJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BsdWdpbn0gcGx1Z2luXG4gICAgICogQHBhcmFtIHsuLi51bmtub3dufSBbdmFsdWVdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbiwgdmFsdWUpIHtcbiAgICAgIGxldCBpbmRleCA9IC0xXG4gICAgICAvKiogQHR5cGUge1Byb2Nlc3NvclsnYXR0YWNoZXJzJ11bbnVtYmVyXXx1bmRlZmluZWR9ICovXG4gICAgICBsZXQgZW50cnlcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhdHRhY2hlcnNbaW5kZXhdWzBdID09PSBwbHVnaW4pIHtcbiAgICAgICAgICBlbnRyeSA9IGF0dGFjaGVyc1tpbmRleF1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iaihlbnRyeVsxXSkgJiYgaXNQbGFpbk9iaih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGV4dGVuZCh0cnVlLCBlbnRyeVsxXSwgdmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeVsxXSA9IHZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBmaW5lLlxuICAgICAgICBhdHRhY2hlcnMucHVzaChbLi4uYXJndW1lbnRzXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3NvclsncGFyc2UnXX0gKi9cbiAgZnVuY3Rpb24gcGFyc2UoZG9jKSB7XG4gICAgcHJvY2Vzc29yLmZyZWV6ZSgpXG4gICAgY29uc3QgZmlsZSA9IHZmaWxlKGRvYylcbiAgICBjb25zdCBQYXJzZXIgPSBwcm9jZXNzb3IuUGFyc2VyXG4gICAgYXNzZXJ0UGFyc2VyKCdwYXJzZScsIFBhcnNlcilcblxuICAgIGlmIChuZXdhYmxlKFBhcnNlciwgJ3BhcnNlJykpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICAgIHJldHVybiBuZXcgUGFyc2VyKFN0cmluZyhmaWxlKSwgZmlsZSkucGFyc2UoKVxuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICByZXR1cm4gUGFyc2VyKFN0cmluZyhmaWxlKSwgZmlsZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3Nvclsnc3RyaW5naWZ5J119ICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBkb2MpIHtcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuICAgIGNvbnN0IENvbXBpbGVyID0gcHJvY2Vzc29yLkNvbXBpbGVyXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3N0cmluZ2lmeScsIENvbXBpbGVyKVxuICAgIGFzc2VydE5vZGUobm9kZSlcblxuICAgIGlmIChuZXdhYmxlKENvbXBpbGVyLCAnY29tcGlsZScpKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbmV3YWJsZWAgY2hlY2tzIHRoaXMuXG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVyKG5vZGUsIGZpbGUpLmNvbXBpbGUoKVxuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICByZXR1cm4gQ29tcGlsZXIobm9kZSwgZmlsZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7VkZpbGVDb21wYXRpYmxlfFJ1bkNhbGxiYWNrfSBbZG9jXVxuICAgKiBAcGFyYW0ge1J1bkNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE5vZGU+fHZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiBydW4obm9kZSwgZG9jLCBjYWxsYmFjaykge1xuICAgIGFzc2VydE5vZGUobm9kZSlcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBkb2NcbiAgICAgIGRvYyA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShleGVjdXRvcilcbiAgICB9XG5cbiAgICBleGVjdXRvcihudWxsLCBjYWxsYmFjaylcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVsbHwoKG5vZGU6IE5vZGUpID0+IHZvaWQpfSByZXNvbHZlXG4gICAgICogQHBhcmFtIHsoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSByZWplY3RcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBkb2NgIGNhbuKAmXQgYmUgYSBjYWxsYmFjayBhbnltb3JlLCB3ZSBjaGVja2VkLlxuICAgICAgdHJhbnNmb3JtZXJzLnJ1bihub2RlLCB2ZmlsZShkb2MpLCBkb25lKVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3JcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgICAgICogQHBhcmFtIHtWRmlsZX0gZmlsZVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IsIHRyZWUsIGZpbGUpIHtcbiAgICAgICAgdHJlZSA9IHRyZWUgfHwgbm9kZVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodHJlZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgY2FsbGJhY2tgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdC5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB0cmVlLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ3J1blN5bmMnXX0gKi9cbiAgZnVuY3Rpb24gcnVuU3luYyhub2RlLCBmaWxlKSB7XG4gICAgLyoqIEB0eXBlIHtOb2RlfHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgcmVzdWx0XG4gICAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgY29tcGxldGVcblxuICAgIHByb2Nlc3Nvci5ydW4obm9kZSwgZmlsZSwgZG9uZSlcblxuICAgIGFzc2VydERvbmUoJ3J1blN5bmMnLCAncnVuJywgY29tcGxldGUpXG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBlaXRoZXIgYmFpbGVkIG9uIGFuIGVycm9yIG9yIGhhdmUgYSB0cmVlLlxuICAgIHJldHVybiByZXN1bHRcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gW2Vycm9yXVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gW3RyZWVdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9uZShlcnJvciwgdHJlZSkge1xuICAgICAgYmFpbChlcnJvcilcbiAgICAgIHJlc3VsdCA9IHRyZWVcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZGaWxlQ29tcGF0aWJsZX0gZG9jXG4gICAqIEBwYXJhbSB7UHJvY2Vzc0NhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZGaWxlPnx1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzKGRvYywgY2FsbGJhY2spIHtcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBhc3NlcnRQYXJzZXIoJ3Byb2Nlc3MnLCBwcm9jZXNzb3IuUGFyc2VyKVxuICAgIGFzc2VydENvbXBpbGVyKCdwcm9jZXNzJywgcHJvY2Vzc29yLkNvbXBpbGVyKVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKVxuICAgIH1cblxuICAgIGV4ZWN1dG9yKG51bGwsIGNhbGxiYWNrKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudWxsfCgoZmlsZTogVkZpbGUpID0+IHZvaWQpfSByZXNvbHZlXG4gICAgICogQHBhcmFtIHsoZXJyb3I/OiBFcnJvcnxudWxsfHVuZGVmaW5lZCkgPT4gdm9pZH0gcmVqZWN0XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuXG4gICAgICBwcm9jZXNzb3IucnVuKHByb2Nlc3Nvci5wYXJzZShmaWxlKSwgZmlsZSwgKGVycm9yLCB0cmVlLCBmaWxlKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciB8fCAhdHJlZSB8fCAhZmlsZSkge1xuICAgICAgICAgIGRvbmUoZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3Nvci5zdHJpbmdpZnkodHJlZSwgZmlsZSlcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCB8fCByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5LlxuICAgICAgICAgIH0gZWxzZSBpZiAobG9va3NMaWtlQVZGaWxlVmFsdWUocmVzdWx0KSkge1xuICAgICAgICAgICAgZmlsZS52YWx1ZSA9IHJlc3VsdFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlLnJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvbmUoZXJyb3IsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFcnJvcnxudWxsfHVuZGVmaW5lZH0gW2Vycm9yXVxuICAgICAgICogQHBhcmFtIHtWRmlsZXx1bmRlZmluZWR9IFtmaWxlXVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IsIGZpbGUpIHtcbiAgICAgICAgaWYgKGVycm9yIHx8ICFmaWxlKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGZpbGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGNhbGxiYWNrYCBpcyBkZWZpbmVkIGlmIGByZXNvbHZlYCBpcyBub3QuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydwcm9jZXNzU3luYyddfSAqL1xuICBmdW5jdGlvbiBwcm9jZXNzU3luYyhkb2MpIHtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb21wbGV0ZVxuXG4gICAgcHJvY2Vzc29yLmZyZWV6ZSgpXG4gICAgYXNzZXJ0UGFyc2VyKCdwcm9jZXNzU3luYycsIHByb2Nlc3Nvci5QYXJzZXIpXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3Byb2Nlc3NTeW5jJywgcHJvY2Vzc29yLkNvbXBpbGVyKVxuXG4gICAgY29uc3QgZmlsZSA9IHZmaWxlKGRvYylcblxuICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIGRvbmUpXG5cbiAgICBhc3NlcnREb25lKCdwcm9jZXNzU3luYycsICdwcm9jZXNzJywgY29tcGxldGUpXG5cbiAgICByZXR1cm4gZmlsZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcnxudWxsfHVuZGVmaW5lZH0gW2Vycm9yXVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IpIHtcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZVxuICAgICAgYmFpbChlcnJvcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgdmFsdWVgIGlzIGEgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBuZXdhYmxlKHZhbHVlLCBuYW1lKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgLy8gUHJvdG90eXBlcyBkbyBleGlzdC5cbiAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICB2YWx1ZS5wcm90b3R5cGUgJiZcbiAgICAvLyBBIGZ1bmN0aW9uIHdpdGgga2V5cyBpbiBpdHMgcHJvdG90eXBlIGlzIHByb2JhYmx5IGEgY29uc3RydWN0b3IuXG4gICAgLy8gQ2xhc3Nlc+KAmSBwcm90b3R5cGUgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUsIHNvIHdlIGNoZWNrIGlmIHNvbWUgdmFsdWVcbiAgICAvLyBleGlzdHMgaW4gdGhlIHByb3RvdHlwZS5cbiAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICAoa2V5cyh2YWx1ZS5wcm90b3R5cGUpIHx8IG5hbWUgaW4gdmFsdWUucHJvdG90eXBlKVxuICApXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24ga2V5cyh2YWx1ZSkge1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGtleVxuXG4gIGZvciAoa2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKG93bi5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEFzc2VydCBhIHBhcnNlciBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIFBhcnNlcn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UGFyc2VyKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYCcgKyBuYW1lICsgJ2Agd2l0aG91dCBgUGFyc2VyYCcpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgYSBjb21waWxlciBpcyBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIENvbXBpbGVyfVxuICovXG5mdW5jdGlvbiBhc3NlcnRDb21waWxlcihuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGAnICsgbmFtZSArICdgIHdpdGhvdXQgYENvbXBpbGVyYCcpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHByb2Nlc3NvciBpcyBub3QgZnJvemVuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3Vua25vd259IGZyb3plblxuICogQHJldHVybnMge2Fzc2VydHMgZnJvemVuIGlzIGZhbHNlfVxuICovXG5mdW5jdGlvbiBhc3NlcnRVbmZyb3plbihuYW1lLCBmcm96ZW4pIHtcbiAgaWYgKGZyb3plbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2FsbCBgJyArXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAnYCBvbiBhIGZyb3plbiBwcm9jZXNzb3IuXFxuQ3JlYXRlIGEgbmV3IHByb2Nlc3NvciBmaXJzdCwgYnkgY2FsbGluZyBpdDogdXNlIGBwcm9jZXNzb3IoKWAgaW5zdGVhZCBvZiBgcHJvY2Vzc29yYC4nXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IGBub2RlYCBpcyBhIHVuaXN0IG5vZGUuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBub2RlXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBub2RlIGlzIE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICAvLyBgaXNQbGFpbk9iamAgdW5mb3J0dW5hdGVseSB1c2VzIGBhbnlgIGluc3RlYWQgb2YgYHVua25vd25gLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgaWYgKCFpc1BsYWluT2JqKG5vZGUpIHx8IHR5cGVvZiBub2RlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbm9kZSwgZ290IGAnICsgbm9kZSArICdgJylcbiAgICAvLyBGaW5lLlxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYGNvbXBsZXRlYCBpcyBgdHJ1ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhc3luY05hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gY29tcGxldGVcbiAqIEByZXR1cm5zIHthc3NlcnRzIGNvbXBsZXRlIGlzIHRydWV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydERvbmUobmFtZSwgYXN5bmNOYW1lLCBjb21wbGV0ZSkge1xuICBpZiAoIWNvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2AnICsgbmFtZSArICdgIGZpbmlzaGVkIGFzeW5jLiBVc2UgYCcgKyBhc3luY05hbWUgKyAnYCBpbnN0ZWFkJ1xuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VkZpbGVDb21wYXRpYmxlfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7VkZpbGV9XG4gKi9cbmZ1bmN0aW9uIHZmaWxlKHZhbHVlKSB7XG4gIHJldHVybiBsb29rc0xpa2VBVkZpbGUodmFsdWUpID8gdmFsdWUgOiBuZXcgVkZpbGUodmFsdWUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtWRmlsZUNvbXBhdGlibGV9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBWRmlsZX1cbiAqL1xuZnVuY3Rpb24gbG9va3NMaWtlQVZGaWxlKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAnbWVzc2FnZScgaW4gdmFsdWUgJiZcbiAgICAgICdtZXNzYWdlcycgaW4gdmFsdWVcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZhbHVlIGlzIFZGaWxlVmFsdWV9XG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUFWRmlsZVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IGlzQnVmZmVyKHZhbHVlKVxufVxuIl0sIm5hbWVzIjpbImJhaWwiLCJpc0J1ZmZlciIsImV4dGVuZCIsImlzUGxhaW5PYmoiLCJ0cm91Z2giLCJWRmlsZSIsInVuaWZpZWQiLCJiYXNlIiwiZnJlZXplIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJ0cmFuc2Zvcm1lcnMiLCJhdHRhY2hlcnMiLCJuYW1lc3BhY2UiLCJmcm96ZW4iLCJmcmVlemVJbmRleCIsInByb2Nlc3NvciIsImRhdGEiLCJQYXJzZXIiLCJ1bmRlZmluZWQiLCJDb21waWxlciIsInVzZSIsInBhcnNlIiwic3RyaW5naWZ5IiwicnVuIiwicnVuU3luYyIsInByb2Nlc3MiLCJwcm9jZXNzU3luYyIsImRlc3RpbmF0aW9uIiwiaW5kZXgiLCJsZW5ndGgiLCJrZXkiLCJ2YWx1ZSIsImFyZ3VtZW50cyIsImFzc2VydFVuZnJvemVuIiwiY2FsbCIsImF0dGFjaGVyIiwib3B0aW9ucyIsInRyYW5zZm9ybWVyIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJzZXR0aW5ncyIsImFkZFBsdWdpbiIsIkFycmF5IiwiaXNBcnJheSIsImFkZExpc3QiLCJhZGRQcmVzZXQiLCJUeXBlRXJyb3IiLCJPYmplY3QiLCJhc3NpZ24iLCJhZGQiLCJwbHVnaW4iLCJyZXN1bHQiLCJwbHVnaW5zIiwidGhpbmciLCJlbnRyeSIsInB1c2giLCJkb2MiLCJmaWxlIiwidmZpbGUiLCJhc3NlcnRQYXJzZXIiLCJuZXdhYmxlIiwiU3RyaW5nIiwibm9kZSIsImFzc2VydENvbXBpbGVyIiwiYXNzZXJ0Tm9kZSIsImNvbXBpbGUiLCJjYWxsYmFjayIsIlByb21pc2UiLCJleGVjdXRvciIsInJlc29sdmUiLCJyZWplY3QiLCJkb25lIiwiZXJyb3IiLCJ0cmVlIiwiY29tcGxldGUiLCJhc3NlcnREb25lIiwibG9va3NMaWtlQVZGaWxlVmFsdWUiLCJuYW1lIiwicHJvdG90eXBlIiwia2V5cyIsIkVycm9yIiwidHlwZSIsImFzeW5jTmFtZSIsImxvb2tzTGlrZUFWRmlsZSIsIkJvb2xlYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/unified/node_modules/is-plain-obj/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unified/node_modules/is-plain-obj/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isPlainObject)\n/* harmony export */ });\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxTQUFTQSxjQUFjQyxLQUFLO0lBQzFDLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07UUFDaEQsT0FBTztJQUNSO0lBRUEsTUFBTUMsWUFBWUMsT0FBT0MsY0FBYyxDQUFDSDtJQUN4QyxPQUFPLENBQUNDLGNBQWMsUUFBUUEsY0FBY0MsT0FBT0QsU0FBUyxJQUFJQyxPQUFPQyxjQUFjLENBQUNGLGVBQWUsSUFBRyxLQUFNLENBQUVHLENBQUFBLE9BQU9DLFdBQVcsSUFBSUwsS0FBSSxLQUFNLENBQUVJLENBQUFBLE9BQU9FLFFBQVEsSUFBSU4sS0FBSTtBQUMxSyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmlmaWVkL25vZGVfbW9kdWxlcy9pcy1wbGFpbi1vYmovaW5kZXguanM/M2U3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblx0cmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpO1xufVxuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/node_modules/is-plain-obj/index.js\n");

/***/ })

};
;