"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst splitFilePath = ({ filePath })=>{\n    const filenameWithExtension = filePath.split(\"\\\\\").pop()?.split(\"/\").pop() || \"\";\n    const filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    const fileExtension = filePath.split(\".\").pop();\n    const filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nconst generateImageURL = (src, width, basePath, isRemoteImage = false)=>{\n    const { filename, path, extension } = splitFilePath({\n        filePath: src\n    });\n    const useWebp =  true ? \"true\" : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    let processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    let correctedPath = path;\n    const lastChar = correctedPath?.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    const isStaticImage = src.includes(\"_next/static/media\");\n    if (basePath) {\n        if (basePath.endsWith(\"/\") && correctedPath && correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + correctedPath.slice(1);\n        } else if (!basePath.endsWith(\"/\") && correctedPath && !correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + \"/\" + correctedPath;\n        } else {\n            correctedPath = basePath + correctedPath;\n        }\n    }\n    const exportFolderName = \"nextImageExportOptimizer\" || 0;\n    const basePathPrefixForStaticImages = basePath ? basePath + \"/\" : \"\";\n    let generatedImageURL = `${isStaticImage ? basePathPrefixForStaticImages : correctedPath}${exportFolderName}/${filename}-opt-${width}.${processedExtension.toUpperCase()}`;\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\nfunction urlToFilename(url) {\n    // Remove the protocol from the URL\n    let filename = url.replace(/^(https?|ftp):\\/\\//, \"\");\n    // Replace special characters with underscores\n    filename = filename.replace(/[/\\\\:*?\"<>|#%]/g, \"_\");\n    // Remove control characters\n    // eslint-disable-next-line no-control-regex\n    filename = filename.replace(/[\\x00-\\x1F\\x7F]/g, \"\");\n    // Trim any leading or trailing spaces\n    filename = filename.trim();\n    return filename;\n}\nconst imageURLForRemoteImage = ({ src, width, basePath })=>{\n    const encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, basePath, true);\n};\nconst optimizedLoader = ({ src, width, basePath })=>{\n    const isStaticImage = typeof src === \"object\";\n    const _src = isStaticImage ? src.src : src;\n    const originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        const deviceSizes = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.deviceSizes || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ];\n        const imageSizes = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.imageSizes || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ];\n        const allSizes = [\n            ...deviceSizes,\n            ...imageSizes\n        ];\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        let nextLargestSize = null;\n        for(let i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize, basePath);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width,\n            basePath\n        });\n    }\n    return generateImageURL(_src, width, basePath);\n};\nconst fallbackLoader = ({ src })=>{\n    let _src = typeof src === \"object\" ? src.src : src;\n    const isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nconst ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ src, priority = false, loading, className, width, height, onLoad, unoptimized, placeholder = \"blur\", basePath = \"\", alt = \"\", blurDataURL, style, onError, ...rest }, ref)=>{\n    const [imageError, setImageError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (blurDataURL) {\n            // use the user provided blurDataURL if present\n            return blurDataURL;\n        }\n        // check if the src is specified as a local file -> then it is an object\n        const isStaticImage = typeof src === \"object\";\n        let _src = isStaticImage ? src.src : src;\n        if (unoptimized === true) {\n            // return the src image when unoptimized\n            return _src;\n        }\n        // Check if the image is a remote image (starts with http or https)\n        if (_src.startsWith(\"http\")) {\n            return imageURLForRemoteImage({\n                src: _src,\n                width: 10,\n                basePath\n            });\n        }\n        // otherwise use the generated image of 10px width as a blurDataURL\n        return generateImageURL(_src, 10, basePath);\n    }, [\n        blurDataURL,\n        src,\n        unoptimized,\n        basePath\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    const isSVG = typeof src === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    const [blurComplete, setBlurComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    const blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: style?.objectFit || \"cover\",\n        backgroundPosition: style?.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(\"${automaticallyCalculatedBlurDataURL}\")`\n    } : undefined;\n    const isStaticImage = typeof src === \"object\";\n    let _src = isStaticImage ? src.src : src;\n    if (basePath && !isStaticImage && _src.startsWith(\"/\")) {\n        _src = basePath + _src;\n    }\n    if (basePath && !isStaticImage && !_src.startsWith(\"/\")) {\n        _src = basePath + \"/\" + _src;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((next_image__WEBPACK_IMPORTED_MODULE_0___default()), {\n        ref: ref,\n        alt: alt,\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        ...onLoad && {\n            onLoad\n        },\n        ...placeholder && {\n            placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n        },\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        ...isSVG && {\n            unoptimized: true\n        },\n        style: {\n            ...style,\n            ...blurStyle\n        },\n        loader: imageError || unoptimized === true ? fallbackLoader : (e)=>optimizedLoader({\n                src,\n                width: e.width,\n                basePath\n            }),\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: (error)=>{\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            onError && onError(error);\n        },\n        onLoad: (e)=>{\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            const target = e.target;\n            if (target.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoad callback if present\n            onLoad && onLoad(e);\n        },\n        src: isStaticImage ? src : _src\n    });\n});\nExportedImage.displayName = \"ExportedImage\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs2REFDK0I7QUFDOEI7QUFDN0QsTUFBTUssZ0JBQWdCLENBQUMsRUFBRUMsUUFBUSxFQUFFO0lBQy9CLE1BQU1DLHdCQUF3QkQsU0FBU0UsS0FBSyxDQUFDLE1BQU1DLEdBQUcsSUFBSUQsTUFBTSxLQUFLQyxTQUFTO0lBQzlFLE1BQU1DLDBCQUEwQkosU0FBU0UsS0FBSyxDQUFDRCx1QkFBdUJJLEtBQUs7SUFDM0UsTUFBTUMsZ0JBQWdCTixTQUFTRSxLQUFLLENBQUMsS0FBS0MsR0FBRztJQUM3QyxNQUFNSSwyQkFBMkJOLHNCQUFzQk8sU0FBUyxDQUFDLEdBQUdQLHNCQUFzQlEsV0FBVyxDQUFDLFNBQVNSO0lBQy9HLE9BQU87UUFDSFMsTUFBTU47UUFDTk8sVUFBVUo7UUFDVkssV0FBV04saUJBQWlCO0lBQ2hDO0FBQ0o7QUFDQSxNQUFNTyxtQkFBbUIsQ0FBQ0MsS0FBS0MsT0FBT0MsVUFBVUMsZ0JBQWdCLEtBQUs7SUFDakUsTUFBTSxFQUFFTixRQUFRLEVBQUVELElBQUksRUFBRUUsU0FBUyxFQUFFLEdBQUdiLGNBQWM7UUFBRUMsVUFBVWM7SUFBSTtJQUNwRSxNQUFNSSxVQUFVQyxLQUFxRUcsR0FDL0VILE1BQXdELEdBQ3hELENBQUk7SUFDVixJQUFJLENBQUM7UUFBQztRQUFPO1FBQVE7UUFBUTtRQUFPO1FBQVE7S0FBTSxDQUFDSSxRQUFRLENBQUNYLFVBQVVZLFdBQVcsS0FBSztRQUNsRiwwQ0FBMEM7UUFDMUMseUJBQXlCO1FBQ3pCLE9BQU9WO0lBQ1g7SUFDQSx5RUFBeUU7SUFDekUsK0NBQStDO0lBQy9DLElBQUlXLHFCQUFxQmI7SUFDekIsSUFBSU0sV0FDQTtRQUFDO1FBQU87UUFBUTtRQUFPO0tBQU0sQ0FBQ0ssUUFBUSxDQUFDWCxVQUFVWSxXQUFXLEtBQUs7UUFDakVDLHFC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Z0JBQWdCZixNQUFNK0I7SUFBSztBQUMzQztBQUNBVyxjQUFjaUMsV0FBVyxHQUFHO0FBQzVCLGlFQUFlakMsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0LWltYWdlLWV4cG9ydC1vcHRpbWl6ZXIvZGlzdC9FeHBvcnRlZEltYWdlLmpzP2VmMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3Qgc3BsaXRGaWxlUGF0aCA9ICh7IGZpbGVQYXRoIH0pID0+IHtcbiAgICBjb25zdCBmaWxlbmFtZVdpdGhFeHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIlxcXFxcIikucG9wKCk/LnNwbGl0KFwiL1wiKS5wb3AoKSB8fCBcIlwiO1xuICAgIGNvbnN0IGZpbGVQYXRoV2l0aG91dEZpbGVuYW1lID0gZmlsZVBhdGguc3BsaXQoZmlsZW5hbWVXaXRoRXh0ZW5zaW9uKS5zaGlmdCgpO1xuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgY29uc3QgZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uID0gZmlsZW5hbWVXaXRoRXh0ZW5zaW9uLnN1YnN0cmluZygwLCBmaWxlbmFtZVdpdGhFeHRlbnNpb24ubGFzdEluZGV4T2YoXCIuXCIpKSB8fCBmaWxlbmFtZVdpdGhFeHRlbnNpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUsXG4gICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgIGV4dGVuc2lvbjogZmlsZUV4dGVuc2lvbiB8fCBcIlwiLFxuICAgIH07XG59O1xuY29uc3QgZ2VuZXJhdGVJbWFnZVVSTCA9IChzcmMsIHdpZHRoLCBiYXNlUGF0aCwgaXNSZW1vdGVJbWFnZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlbmFtZSwgcGF0aCwgZXh0ZW5zaW9uIH0gPSBzcGxpdEZpbGVQYXRoKHsgZmlsZVBhdGg6IHNyYyB9KTtcbiAgICBjb25zdCB1c2VXZWJwID0gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAgIT0gdW5kZWZpbmVkXG4gICAgICAgID8gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlBcbiAgICAgICAgOiB0cnVlO1xuICAgIGlmICghW1wiSlBHXCIsIFwiSlBFR1wiLCBcIldFQlBcIiwgXCJQTkdcIiwgXCJBVklGXCIsIFwiR0lGXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAvLyBUaGUgaW1hZ2VzIGhhcyBhbiB1bnN1cHBvcnRlZCBleHRlbnNpb25cbiAgICAgICAgLy8gV2Ugd2lsbCByZXR1cm4gdGhlIHNyY1xuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgaW1hZ2VzIGFyZSBzdG9yZWQgYXMgV0VCUCBieSB0aGUgcGFja2FnZSwgdGhlbiB3ZSBzaG91bGQgY2hhbmdlXG4gICAgLy8gdGhlIGV4dGVuc2lvbiB0byBXRUJQIHRvIGxvYWQgdGhlbSBjb3JyZWN0bHlcbiAgICBsZXQgcHJvY2Vzc2VkRXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgIGlmICh1c2VXZWJwICYmXG4gICAgICAgIFtcIkpQR1wiLCBcIkpQRUdcIiwgXCJQTkdcIiwgXCJHSUZcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIHByb2Nlc3NlZEV4dGVuc2lvbiA9IFwiV0VCUFwiO1xuICAgIH1cbiAgICBsZXQgY29ycmVjdGVkUGF0aCA9IHBhdGg7XG4gICAgY29uc3QgbGFzdENoYXIgPSBjb3JyZWN0ZWRQYXRoPy5zdWJzdHIoLTEpOyAvLyBTZWxlY3RzIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgIGlmIChsYXN0Q2hhciAhPSBcIi9cIikge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGEgc2xhc2hcbiAgICAgICAgY29ycmVjdGVkUGF0aCA9IGNvcnJlY3RlZFBhdGggKyBcIi9cIjsgLy8gQXBwZW5kIGEgc2xhc2ggdG8gaXQuXG4gICAgfVxuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSBzcmMuaW5jbHVkZXMoXCJfbmV4dC9zdGF0aWMvbWVkaWFcIik7XG4gICAgaWYgKGJhc2VQYXRoKSB7XG4gICAgICAgIGlmIChiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIGNvcnJlY3RlZFBhdGguc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWJhc2VQYXRoLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCAmJlxuICAgICAgICAgICAgIWNvcnJlY3RlZFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIFwiL1wiICsgY29ycmVjdGVkUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIGNvcnJlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwb3J0Rm9sZGVyTmFtZSA9IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9leHBvcnRGb2xkZXJOYW1lIHx8XG4gICAgICAgIFwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyXCI7XG4gICAgY29uc3QgYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMgPSBiYXNlUGF0aCA/IGJhc2VQYXRoICsgXCIvXCIgOiBcIlwiO1xuICAgIGxldCBnZW5lcmF0ZWRJbWFnZVVSTCA9IGAke2lzU3RhdGljSW1hZ2UgPyBiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyA6IGNvcnJlY3RlZFBhdGh9JHtleHBvcnRGb2xkZXJOYW1lfS8ke2ZpbGVuYW1lfS1vcHQtJHt3aWR0aH0uJHtwcm9jZXNzZWRFeHRlbnNpb24udG9VcHBlckNhc2UoKX1gO1xuICAgIC8vIGlmIHRoZSBnZW5lcmF0ZWRJbWFnZVVSTCBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgZ2VuZXJhdGVkSW1hZ2VVUkwuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZVVSTCA9IFwiL1wiICsgZ2VuZXJhdGVkSW1hZ2VVUkw7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZVVSTDtcbn07XG5mdW5jdGlvbiB1cmxUb0ZpbGVuYW1lKHVybCkge1xuICAgIC8vIFJlbW92ZSB0aGUgcHJvdG9jb2wgZnJvbSB0aGUgVVJMXG4gICAgbGV0IGZpbGVuYW1lID0gdXJsLnJlcGxhY2UoL14oaHR0cHM/fGZ0cCk6XFwvXFwvLywgXCJcIik7XG4gICAgLy8gUmVwbGFjZSBzcGVjaWFsIGNoYXJhY3RlcnMgd2l0aCB1bmRlcnNjb3Jlc1xuICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvWy9cXFxcOio/XCI8PnwjJV0vZywgXCJfXCIpO1xuICAgIC8vIFJlbW92ZSBjb250cm9sIGNoYXJhY3RlcnNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvW1xceDAwLVxceDFGXFx4N0ZdL2csIFwiXCIpO1xuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgc3BhY2VzXG4gICAgZmlsZW5hbWUgPSBmaWxlbmFtZS50cmltKCk7XG4gICAgcmV0dXJuIGZpbGVuYW1lO1xufVxuY29uc3QgaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSA9ICh7IHNyYywgd2lkdGgsIGJhc2VQYXRoLCB9KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZFNyYyA9IHVybFRvRmlsZW5hbWUoc3JjKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChlbmNvZGVkU3JjLCB3aWR0aCwgYmFzZVBhdGgsIHRydWUpO1xufTtcbmNvbnN0IG9wdGltaXplZExvYWRlciA9ICh7IHNyYywgd2lkdGgsIGJhc2VQYXRoLCB9KSA9PiB7XG4gICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCI7XG4gICAgY29uc3QgX3NyYyA9IGlzU3RhdGljSW1hZ2UgPyBzcmMuc3JjIDogc3JjO1xuICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2VXaWR0aCA9IChpc1N0YXRpY0ltYWdlICYmIHNyYy53aWR0aCkgfHwgdW5kZWZpbmVkO1xuICAgIC8vIGlmIGl0IGlzIGEgc3RhdGljIGltYWdlLCB3ZSBjYW4gdXNlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UgdG8gZ2VuZXJhdGUgYSByZWR1Y2VkIHNyY3NldCB0aGF0IHJldHVybnNcbiAgICAvLyB0aGUgc2FtZSBpbWFnZSB1cmwgZm9yIHdpZHRocyB0aGF0IGFyZSBsYXJnZXIgdGhhbiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICBpZiAoaXNTdGF0aWNJbWFnZSAmJiBvcmlnaW5hbEltYWdlV2lkdGggJiYgd2lkdGggPiBvcmlnaW5hbEltYWdlV2lkdGgpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUz8uZGV2aWNlU2l6ZXMgfHwgW1xuICAgICAgICAgICAgNjQwLCA3NTAsIDgyOCwgMTA4MCwgMTIwMCwgMTkyMCwgMjA0OCwgMzg0MCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaW1hZ2VTaXplcyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTPy5pbWFnZVNpemVzIHx8IFtcbiAgICAgICAgICAgIDE2LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAyNTYsIDM4NCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbLi4uZGV2aWNlU2l6ZXMsIC4uLmltYWdlU2l6ZXNdO1xuICAgICAgICAvLyBvbmx5IHVzZSB0aGUgd2lkdGggaWYgaXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB0aGUgbmV4dCBzaXplIGluIHRoZSBhbGxTaXplcyBhcnJheVxuICAgICAgICBsZXQgbmV4dExhcmdlc3RTaXplID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxTaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKE51bWJlcihhbGxTaXplc1tpXSkgPj0gb3JpZ2luYWxJbWFnZVdpZHRoICYmXG4gICAgICAgICAgICAgICAgKG5leHRMYXJnZXN0U2l6ZSA9PT0gbnVsbCB8fCBOdW1iZXIoYWxsU2l6ZXNbaV0pIDwgbmV4dExhcmdlc3RTaXplKSkge1xuICAgICAgICAgICAgICAgIG5leHRMYXJnZXN0U2l6ZSA9IE51bWJlcihhbGxTaXplc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMYXJnZXN0U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgbmV4dExhcmdlc3RTaXplLCBiYXNlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGlzIGEgcmVtb3RlIGltYWdlIChzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzKVxuICAgIGlmIChfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHJldHVybiBpbWFnZVVSTEZvclJlbW90ZUltYWdlKHsgc3JjOiBfc3JjLCB3aWR0aCwgYmFzZVBhdGggfSk7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIHdpZHRoLCBiYXNlUGF0aCk7XG59O1xuY29uc3QgZmFsbGJhY2tMb2FkZXIgPSAoeyBzcmMgfSkgPT4ge1xuICAgIGxldCBfc3JjID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMgOiBzcmM7XG4gICAgY29uc3QgaXNSZW1vdGVJbWFnZSA9IF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIik7XG4gICAgLy8gaWYgdGhlIF9zcmMgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgX3NyYy5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIF9zcmMgPSBcIi9cIiArIF9zcmM7XG4gICAgfVxuICAgIHJldHVybiBfc3JjO1xufTtcbmNvbnN0IEV4cG9ydGVkSW1hZ2UgPSBmb3J3YXJkUmVmKCh7IHNyYywgcHJpb3JpdHkgPSBmYWxzZSwgbG9hZGluZywgY2xhc3NOYW1lLCB3aWR0aCwgaGVpZ2h0LCBvbkxvYWQsIHVub3B0aW1pemVkLCBwbGFjZWhvbGRlciA9IFwiYmx1clwiLCBiYXNlUGF0aCA9IFwiXCIsIGFsdCA9IFwiXCIsIGJsdXJEYXRhVVJMLCBzdHlsZSwgb25FcnJvciwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBbaW1hZ2VFcnJvciwgc2V0SW1hZ2VFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgdXNlciBwcm92aWRlZCBibHVyRGF0YVVSTCBpZiBwcmVzZW50XG4gICAgICAgICAgICByZXR1cm4gYmx1ckRhdGFVUkw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNyYyBpcyBzcGVjaWZpZWQgYXMgYSBsb2NhbCBmaWxlIC0+IHRoZW4gaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgICAgICBsZXQgX3NyYyA9IGlzU3RhdGljSW1hZ2UgPyBzcmMuc3JjIDogc3JjO1xuICAgICAgICBpZiAodW5vcHRpbWl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgc3JjIGltYWdlIHdoZW4gdW5vcHRpbWl6ZWRcbiAgICAgICAgICAgIHJldHVybiBfc3JjO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbWFnZSBpcyBhIHJlbW90ZSBpbWFnZSAoc3RhcnRzIHdpdGggaHR0cCBvciBodHRwcylcbiAgICAgICAgaWYgKF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVVSTEZvclJlbW90ZUltYWdlKHsgc3JjOiBfc3JjLCB3aWR0aDogMTAsIGJhc2VQYXRoIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGdlbmVyYXRlZCBpbWFnZSBvZiAxMHB4IHdpZHRoIGFzIGEgYmx1ckRhdGFVUkxcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgMTAsIGJhc2VQYXRoKTtcbiAgICB9LCBbYmx1ckRhdGFVUkwsIHNyYywgdW5vcHRpbWl6ZWQsIGJhc2VQYXRoXSk7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHNyYyBpcyBhIFNWRyBpbWFnZSAtPiB0aGVuIHdlIHNob3VsZCBub3QgdXNlIHRoZSBibHVyRGF0YVVSTCBhbmQgdXNlIHVub3B0aW1pemVkXG4gICAgY29uc3QgaXNTVkcgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiID8gc3JjLnNyYy5lbmRzV2l0aChcIi5zdmdcIikgOiBzcmMuZW5kc1dpdGgoXCIuc3ZnXCIpO1xuICAgIGNvbnN0IFtibHVyQ29tcGxldGUsIHNldEJsdXJDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gQ3VycmVudGx5LCB3ZSBoYXZlIHRvIGhhbmRsZSB0aGUgYmx1ckRhdGFVUkwgb3Vyc2VsdmVzIGFzIHRoZSBuZXcgSW1hZ2UgY29tcG9uZW50XG4gICAgLy8gaXMgZXhwZWN0aW5nIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLCBidXQgdGhlIGdlbmVyYXRlZCBibHVyRGF0YVVSTCBpcyBhIG5vcm1hbCBVUkxcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gXCJibHVyXCIgJiZcbiAgICAgICAgIWlzU1ZHICYmXG4gICAgICAgIGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwgJiZcbiAgICAgICAgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTC5zdGFydHNXaXRoKFwiL1wiKSAmJlxuICAgICAgICAhYmx1ckNvbXBsZXRlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgYmFja2dyb3VuZFNpemU6IHN0eWxlPy5vYmplY3RGaXQgfHwgXCJjb3ZlclwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBzdHlsZT8ub2JqZWN0UG9zaXRpb24gfHwgXCI1MCUgNTAlXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKFwiJHthdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMfVwiKWAsXG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCI7XG4gICAgbGV0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICBpZiAoYmFzZVBhdGggJiYgIWlzU3RhdGljSW1hZ2UgJiYgX3NyYy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBfc3JjID0gYmFzZVBhdGggKyBfc3JjO1xuICAgIH1cbiAgICBpZiAoYmFzZVBhdGggJiYgIWlzU3RhdGljSW1hZ2UgJiYgIV9zcmMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgX3NyYyA9IGJhc2VQYXRoICsgXCIvXCIgKyBfc3JjO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW1hZ2UsIHsgcmVmOiByZWYsIGFsdDogYWx0LCAuLi5yZXN0LCAuLi4od2lkdGggJiYgeyB3aWR0aCB9KSwgLi4uKGhlaWdodCAmJiB7IGhlaWdodCB9KSwgLi4uKGxvYWRpbmcgJiYgeyBsb2FkaW5nIH0pLCAuLi4oY2xhc3NOYW1lICYmIHsgY2xhc3NOYW1lIH0pLCAuLi4ob25Mb2FkICYmIHsgb25Mb2FkIH0pLCAuLi4ocGxhY2Vob2xkZXIgJiYge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGJsdXJTdHlsZSB8fCBibHVyQ29tcGxldGUgPyBcImVtcHR5XCIgOiBwbGFjZWhvbGRlcixcbiAgICAgICAgfSksIC4uLih1bm9wdGltaXplZCAmJiB7IHVub3B0aW1pemVkIH0pLCAuLi4ocHJpb3JpdHkgJiYgeyBwcmlvcml0eSB9KSwgLi4uKGlzU1ZHICYmIHsgdW5vcHRpbWl6ZWQ6IHRydWUgfSksIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi5ibHVyU3R5bGUgfSwgbG9hZGVyOiBpbWFnZUVycm9yIHx8IHVub3B0aW1pemVkID09PSB0cnVlXG4gICAgICAgICAgICA/IGZhbGxiYWNrTG9hZGVyXG4gICAgICAgICAgICA6IChlKSA9PiBvcHRpbWl6ZWRMb2FkZXIoeyBzcmMsIHdpZHRoOiBlLndpZHRoLCBiYXNlUGF0aCB9KSwgYmx1ckRhdGFVUkw6IGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwsIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc2V0SW1hZ2VFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIG9uRXJyb3IgZnVuY3Rpb24gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0sIG9uTG9hZDogKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNvbmZpZ3VyYXRpb25zLCB0aGUgb25FcnJvciBoYW5kbGVyIGlzIG5vdCBjYWxsZWQgb24gYW4gZXJyb3Igb2NjdXJyZW5jZVxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgaW1hZ2UgaXMgbG9hZGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEJyb2tlbiBpbWFnZSwgZmFsbCBiYWNrIHRvIHVub3B0aW1pemVkIChtZWFuaW5nIHRoZSBvcmlnaW5hbCBpbWFnZSBzcmMpXG4gICAgICAgICAgICAgICAgc2V0SW1hZ2VFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIG9uTG9hZCBjYWxsYmFjayBpZiBwcmVzZW50XG4gICAgICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKGUpO1xuICAgICAgICB9LCBzcmM6IGlzU3RhdGljSW1hZ2UgPyBzcmMgOiBfc3JjIH0pKTtcbn0pO1xuRXhwb3J0ZWRJbWFnZS5kaXNwbGF5TmFtZSA9IFwiRXhwb3J0ZWRJbWFnZVwiO1xuZXhwb3J0IGRlZmF1bHQgRXhwb3J0ZWRJbWFnZTtcbiJdLCJuYW1lcyI6WyJJbWFnZSIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInNwbGl0RmlsZVBhdGgiLCJmaWxlUGF0aCIsImZpbGVuYW1lV2l0aEV4dGVuc2lvbiIsInNwbGl0IiwicG9wIiwiZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUiLCJzaGlmdCIsImZpbGVFeHRlbnNpb24iLCJmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24iLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsInBhdGgiLCJmaWxlbmFtZSIsImV4dGVuc2lvbiIsImdlbmVyYXRlSW1hZ2VVUkwiLCJzcmMiLCJ3aWR0aCIsImJhc2VQYXRoIiwiaXNSZW1vdGVJbWFnZSIsInVzZVdlYnAiLCJwcm9jZXNzIiwiZW52IiwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAiLCJ1bmRlZmluZWQiLCJpbmNsdWRlcyIsInRvVXBwZXJDYXNlIiwicHJvY2Vzc2VkRXh0ZW5zaW9uIiwiY29ycmVjdGVkUGF0aCIsImxhc3RDaGFyIiwic3Vic3RyIiwiaXNTdGF0aWNJbWFnZSIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZXhwb3J0Rm9sZGVyTmFtZSIsIm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9leHBvcnRGb2xkZXJOYW1lIiwiYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMiLCJnZW5lcmF0ZWRJbWFnZVVSTCIsImNoYXJBdCIsInVybFRvRmlsZW5hbWUiLCJ1cmwiLCJyZXBsYWNlIiwidHJpbSIsImltYWdlVVJMRm9yUmVtb3RlSW1hZ2UiLCJlbmNvZGVkU3JjIiwib3B0aW1pemVkTG9hZGVyIiwiX3NyYyIsIm9yaWdpbmFsSW1hZ2VXaWR0aCIsImRldmljZVNpemVzIiwiX19ORVhUX0lNQUdFX09QVFMiLCJpbWFnZVNpemVzIiwiYWxsU2l6ZXMiLCJuZXh0TGFyZ2VzdFNpemUiLCJpIiwibGVuZ3RoIiwiTnVtYmVyIiwiZmFsbGJhY2tMb2FkZXIiLCJFeHBvcnRlZEltYWdlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0Iiwib25Mb2FkIiwidW5vcHRpbWl6ZWQiLCJwbGFjZWhvbGRlciIsImFsdCIsImJsdXJEYXRhVVJMIiwic3R5bGUiLCJvbkVycm9yIiwicmVzdCIsInJlZiIsImltYWdlRXJyb3IiLCJzZXRJbWFnZUVycm9yIiwiYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCIsImlzU1ZHIiwiYmx1ckNvbXBsZXRlIiwic2V0Qmx1ckNvbXBsZXRlIiwiYmx1clN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJvYmplY3RGaXQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJvYmplY3RQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJjcmVhdGVFbGVtZW50IiwibG9hZGVyIiwiZSIsImVycm9yIiwidGFyZ2V0IiwibmF0dXJhbFdpZHRoIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\user\Desktop\Study\blogs\study-log\node_modules\next-image-export-optimizer\dist\ExportedImage.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ })

};
;