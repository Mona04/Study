"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst splitFilePath = ({ filePath })=>{\n    const filenameWithExtension = filePath.split(\"\\\\\").pop()?.split(\"/\").pop() || \"\";\n    const filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    const fileExtension = filePath.split(\".\").pop();\n    const filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nconst generateImageURL = (src, width, basePath, isRemoteImage = false)=>{\n    const { filename, path, extension } = splitFilePath({\n        filePath: src\n    });\n    const useWebp =  true ? \"true\" == \"true\" : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    let processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    let correctedPath = path;\n    const lastChar = correctedPath?.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    const isStaticImage = src.includes(\"_next/static/media\");\n    if (basePath) {\n        if (basePath.endsWith(\"/\") && correctedPath && correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + correctedPath.slice(1);\n        } else if (!basePath.endsWith(\"/\") && correctedPath && !correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + \"/\" + correctedPath;\n        } else {\n            correctedPath = basePath + correctedPath;\n        }\n    }\n    const exportFolderName = \"nextImageExportOptimizer\" || 0;\n    const basePathPrefixForStaticImages = basePath ? basePath + \"/\" : \"\";\n    let generatedImageURL = `${isStaticImage ? basePathPrefixForStaticImages : correctedPath}${exportFolderName}/${filename}-opt-${width}.${processedExtension.toUpperCase()}`;\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\nfunction urlToFilename(url) {\n    // Remove the protocol from the URL\n    let filename = url.replace(/^(https?|ftp):\\/\\//, \"\");\n    // Replace special characters with underscores\n    filename = filename.replace(/[/\\\\:*?\"<>|#%]/g, \"_\");\n    // Remove control characters\n    // eslint-disable-next-line no-control-regex\n    filename = filename.replace(/[\\x00-\\x1F\\x7F]/g, \"\");\n    // Trim any leading or trailing spaces\n    filename = filename.trim();\n    return filename;\n}\nconst imageURLForRemoteImage = ({ src, width, basePath })=>{\n    const encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, basePath, true);\n};\nconst optimizedLoader = ({ src, width, basePath })=>{\n    const isStaticImage = typeof src === \"object\";\n    const _src = isStaticImage ? src.src : src;\n    const originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        const deviceSizes = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.deviceSizes || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ];\n        const imageSizes = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.imageSizes || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ];\n        const allSizes = [\n            ...deviceSizes,\n            ...imageSizes\n        ];\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        let nextLargestSize = null;\n        for(let i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize, basePath);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width,\n            basePath\n        });\n    }\n    return generateImageURL(_src, width, basePath);\n};\nconst fallbackLoader = ({ src })=>{\n    let _src = typeof src === \"object\" ? src.src : src;\n    const isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nconst ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ src, priority = false, loading, className, width, height, onLoad, unoptimized, placeholder = \"blur\", basePath = \"\", alt = \"\", blurDataURL, style, onError, ...rest }, ref)=>{\n    const [imageError, setImageError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (blurDataURL) {\n            // use the user provided blurDataURL if present\n            return blurDataURL;\n        }\n        // check if the src is specified as a local file -> then it is an object\n        const isStaticImage = typeof src === \"object\";\n        let _src = isStaticImage ? src.src : src;\n        if (unoptimized === true) {\n            // return the src image when unoptimized\n            return _src;\n        }\n        // Check if the image is a remote image (starts with http or https)\n        if (_src.startsWith(\"http\")) {\n            return imageURLForRemoteImage({\n                src: _src,\n                width: 10,\n                basePath\n            });\n        }\n        // otherwise use the generated image of 10px width as a blurDataURL\n        return generateImageURL(_src, 10, basePath);\n    }, [\n        blurDataURL,\n        src,\n        unoptimized,\n        basePath\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    const isSVG = typeof src === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    const [blurComplete, setBlurComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    const blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: style?.objectFit || \"cover\",\n        backgroundPosition: style?.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(\"${automaticallyCalculatedBlurDataURL}\")`\n    } : undefined;\n    const isStaticImage = typeof src === \"object\";\n    let _src = isStaticImage ? src.src : src;\n    if (basePath && !isStaticImage && _src.startsWith(\"/\")) {\n        _src = basePath + _src;\n    }\n    if (basePath && !isStaticImage && !_src.startsWith(\"/\")) {\n        _src = basePath + \"/\" + _src;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n        ref: ref,\n        alt: alt,\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        ...onLoad && {\n            onLoad\n        },\n        ...placeholder && {\n            placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n        },\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        ...isSVG && {\n            unoptimized: true\n        },\n        style: {\n            ...style,\n            ...blurStyle\n        },\n        loader: imageError || unoptimized === true ? fallbackLoader : (e)=>optimizedLoader({\n                src,\n                width: e.width,\n                basePath\n            }),\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: (error)=>{\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            onError && onError(error);\n        },\n        onLoad: (e)=>{\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            const target = e.target;\n            if (target.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoad callback if present\n            onLoad && onLoad(e);\n        },\n        src: isStaticImage ? src : _src\n    });\n});\nExportedImage.displayName = \"ExportedImage\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzZEQUMrQjtBQUM4QjtBQUM3RCxNQUFNSyxnQkFBZ0IsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7SUFDL0IsTUFBTUMsd0JBQXdCRCxTQUFTRSxLQUFLLENBQUMsTUFBTUMsR0FBRyxJQUFJRCxNQUFNLEtBQUtDLFNBQVM7SUFDOUUsTUFBTUMsMEJBQTBCSixTQUFTRSxLQUFLLENBQUNELHVCQUF1QkksS0FBSztJQUMzRSxNQUFNQyxnQkFBZ0JOLFNBQVNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHO0lBQzdDLE1BQU1JLDJCQUEyQk4sc0JBQXNCTyxTQUFTLENBQUMsR0FBR1Asc0JBQXNCUSxXQUFXLENBQUMsU0FBU1I7SUFDL0csT0FBTztRQUNIUyxNQUFNTjtRQUNOTyxVQUFVSjtRQUNWSyxXQUFXTixpQkFBaUI7SUFDaEM7QUFDSjtBQUNBLE1BQU1PLG1CQUFtQixDQUFDQyxLQUFLQyxPQUFPQyxVQUFVQyxnQkFBZ0IsS0FBSztJQUNqRSxNQUFNLEVBQUVOLFFBQVEsRUFBRUQsSUFBSSxFQUFFRSxTQUFTLEVBQUUsR0FBR2IsY0FBYztRQUFFQyxVQUFVYztJQUFJO0lBQ3BFLE1BQU1JLFVBQVVDLEtBQXFFRyxHQUMvRUgsTUFBd0QsSUFBSSxTQUM1RCxDQUFJO0lBQ1YsSUFBSSxDQUFDO1FBQUM7UUFBTztRQUFRO1FBQVE7UUFBTztRQUFRO0tBQU0sQ0FBQ0ksUUFBUSxDQUFDWCxVQUFVWSxXQUFXLEtBQUs7UUFDbEYsMENBQTBDO1FBQzFDLHlCQUF5QjtRQUN6QixPQUFPVjtJQUNYO0lBQ0EseUVBQXlFO0lBQ3pFLCtDQUErQztJQUMvQyxJQUFJVyxxQkFBcUJiO0lBQ3pCLElBQUlNLFdBQ0E7UUFBQztRQUFPO1FBQVE7UUFBTztLQUFNLENBQUNLLFFBQVEsQ0FBQ1gsVUFBVVksV0FBVyxLQUFLO1FBQ2pF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QUtlLGdCQUFnQmYsTUFBTStCO0lBQUs7QUFDM0M7QUFDQVcsY0FBY2lDLFdBQVcsR0FBRztBQUM1QixpRUFBZWpDLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcz9lZjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IHNwbGl0RmlsZVBhdGggPSAoeyBmaWxlUGF0aCB9KSA9PiB7XG4gICAgY29uc3QgZmlsZW5hbWVXaXRoRXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoXCJcXFxcXCIpLnBvcCgpPy5zcGxpdChcIi9cIikucG9wKCkgfHwgXCJcIjtcbiAgICBjb25zdCBmaWxlUGF0aFdpdGhvdXRGaWxlbmFtZSA9IGZpbGVQYXRoLnNwbGl0KGZpbGVuYW1lV2l0aEV4dGVuc2lvbikuc2hpZnQoKTtcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgIGNvbnN0IGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiA9IGZpbGVuYW1lV2l0aEV4dGVuc2lvbi5zdWJzdHJpbmcoMCwgZmlsZW5hbWVXaXRoRXh0ZW5zaW9uLmxhc3RJbmRleE9mKFwiLlwiKSkgfHwgZmlsZW5hbWVXaXRoRXh0ZW5zaW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IGZpbGVQYXRoV2l0aG91dEZpbGVuYW1lLFxuICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLFxuICAgICAgICBleHRlbnNpb246IGZpbGVFeHRlbnNpb24gfHwgXCJcIixcbiAgICB9O1xufTtcbmNvbnN0IGdlbmVyYXRlSW1hZ2VVUkwgPSAoc3JjLCB3aWR0aCwgYmFzZVBhdGgsIGlzUmVtb3RlSW1hZ2UgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHsgZmlsZW5hbWUsIHBhdGgsIGV4dGVuc2lvbiB9ID0gc3BsaXRGaWxlUGF0aCh7IGZpbGVQYXRoOiBzcmMgfSk7XG4gICAgY29uc3QgdXNlV2VicCA9IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQICE9IHVuZGVmaW5lZFxuICAgICAgICA/IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQID09IFwidHJ1ZVwiXG4gICAgICAgIDogdHJ1ZTtcbiAgICBpZiAoIVtcIkpQR1wiLCBcIkpQRUdcIiwgXCJXRUJQXCIsIFwiUE5HXCIsIFwiQVZJRlwiLCBcIkdJRlwiXS5pbmNsdWRlcyhleHRlbnNpb24udG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgLy8gVGhlIGltYWdlcyBoYXMgYW4gdW5zdXBwb3J0ZWQgZXh0ZW5zaW9uXG4gICAgICAgIC8vIFdlIHdpbGwgcmV0dXJuIHRoZSBzcmNcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgLy8gSWYgdGhlIGltYWdlcyBhcmUgc3RvcmVkIGFzIFdFQlAgYnkgdGhlIHBhY2thZ2UsIHRoZW4gd2Ugc2hvdWxkIGNoYW5nZVxuICAgIC8vIHRoZSBleHRlbnNpb24gdG8gV0VCUCB0byBsb2FkIHRoZW0gY29ycmVjdGx5XG4gICAgbGV0IHByb2Nlc3NlZEV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgICBpZiAodXNlV2VicCAmJlxuICAgICAgICBbXCJKUEdcIiwgXCJKUEVHXCIsIFwiUE5HXCIsIFwiR0lGXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICBwcm9jZXNzZWRFeHRlbnNpb24gPSBcIldFQlBcIjtcbiAgICB9XG4gICAgbGV0IGNvcnJlY3RlZFBhdGggPSBwYXRoO1xuICAgIGNvbnN0IGxhc3RDaGFyID0gY29ycmVjdGVkUGF0aD8uc3Vic3RyKC0xKTsgLy8gU2VsZWN0cyB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICBpZiAobGFzdENoYXIgIT0gXCIvXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBhIHNsYXNoXG4gICAgICAgIGNvcnJlY3RlZFBhdGggPSBjb3JyZWN0ZWRQYXRoICsgXCIvXCI7IC8vIEFwcGVuZCBhIHNsYXNoIHRvIGl0LlxuICAgIH1cbiAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gc3JjLmluY2x1ZGVzKFwiX25leHQvc3RhdGljL21lZGlhXCIpO1xuICAgIGlmIChiYXNlUGF0aCkge1xuICAgICAgICBpZiAoYmFzZVBhdGguZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoICYmXG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoID0gYmFzZVBhdGggKyBjb3JyZWN0ZWRQYXRoLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggJiZcbiAgICAgICAgICAgICFjb3JyZWN0ZWRQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoID0gYmFzZVBhdGggKyBcIi9cIiArIGNvcnJlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3JyZWN0ZWRQYXRoID0gYmFzZVBhdGggKyBjb3JyZWN0ZWRQYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cG9ydEZvbGRlck5hbWUgPSBwcm9jZXNzLmVudi5uZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfZXhwb3J0Rm9sZGVyTmFtZSB8fFxuICAgICAgICBcIm5leHRJbWFnZUV4cG9ydE9wdGltaXplclwiO1xuICAgIGNvbnN0IGJhc2VQYXRoUHJlZml4Rm9yU3RhdGljSW1hZ2VzID0gYmFzZVBhdGggPyBiYXNlUGF0aCArIFwiL1wiIDogXCJcIjtcbiAgICBsZXQgZ2VuZXJhdGVkSW1hZ2VVUkwgPSBgJHtpc1N0YXRpY0ltYWdlID8gYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMgOiBjb3JyZWN0ZWRQYXRofSR7ZXhwb3J0Rm9sZGVyTmFtZX0vJHtmaWxlbmFtZX0tb3B0LSR7d2lkdGh9LiR7cHJvY2Vzc2VkRXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAvLyBpZiB0aGUgZ2VuZXJhdGVkSW1hZ2VVUkwgaXMgbm90IHN0YXJ0aW5nIHdpdGggYSBzbGFzaCwgdGhlbiB3ZSBhZGQgb25lIGFzIGxvbmcgYXMgaXQgaXMgbm90IGEgcmVtb3RlIGltYWdlXG4gICAgaWYgKCFpc1JlbW90ZUltYWdlICYmIGdlbmVyYXRlZEltYWdlVVJMLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgZ2VuZXJhdGVkSW1hZ2VVUkwgPSBcIi9cIiArIGdlbmVyYXRlZEltYWdlVVJMO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VVUkw7XG59O1xuZnVuY3Rpb24gdXJsVG9GaWxlbmFtZSh1cmwpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHByb3RvY29sIGZyb20gdGhlIFVSTFxuICAgIGxldCBmaWxlbmFtZSA9IHVybC5yZXBsYWNlKC9eKGh0dHBzP3xmdHApOlxcL1xcLy8sIFwiXCIpO1xuICAgIC8vIFJlcGxhY2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIHdpdGggdW5kZXJzY29yZXNcbiAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1svXFxcXDoqP1wiPD58IyVdL2csIFwiX1wiKTtcbiAgICAvLyBSZW1vdmUgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoL1tcXHgwMC1cXHgxRlxceDdGXS9nLCBcIlwiKTtcbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlc1xuICAgIGZpbGVuYW1lID0gZmlsZW5hbWUudHJpbSgpO1xuICAgIHJldHVybiBmaWxlbmFtZTtcbn1cbmNvbnN0IGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UgPSAoeyBzcmMsIHdpZHRoLCBiYXNlUGF0aCwgfSkgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRTcmMgPSB1cmxUb0ZpbGVuYW1lKHNyYyk7XG4gICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoZW5jb2RlZFNyYywgd2lkdGgsIGJhc2VQYXRoLCB0cnVlKTtcbn07XG5jb25zdCBvcHRpbWl6ZWRMb2FkZXIgPSAoeyBzcmMsIHdpZHRoLCBiYXNlUGF0aCwgfSkgPT4ge1xuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgIGNvbnN0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICBjb25zdCBvcmlnaW5hbEltYWdlV2lkdGggPSAoaXNTdGF0aWNJbWFnZSAmJiBzcmMud2lkdGgpIHx8IHVuZGVmaW5lZDtcbiAgICAvLyBpZiBpdCBpcyBhIHN0YXRpYyBpbWFnZSwgd2UgY2FuIHVzZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIGltYWdlIHRvIGdlbmVyYXRlIGEgcmVkdWNlZCBzcmNzZXQgdGhhdCByZXR1cm5zXG4gICAgLy8gdGhlIHNhbWUgaW1hZ2UgdXJsIGZvciB3aWR0aHMgdGhhdCBhcmUgbGFyZ2VyIHRoYW4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgaWYgKGlzU3RhdGljSW1hZ2UgJiYgb3JpZ2luYWxJbWFnZVdpZHRoICYmIHdpZHRoID4gb3JpZ2luYWxJbWFnZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFM/LmRldmljZVNpemVzIHx8IFtcbiAgICAgICAgICAgIDY0MCwgNzUwLCA4MjgsIDEwODAsIDEyMDAsIDE5MjAsIDIwNDgsIDM4NDAsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGltYWdlU2l6ZXMgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUz8uaW1hZ2VTaXplcyB8fCBbXG4gICAgICAgICAgICAxNiwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMjU2LCAzODQsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmRldmljZVNpemVzLCAuLi5pbWFnZVNpemVzXTtcbiAgICAgICAgLy8gb25seSB1c2UgdGhlIHdpZHRoIGlmIGl0IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8gdGhlIG5leHQgc2l6ZSBpbiB0aGUgYWxsU2l6ZXMgYXJyYXlcbiAgICAgICAgbGV0IG5leHRMYXJnZXN0U2l6ZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsU2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIoYWxsU2l6ZXNbaV0pID49IG9yaWdpbmFsSW1hZ2VXaWR0aCAmJlxuICAgICAgICAgICAgICAgIChuZXh0TGFyZ2VzdFNpemUgPT09IG51bGwgfHwgTnVtYmVyKGFsbFNpemVzW2ldKSA8IG5leHRMYXJnZXN0U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0TGFyZ2VzdFNpemUgPSBOdW1iZXIoYWxsU2l6ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0TGFyZ2VzdFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIG5leHRMYXJnZXN0U2l6ZSwgYmFzZVBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBpbWFnZSBpcyBhIHJlbW90ZSBpbWFnZSAoc3RhcnRzIHdpdGggaHR0cCBvciBodHRwcylcbiAgICBpZiAoX3NyYy5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICByZXR1cm4gaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSh7IHNyYzogX3NyYywgd2lkdGgsIGJhc2VQYXRoIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChfc3JjLCB3aWR0aCwgYmFzZVBhdGgpO1xufTtcbmNvbnN0IGZhbGxiYWNrTG9hZGVyID0gKHsgc3JjIH0pID0+IHtcbiAgICBsZXQgX3NyYyA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCIgPyBzcmMuc3JjIDogc3JjO1xuICAgIGNvbnN0IGlzUmVtb3RlSW1hZ2UgPSBfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpO1xuICAgIC8vIGlmIHRoZSBfc3JjIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzbGFzaCwgdGhlbiB3ZSBhZGQgb25lIGFzIGxvbmcgYXMgaXQgaXMgbm90IGEgcmVtb3RlIGltYWdlXG4gICAgaWYgKCFpc1JlbW90ZUltYWdlICYmIF9zcmMuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBfc3JjID0gXCIvXCIgKyBfc3JjO1xuICAgIH1cbiAgICByZXR1cm4gX3NyYztcbn07XG5jb25zdCBFeHBvcnRlZEltYWdlID0gZm9yd2FyZFJlZigoeyBzcmMsIHByaW9yaXR5ID0gZmFsc2UsIGxvYWRpbmcsIGNsYXNzTmFtZSwgd2lkdGgsIGhlaWdodCwgb25Mb2FkLCB1bm9wdGltaXplZCwgcGxhY2Vob2xkZXIgPSBcImJsdXJcIiwgYmFzZVBhdGggPSBcIlwiLCBhbHQgPSBcIlwiLCBibHVyRGF0YVVSTCwgc3R5bGUsIG9uRXJyb3IsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgW2ltYWdlRXJyb3IsIHNldEltYWdlRXJyb3JdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGJsdXJEYXRhVVJMKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHVzZXIgcHJvdmlkZWQgYmx1ckRhdGFVUkwgaWYgcHJlc2VudFxuICAgICAgICAgICAgcmV0dXJuIGJsdXJEYXRhVVJMO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzcmMgaXMgc3BlY2lmaWVkIGFzIGEgbG9jYWwgZmlsZSAtPiB0aGVuIGl0IGlzIGFuIG9iamVjdFxuICAgICAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgbGV0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICAgICAgaWYgKHVub3B0aW1pemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIHNyYyBpbWFnZSB3aGVuIHVub3B0aW1pemVkXG4gICAgICAgICAgICByZXR1cm4gX3NyYztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW1hZ2UgaXMgYSByZW1vdGUgaW1hZ2UgKHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHMpXG4gICAgICAgIGlmIChfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSh7IHNyYzogX3NyYywgd2lkdGg6IDEwLCBiYXNlUGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2Ugb2YgMTBweCB3aWR0aCBhcyBhIGJsdXJEYXRhVVJMXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIDEwLCBiYXNlUGF0aCk7XG4gICAgfSwgW2JsdXJEYXRhVVJMLCBzcmMsIHVub3B0aW1pemVkLCBiYXNlUGF0aF0pO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBzcmMgaXMgYSBTVkcgaW1hZ2UgLT4gdGhlbiB3ZSBzaG91bGQgbm90IHVzZSB0aGUgYmx1ckRhdGFVUkwgYW5kIHVzZSB1bm9wdGltaXplZFxuICAgIGNvbnN0IGlzU1ZHID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMuZW5kc1dpdGgoXCIuc3ZnXCIpIDogc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKTtcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0byBoYW5kbGUgdGhlIGJsdXJEYXRhVVJMIG91cnNlbHZlcyBhcyB0aGUgbmV3IEltYWdlIGNvbXBvbmVudFxuICAgIC8vIGlzIGV4cGVjdGluZyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZywgYnV0IHRoZSBnZW5lcmF0ZWQgYmx1ckRhdGFVUkwgaXMgYSBub3JtYWwgVVJMXG4gICAgY29uc3QgYmx1clN0eWxlID0gcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiICYmXG4gICAgICAgICFpc1NWRyAmJlxuICAgICAgICBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMICYmXG4gICAgICAgIGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwuc3RhcnRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgIWJsdXJDb21wbGV0ZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRTaXplOiBzdHlsZT8ub2JqZWN0Rml0IHx8IFwiY292ZXJcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogc3R5bGU/Lm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybChcIiR7YXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTH1cIilgLFxuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgIGxldCBfc3JjID0gaXNTdGF0aWNJbWFnZSA/IHNyYy5zcmMgOiBzcmM7XG4gICAgaWYgKGJhc2VQYXRoICYmICFpc1N0YXRpY0ltYWdlICYmIF9zcmMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgX3NyYyA9IGJhc2VQYXRoICsgX3NyYztcbiAgICB9XG4gICAgaWYgKGJhc2VQYXRoICYmICFpc1N0YXRpY0ltYWdlICYmICFfc3JjLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIF9zcmMgPSBiYXNlUGF0aCArIFwiL1wiICsgX3NyYztcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEltYWdlLCB7IHJlZjogcmVmLCBhbHQ6IGFsdCwgLi4ucmVzdCwgLi4uKHdpZHRoICYmIHsgd2lkdGggfSksIC4uLihoZWlnaHQgJiYgeyBoZWlnaHQgfSksIC4uLihsb2FkaW5nICYmIHsgbG9hZGluZyB9KSwgLi4uKGNsYXNzTmFtZSAmJiB7IGNsYXNzTmFtZSB9KSwgLi4uKG9uTG9hZCAmJiB7IG9uTG9hZCB9KSwgLi4uKHBsYWNlaG9sZGVyICYmIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBibHVyU3R5bGUgfHwgYmx1ckNvbXBsZXRlID8gXCJlbXB0eVwiIDogcGxhY2Vob2xkZXIsXG4gICAgICAgIH0pLCAuLi4odW5vcHRpbWl6ZWQgJiYgeyB1bm9wdGltaXplZCB9KSwgLi4uKHByaW9yaXR5ICYmIHsgcHJpb3JpdHkgfSksIC4uLihpc1NWRyAmJiB7IHVub3B0aW1pemVkOiB0cnVlIH0pLCBzdHlsZTogeyAuLi5zdHlsZSwgLi4uYmx1clN0eWxlIH0sIGxvYWRlcjogaW1hZ2VFcnJvciB8fCB1bm9wdGltaXplZCA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBmYWxsYmFja0xvYWRlclxuICAgICAgICAgICAgOiAoZSkgPT4gb3B0aW1pemVkTG9hZGVyKHsgc3JjLCB3aWR0aDogZS53aWR0aCwgYmFzZVBhdGggfSksIGJsdXJEYXRhVVJMOiBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMLCBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHNldEltYWdlRXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBvbkVycm9yIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9LCBvbkxvYWQ6IChlKSA9PiB7XG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjb25maWd1cmF0aW9ucywgdGhlIG9uRXJyb3IgaGFuZGxlciBpcyBub3QgY2FsbGVkIG9uIGFuIGVycm9yIG9jY3VycmVuY2VcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGltYWdlIGlzIGxvYWRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBCcm9rZW4gaW1hZ2UsIGZhbGwgYmFjayB0byB1bm9wdGltaXplZCAobWVhbmluZyB0aGUgb3JpZ2luYWwgaW1hZ2Ugc3JjKVxuICAgICAgICAgICAgICAgIHNldEltYWdlRXJyb3IodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBvbkxvYWQgY2FsbGJhY2sgaWYgcHJlc2VudFxuICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChlKTtcbiAgICAgICAgfSwgc3JjOiBpc1N0YXRpY0ltYWdlID8gc3JjIDogX3NyYyB9KSk7XG59KTtcbkV4cG9ydGVkSW1hZ2UuZGlzcGxheU5hbWUgPSBcIkV4cG9ydGVkSW1hZ2VcIjtcbmV4cG9ydCBkZWZhdWx0IEV4cG9ydGVkSW1hZ2U7XG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJSZWFjdCIsImZvcndhcmRSZWYiLCJ1c2VNZW1vIiwidXNlU3RhdGUiLCJzcGxpdEZpbGVQYXRoIiwiZmlsZVBhdGgiLCJmaWxlbmFtZVdpdGhFeHRlbnNpb24iLCJzcGxpdCIsInBvcCIsImZpbGVQYXRoV2l0aG91dEZpbGVuYW1lIiwic2hpZnQiLCJmaWxlRXh0ZW5zaW9uIiwiZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJwYXRoIiwiZmlsZW5hbWUiLCJleHRlbnNpb24iLCJnZW5lcmF0ZUltYWdlVVJMIiwic3JjIiwid2lkdGgiLCJiYXNlUGF0aCIsImlzUmVtb3RlSW1hZ2UiLCJ1c2VXZWJwIiwicHJvY2VzcyIsImVudiIsIm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQIiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJ0b1VwcGVyQ2FzZSIsInByb2Nlc3NlZEV4dGVuc2lvbiIsImNvcnJlY3RlZFBhdGgiLCJsYXN0Q2hhciIsInN1YnN0ciIsImlzU3RhdGljSW1hZ2UiLCJlbmRzV2l0aCIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImV4cG9ydEZvbGRlck5hbWUiLCJuZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfZXhwb3J0Rm9sZGVyTmFtZSIsImJhc2VQYXRoUHJlZml4Rm9yU3RhdGljSW1hZ2VzIiwiZ2VuZXJhdGVkSW1hZ2VVUkwiLCJjaGFyQXQiLCJ1cmxUb0ZpbGVuYW1lIiwidXJsIiwicmVwbGFjZSIsInRyaW0iLCJpbWFnZVVSTEZvclJlbW90ZUltYWdlIiwiZW5jb2RlZFNyYyIsIm9wdGltaXplZExvYWRlciIsIl9zcmMiLCJvcmlnaW5hbEltYWdlV2lkdGgiLCJkZXZpY2VTaXplcyIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiaW1hZ2VTaXplcyIsImFsbFNpemVzIiwibmV4dExhcmdlc3RTaXplIiwiaSIsImxlbmd0aCIsIk51bWJlciIsImZhbGxiYWNrTG9hZGVyIiwiRXhwb3J0ZWRJbWFnZSIsInByaW9yaXR5IiwibG9hZGluZyIsImNsYXNzTmFtZSIsImhlaWdodCIsIm9uTG9hZCIsInVub3B0aW1pemVkIiwicGxhY2Vob2xkZXIiLCJhbHQiLCJibHVyRGF0YVVSTCIsInN0eWxlIiwib25FcnJvciIsInJlc3QiLCJyZWYiLCJpbWFnZUVycm9yIiwic2V0SW1hZ2VFcnJvciIsImF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwiLCJpc1NWRyIsImJsdXJDb21wbGV0ZSIsInNldEJsdXJDb21wbGV0ZSIsImJsdXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwib2JqZWN0Rml0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwib2JqZWN0UG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZEltYWdlIiwiY3JlYXRlRWxlbWVudCIsImxvYWRlciIsImUiLCJlcnJvciIsInRhcmdldCIsIm5hdHVyYWxXaWR0aCIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\user\Desktop\study\blog\study-log\node_modules\next-image-export-optimizer\dist\ExportedImage.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ })

};
;