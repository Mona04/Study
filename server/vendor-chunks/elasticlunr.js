"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/elasticlunr";
exports.ids = ["vendor-chunks/elasticlunr"];
exports.modules = {

/***/ "(ssr)/./node_modules/elasticlunr/elasticlunr.js":
/*!*************************************************!*\
  !*** ./node_modules/elasticlunr/elasticlunr.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * elasticlunr - http://weixsong.github.io\n * Lightweight full-text search engine in Javascript for browser search and offline search. - 0.9.5\n *\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n * MIT Licensed\n * @license\n */ (function() {\n    /*!\n * elasticlunr.js\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * Convenience function for instantiating a new elasticlunr index and configuring it\n * with the default pipeline functions and the passed config function.\n *\n * When using this convenience function a new index will be created with the\n * following functions already in the pipeline:\n * \n * 1. elasticlunr.trimmer - trim non-word character\n * 2. elasticlunr.StopWordFilter - filters out any stop words before they enter the\n * index\n * 3. elasticlunr.stemmer - stems the tokens before entering the index.\n *\n *\n * Example:\n *\n *     var idx = elasticlunr(function () {\n *       this.addField('id');\n *       this.addField('title');\n *       this.addField('body');\n *       \n *       //this.setRef('id'); // default ref is 'id'\n *\n *       this.pipeline.add(function () {\n *         // some custom pipeline function\n *       });\n *     });\n * \n *    idx.addDoc({\n *      id: 1, \n *      title: 'Oracle released database 12g',\n *      body: 'Yestaday, Oracle has released their latest database, named 12g, more robust. this product will increase Oracle profit.'\n *    });\n * \n *    idx.addDoc({\n *      id: 2, \n *      title: 'Oracle released annual profit report',\n *      body: 'Yestaday, Oracle has released their annual profit report of 2015, total profit is 12.5 Billion.'\n *    });\n * \n *    # simple search\n *    idx.search('oracle database');\n * \n *    # search with query-time boosting\n *    idx.search('oracle database', {fields: {title: {boost: 2}, body: {boost: 1}}});\n *\n * @param {Function} config A function that will be called with the new instance\n * of the elasticlunr.Index as both its context and first parameter. It can be used to\n * customize the instance of new elasticlunr.Index.\n * @namespace\n * @module\n * @return {elasticlunr.Index}\n *\n */ var elasticlunr = function(config) {\n        var idx = new elasticlunr.Index;\n        idx.pipeline.add(elasticlunr.trimmer, elasticlunr.stopWordFilter, elasticlunr.stemmer);\n        if (config) config.call(idx, idx);\n        return idx;\n    };\n    elasticlunr.version = \"0.9.5\";\n    // only used this to make elasticlunr.js compatible with lunr-languages\n    // this is a trick to define a global alias of elasticlunr\n    lunr = elasticlunr;\n    /*!\n * elasticlunr.utils\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * A namespace containing utils for the rest of the elasticlunr library\n */ elasticlunr.utils = {};\n    /**\n * Print a warning message to the console.\n *\n * @param {String} message The message to be printed.\n * @memberOf Utils\n */ elasticlunr.utils.warn = function(global) {\n        return function(message) {\n            if (global.console && console.warn) {\n                console.warn(message);\n            }\n        };\n    }(this);\n    /**\n * Convert an object to string.\n *\n * In the case of `null` and `undefined` the function returns\n * an empty string, in all other cases the result of calling\n * `toString` on the passed object is returned.\n *\n * @param {object} obj The object to convert to a string.\n * @return {String} string representation of the passed object.\n * @memberOf Utils\n */ elasticlunr.utils.toString = function(obj) {\n        if (obj === void 0 || obj === null) {\n            return \"\";\n        }\n        return obj.toString();\n    };\n    /*!\n * elasticlunr.EventEmitter\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * elasticlunr.EventEmitter is an event emitter for elasticlunr.\n * It manages adding and removing event handlers and triggering events and their handlers.\n *\n * Each event could has multiple corresponding functions,\n * these functions will be called as the sequence that they are added into the event.\n * \n * @constructor\n */ elasticlunr.EventEmitter = function() {\n        this.events = {};\n    };\n    /**\n * Binds a handler function to a specific event(s).\n *\n * Can bind a single function to many different events in one call.\n *\n * @param {String} [eventName] The name(s) of events to bind this function to.\n * @param {Function} fn The function to call when an event is fired.\n * @memberOf EventEmitter\n */ elasticlunr.EventEmitter.prototype.addListener = function() {\n        var args = Array.prototype.slice.call(arguments), fn = args.pop(), names = args;\n        if (typeof fn !== \"function\") throw new TypeError(\"last argument must be a function\");\n        names.forEach(function(name) {\n            if (!this.hasHandler(name)) this.events[name] = [];\n            this.events[name].push(fn);\n        }, this);\n    };\n    /**\n * Removes a handler function from a specific event.\n *\n * @param {String} eventName The name of the event to remove this function from.\n * @param {Function} fn The function to remove from an event.\n * @memberOf EventEmitter\n */ elasticlunr.EventEmitter.prototype.removeListener = function(name, fn) {\n        if (!this.hasHandler(name)) return;\n        var fnIndex = this.events[name].indexOf(fn);\n        if (fnIndex === -1) return;\n        this.events[name].splice(fnIndex, 1);\n        if (this.events[name].length == 0) delete this.events[name];\n    };\n    /**\n * Call all functions that bounded to the given event.\n *\n * Additional data can be passed to the event handler as arguments to `emit`\n * after the event name.\n *\n * @param {String} eventName The name of the event to emit.\n * @memberOf EventEmitter\n */ elasticlunr.EventEmitter.prototype.emit = function(name) {\n        if (!this.hasHandler(name)) return;\n        var args = Array.prototype.slice.call(arguments, 1);\n        this.events[name].forEach(function(fn) {\n            fn.apply(undefined, args);\n        }, this);\n    };\n    /**\n * Checks whether a handler has ever been stored against an event.\n *\n * @param {String} eventName The name of the event to check.\n * @private\n * @memberOf EventEmitter\n */ elasticlunr.EventEmitter.prototype.hasHandler = function(name) {\n        return name in this.events;\n    };\n    /*!\n * elasticlunr.tokenizer\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * A function for splitting a string into tokens.\n * Currently English is supported as default.\n * Uses `elasticlunr.tokenizer.seperator` to split strings, you could change\n * the value of this property to set how you want strings are split into tokens.\n * IMPORTANT: use elasticlunr.tokenizer.seperator carefully, if you are not familiar with\n * text process, then you'd better not change it.\n *\n * @module\n * @param {String} str The string that you want to tokenize.\n * @see elasticlunr.tokenizer.seperator\n * @return {Array}\n */ elasticlunr.tokenizer = function(str) {\n        if (!arguments.length || str === null || str === undefined) return [];\n        if (Array.isArray(str)) {\n            var arr = str.filter(function(token) {\n                if (token === null || token === undefined) {\n                    return false;\n                }\n                return true;\n            });\n            arr = arr.map(function(t) {\n                return elasticlunr.utils.toString(t).toLowerCase();\n            });\n            var out = [];\n            arr.forEach(function(item) {\n                var tokens = item.split(elasticlunr.tokenizer.seperator);\n                out = out.concat(tokens);\n            }, this);\n            return out;\n        }\n        return str.toString().trim().toLowerCase().split(elasticlunr.tokenizer.seperator);\n    };\n    /**\n * Default string seperator.\n */ elasticlunr.tokenizer.defaultSeperator = /[\\s\\-]+/;\n    /**\n * The sperator used to split a string into tokens. Override this property to change the behaviour of\n * `elasticlunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.\n *\n * @static\n * @see elasticlunr.tokenizer\n */ elasticlunr.tokenizer.seperator = elasticlunr.tokenizer.defaultSeperator;\n    /**\n * Set up customized string seperator\n *\n * @param {Object} sep The customized seperator that you want to use to tokenize a string.\n */ elasticlunr.tokenizer.setSeperator = function(sep) {\n        if (sep !== null && sep !== undefined && typeof sep === \"object\") {\n            elasticlunr.tokenizer.seperator = sep;\n        }\n    };\n    /**\n * Reset string seperator\n *\n */ elasticlunr.tokenizer.resetSeperator = function() {\n        elasticlunr.tokenizer.seperator = elasticlunr.tokenizer.defaultSeperator;\n    };\n    /**\n * Get string seperator\n *\n */ elasticlunr.tokenizer.getSeperator = function() {\n        return elasticlunr.tokenizer.seperator;\n    };\n    /*!\n * elasticlunr.Pipeline\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * elasticlunr.Pipelines maintain an ordered list of functions to be applied to \n * both documents tokens and query tokens.\n *\n * An instance of elasticlunr.Index will contain a pipeline\n * with a trimmer, a stop word filter, an English stemmer. Extra\n * functions can be added before or after either of these functions or these\n * default functions can be removed.\n *\n * When run the pipeline, it will call each function in turn.\n *\n * The output of the functions in the pipeline will be passed to the next function\n * in the pipeline. To exclude a token from entering the index the function\n * should return undefined, the rest of the pipeline will not be called with\n * this token.\n *\n * For serialisation of pipelines to work, all functions used in an instance of\n * a pipeline should be registered with elasticlunr.Pipeline. Registered functions can\n * then be loaded. If trying to load a serialised pipeline that uses functions\n * that are not registered an error will be thrown.\n *\n * If not planning on serialising the pipeline then registering pipeline functions\n * is not necessary.\n *\n * @constructor\n */ elasticlunr.Pipeline = function() {\n        this._queue = [];\n    };\n    elasticlunr.Pipeline.registeredFunctions = {};\n    /**\n * Register a function in the pipeline.\n *\n * Functions that are used in the pipeline should be registered if the pipeline\n * needs to be serialised, or a serialised pipeline needs to be loaded.\n *\n * Registering a function does not add it to a pipeline, functions must still be\n * added to instances of the pipeline for them to be used when running a pipeline.\n *\n * @param {Function} fn The function to register.\n * @param {String} label The label to register this function with\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.registerFunction = function(fn, label) {\n        if (label in elasticlunr.Pipeline.registeredFunctions) {\n            elasticlunr.utils.warn(\"Overwriting existing registered function: \" + label);\n        }\n        fn.label = label;\n        elasticlunr.Pipeline.registeredFunctions[label] = fn;\n    };\n    /**\n * Get a registered function in the pipeline.\n *\n * @param {String} label The label of registered function.\n * @return {Function}\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.getRegisteredFunction = function(label) {\n        if (label in elasticlunr.Pipeline.registeredFunctions !== true) {\n            return null;\n        }\n        return elasticlunr.Pipeline.registeredFunctions[label];\n    };\n    /**\n * Warns if the function is not registered as a Pipeline function.\n *\n * @param {Function} fn The function to check for.\n * @private\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.warnIfFunctionNotRegistered = function(fn) {\n        var isRegistered = fn.label && fn.label in this.registeredFunctions;\n        if (!isRegistered) {\n            elasticlunr.utils.warn(\"Function is not registered with pipeline. This may cause problems when serialising the index.\\n\", fn);\n        }\n    };\n    /**\n * Loads a previously serialised pipeline.\n *\n * All functions to be loaded must already be registered with elasticlunr.Pipeline.\n * If any function from the serialised data has not been registered then an\n * error will be thrown.\n *\n * @param {Object} serialised The serialised pipeline to load.\n * @return {elasticlunr.Pipeline}\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.load = function(serialised) {\n        var pipeline = new elasticlunr.Pipeline;\n        serialised.forEach(function(fnName) {\n            var fn = elasticlunr.Pipeline.getRegisteredFunction(fnName);\n            if (fn) {\n                pipeline.add(fn);\n            } else {\n                throw new Error(\"Cannot load un-registered function: \" + fnName);\n            }\n        });\n        return pipeline;\n    };\n    /**\n * Adds new functions to the end of the pipeline.\n *\n * Logs a warning if the function has not been registered.\n *\n * @param {Function} functions Any number of functions to add to the pipeline.\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.add = function() {\n        var fns = Array.prototype.slice.call(arguments);\n        fns.forEach(function(fn) {\n            elasticlunr.Pipeline.warnIfFunctionNotRegistered(fn);\n            this._queue.push(fn);\n        }, this);\n    };\n    /**\n * Adds a single function after a function that already exists in the\n * pipeline.\n *\n * Logs a warning if the function has not been registered.\n * If existingFn is not found, throw an Exception.\n *\n * @param {Function} existingFn A function that already exists in the pipeline.\n * @param {Function} newFn The new function to add to the pipeline.\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.after = function(existingFn, newFn) {\n        elasticlunr.Pipeline.warnIfFunctionNotRegistered(newFn);\n        var pos = this._queue.indexOf(existingFn);\n        if (pos === -1) {\n            throw new Error(\"Cannot find existingFn\");\n        }\n        this._queue.splice(pos + 1, 0, newFn);\n    };\n    /**\n * Adds a single function before a function that already exists in the\n * pipeline.\n *\n * Logs a warning if the function has not been registered.\n * If existingFn is not found, throw an Exception.\n *\n * @param {Function} existingFn A function that already exists in the pipeline.\n * @param {Function} newFn The new function to add to the pipeline.\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.before = function(existingFn, newFn) {\n        elasticlunr.Pipeline.warnIfFunctionNotRegistered(newFn);\n        var pos = this._queue.indexOf(existingFn);\n        if (pos === -1) {\n            throw new Error(\"Cannot find existingFn\");\n        }\n        this._queue.splice(pos, 0, newFn);\n    };\n    /**\n * Removes a function from the pipeline.\n *\n * @param {Function} fn The function to remove from the pipeline.\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.remove = function(fn) {\n        var pos = this._queue.indexOf(fn);\n        if (pos === -1) {\n            return;\n        }\n        this._queue.splice(pos, 1);\n    };\n    /**\n * Runs the current list of functions that registered in the pipeline against the\n * input tokens.\n *\n * @param {Array} tokens The tokens to run through the pipeline.\n * @return {Array}\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.run = function(tokens) {\n        var out = [], tokenLength = tokens.length, pipelineLength = this._queue.length;\n        for(var i = 0; i < tokenLength; i++){\n            var token = tokens[i];\n            for(var j = 0; j < pipelineLength; j++){\n                token = this._queue[j](token, i, tokens);\n                if (token === void 0 || token === null) break;\n            }\n            ;\n            if (token !== void 0 && token !== null) out.push(token);\n        }\n        ;\n        return out;\n    };\n    /**\n * Resets the pipeline by removing any existing processors.\n *\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.reset = function() {\n        this._queue = [];\n    };\n    /**\n  * Get the pipeline if user want to check the pipeline.\n  *\n  * @memberOf Pipeline\n  */ elasticlunr.Pipeline.prototype.get = function() {\n        return this._queue;\n    };\n    /**\n * Returns a representation of the pipeline ready for serialisation.\n * Only serialize pipeline function's name. Not storing function, so when\n * loading the archived JSON index file, corresponding pipeline function is \n * added by registered function of elasticlunr.Pipeline.registeredFunctions\n *\n * Logs a warning if the function has not been registered.\n *\n * @return {Array}\n * @memberOf Pipeline\n */ elasticlunr.Pipeline.prototype.toJSON = function() {\n        return this._queue.map(function(fn) {\n            elasticlunr.Pipeline.warnIfFunctionNotRegistered(fn);\n            return fn.label;\n        });\n    };\n    /*!\n * elasticlunr.Index\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * elasticlunr.Index is object that manages a search index.  It contains the indexes\n * and stores all the tokens and document lookups.  It also provides the main\n * user facing API for the library.\n *\n * @constructor\n */ elasticlunr.Index = function() {\n        this._fields = [];\n        this._ref = \"id\";\n        this.pipeline = new elasticlunr.Pipeline;\n        this.documentStore = new elasticlunr.DocumentStore;\n        this.index = {};\n        this.eventEmitter = new elasticlunr.EventEmitter;\n        this._idfCache = {};\n        this.on(\"add\", \"remove\", \"update\", (function() {\n            this._idfCache = {};\n        }).bind(this));\n    };\n    /**\n * Bind a handler to events being emitted by the index.\n *\n * The handler can be bound to many events at the same time.\n *\n * @param {String} [eventName] The name(s) of events to bind the function to.\n * @param {Function} fn The serialised set to load.\n * @memberOf Index\n */ elasticlunr.Index.prototype.on = function() {\n        var args = Array.prototype.slice.call(arguments);\n        return this.eventEmitter.addListener.apply(this.eventEmitter, args);\n    };\n    /**\n * Removes a handler from an event being emitted by the index.\n *\n * @param {String} eventName The name of events to remove the function from.\n * @param {Function} fn The serialised set to load.\n * @memberOf Index\n */ elasticlunr.Index.prototype.off = function(name, fn) {\n        return this.eventEmitter.removeListener(name, fn);\n    };\n    /**\n * Loads a previously serialised index.\n *\n * Issues a warning if the index being imported was serialised\n * by a different version of elasticlunr.\n *\n * @param {Object} serialisedData The serialised set to load.\n * @return {elasticlunr.Index}\n * @memberOf Index\n */ elasticlunr.Index.load = function(serialisedData) {\n        if (serialisedData.version !== elasticlunr.version) {\n            elasticlunr.utils.warn(\"version mismatch: current \" + elasticlunr.version + \" importing \" + serialisedData.version);\n        }\n        var idx = new this;\n        idx._fields = serialisedData.fields;\n        idx._ref = serialisedData.ref;\n        idx.documentStore = elasticlunr.DocumentStore.load(serialisedData.documentStore);\n        idx.pipeline = elasticlunr.Pipeline.load(serialisedData.pipeline);\n        idx.index = {};\n        for(var field in serialisedData.index){\n            idx.index[field] = elasticlunr.InvertedIndex.load(serialisedData.index[field]);\n        }\n        return idx;\n    };\n    /**\n * Adds a field to the list of fields that will be searchable within documents in the index.\n *\n * Remember that inner index is build based on field, which means each field has one inverted index.\n *\n * Fields should be added before any documents are added to the index, fields\n * that are added after documents are added to the index will only apply to new\n * documents added to the index.\n *\n * @param {String} fieldName The name of the field within the document that should be indexed\n * @return {elasticlunr.Index}\n * @memberOf Index\n */ elasticlunr.Index.prototype.addField = function(fieldName) {\n        this._fields.push(fieldName);\n        this.index[fieldName] = new elasticlunr.InvertedIndex;\n        return this;\n    };\n    /**\n * Sets the property used to uniquely identify documents added to the index,\n * by default this property is 'id'.\n *\n * This should only be changed before adding documents to the index, changing\n * the ref property without resetting the index can lead to unexpected results.\n *\n * @param {String} refName The property to use to uniquely identify the\n * documents in the index.\n * @param {Boolean} emitEvent Whether to emit add events, defaults to true\n * @return {elasticlunr.Index}\n * @memberOf Index\n */ elasticlunr.Index.prototype.setRef = function(refName) {\n        this._ref = refName;\n        return this;\n    };\n    /**\n *\n * Set if the JSON format original documents are save into elasticlunr.DocumentStore\n *\n * Defaultly save all the original JSON documents.\n *\n * @param {Boolean} save Whether to save the original JSON documents.\n * @return {elasticlunr.Index}\n * @memberOf Index\n */ elasticlunr.Index.prototype.saveDocument = function(save) {\n        this.documentStore = new elasticlunr.DocumentStore(save);\n        return this;\n    };\n    /**\n * Add a JSON format document to the index.\n *\n * This is the way new documents enter the index, this function will run the\n * fields from the document through the index's pipeline and then add it to\n * the index, it will then show up in search results.\n *\n * An 'add' event is emitted with the document that has been added and the index\n * the document has been added to. This event can be silenced by passing false\n * as the second argument to add.\n *\n * @param {Object} doc The JSON format document to add to the index.\n * @param {Boolean} emitEvent Whether or not to emit events, default true.\n * @memberOf Index\n */ elasticlunr.Index.prototype.addDoc = function(doc, emitEvent) {\n        if (!doc) return;\n        var emitEvent = emitEvent === undefined ? true : emitEvent;\n        var docRef = doc[this._ref];\n        this.documentStore.addDoc(docRef, doc);\n        this._fields.forEach(function(field) {\n            var fieldTokens = this.pipeline.run(elasticlunr.tokenizer(doc[field]));\n            this.documentStore.addFieldLength(docRef, field, fieldTokens.length);\n            var tokenCount = {};\n            fieldTokens.forEach(function(token) {\n                if (token in tokenCount) tokenCount[token] += 1;\n                else tokenCount[token] = 1;\n            }, this);\n            for(var token in tokenCount){\n                var termFrequency = tokenCount[token];\n                termFrequency = Math.sqrt(termFrequency);\n                this.index[field].addToken(token, {\n                    ref: docRef,\n                    tf: termFrequency\n                });\n            }\n        }, this);\n        if (emitEvent) this.eventEmitter.emit(\"add\", doc, this);\n    };\n    /**\n * Removes a document from the index by doc ref.\n *\n * To make sure documents no longer show up in search results they can be\n * removed from the index using this method.\n *\n * A 'remove' event is emitted with the document that has been removed and the index\n * the document has been removed from. This event can be silenced by passing false\n * as the second argument to remove.\n *\n * If user setting DocumentStore not storing the documents, then remove doc by docRef is not allowed.\n *\n * @param {String|Integer} docRef The document ref to remove from the index.\n * @param {Boolean} emitEvent Whether to emit remove events, defaults to true\n * @memberOf Index\n */ elasticlunr.Index.prototype.removeDocByRef = function(docRef, emitEvent) {\n        if (!docRef) return;\n        if (this.documentStore.isDocStored() === false) {\n            return;\n        }\n        if (!this.documentStore.hasDoc(docRef)) return;\n        var doc = this.documentStore.getDoc(docRef);\n        this.removeDoc(doc, false);\n    };\n    /**\n * Removes a document from the index.\n * This remove operation could work even the original doc is not store in the DocumentStore.\n *\n * To make sure documents no longer show up in search results they can be\n * removed from the index using this method.\n *\n * A 'remove' event is emitted with the document that has been removed and the index\n * the document has been removed from. This event can be silenced by passing false\n * as the second argument to remove.\n *\n *\n * @param {Object} doc The document ref to remove from the index.\n * @param {Boolean} emitEvent Whether to emit remove events, defaults to true\n * @memberOf Index\n */ elasticlunr.Index.prototype.removeDoc = function(doc, emitEvent) {\n        if (!doc) return;\n        var emitEvent = emitEvent === undefined ? true : emitEvent;\n        var docRef = doc[this._ref];\n        if (!this.documentStore.hasDoc(docRef)) return;\n        this.documentStore.removeDoc(docRef);\n        this._fields.forEach(function(field) {\n            var fieldTokens = this.pipeline.run(elasticlunr.tokenizer(doc[field]));\n            fieldTokens.forEach(function(token) {\n                this.index[field].removeToken(token, docRef);\n            }, this);\n        }, this);\n        if (emitEvent) this.eventEmitter.emit(\"remove\", doc, this);\n    };\n    /**\n * Updates a document in the index.\n *\n * When a document contained within the index gets updated, fields changed,\n * added or removed, to make sure it correctly matched against search queries,\n * it should be updated in the index.\n *\n * This method is just a wrapper around `remove` and `add`\n *\n * An 'update' event is emitted with the document that has been updated and the index.\n * This event can be silenced by passing false as the second argument to update. Only\n * an update event will be fired, the 'add' and 'remove' events of the underlying calls\n * are silenced.\n *\n * @param {Object} doc The document to update in the index.\n * @param {Boolean} emitEvent Whether to emit update events, defaults to true\n * @see Index.prototype.remove\n * @see Index.prototype.add\n * @memberOf Index\n */ elasticlunr.Index.prototype.updateDoc = function(doc, emitEvent) {\n        var emitEvent = emitEvent === undefined ? true : emitEvent;\n        this.removeDocByRef(doc[this._ref], false);\n        this.addDoc(doc, false);\n        if (emitEvent) this.eventEmitter.emit(\"update\", doc, this);\n    };\n    /**\n * Calculates the inverse document frequency for a token within the index of a field.\n *\n * @param {String} token The token to calculate the idf of.\n * @param {String} field The field to compute idf.\n * @see Index.prototype.idf\n * @private\n * @memberOf Index\n */ elasticlunr.Index.prototype.idf = function(term, field) {\n        var cacheKey = \"@\" + field + \"/\" + term;\n        if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey];\n        var df = this.index[field].getDocFreq(term);\n        var idf = 1 + Math.log(this.documentStore.length / (df + 1));\n        this._idfCache[cacheKey] = idf;\n        return idf;\n    };\n    /**\n * get fields of current index instance\n *\n * @return {Array}\n */ elasticlunr.Index.prototype.getFields = function() {\n        return this._fields.slice();\n    };\n    /**\n * Searches the index using the passed query.\n * Queries should be a string, multiple words are allowed.\n *\n * If config is null, will search all fields defaultly, and lead to OR based query.\n * If config is specified, will search specified with query time boosting.\n *\n * All query tokens are passed through the same pipeline that document tokens\n * are passed through, so any language processing involved will be run on every\n * query term.\n *\n * Each query term is expanded, so that the term 'he' might be expanded to\n * 'hello' and 'help' if those terms were already included in the index.\n *\n * Matching documents are returned as an array of objects, each object contains\n * the matching document ref, as set for this index, and the similarity score\n * for this document against the query.\n *\n * @param {String} query The query to search the index with.\n * @param {JSON} userConfig The user query config, JSON format.\n * @return {Object}\n * @see Index.prototype.idf\n * @see Index.prototype.documentVector\n * @memberOf Index\n */ elasticlunr.Index.prototype.search = function(query, userConfig) {\n        if (!query) return [];\n        var configStr = null;\n        if (userConfig != null) {\n            configStr = JSON.stringify(userConfig);\n        }\n        var config = new elasticlunr.Configuration(configStr, this.getFields()).get();\n        var queryTokens = this.pipeline.run(elasticlunr.tokenizer(query));\n        var queryResults = {};\n        for(var field in config){\n            var fieldSearchResults = this.fieldSearch(queryTokens, field, config);\n            var fieldBoost = config[field].boost;\n            for(var docRef in fieldSearchResults){\n                fieldSearchResults[docRef] = fieldSearchResults[docRef] * fieldBoost;\n            }\n            for(var docRef in fieldSearchResults){\n                if (docRef in queryResults) {\n                    queryResults[docRef] += fieldSearchResults[docRef];\n                } else {\n                    queryResults[docRef] = fieldSearchResults[docRef];\n                }\n            }\n        }\n        var results = [];\n        for(var docRef in queryResults){\n            results.push({\n                ref: docRef,\n                score: queryResults[docRef]\n            });\n        }\n        results.sort(function(a, b) {\n            return b.score - a.score;\n        });\n        return results;\n    };\n    /**\n * search queryTokens in specified field.\n *\n * @param {Array} queryTokens The query tokens to query in this field.\n * @param {String} field Field to query in.\n * @param {elasticlunr.Configuration} config The user query config, JSON format.\n * @return {Object}\n */ elasticlunr.Index.prototype.fieldSearch = function(queryTokens, fieldName, config) {\n        var booleanType = config[fieldName].bool;\n        var expand = config[fieldName].expand;\n        var boost = config[fieldName].boost;\n        var scores = null;\n        var docTokens = {};\n        // Do nothing if the boost is 0\n        if (boost === 0) {\n            return;\n        }\n        queryTokens.forEach(function(token) {\n            var tokens = [\n                token\n            ];\n            if (expand == true) {\n                tokens = this.index[fieldName].expandToken(token);\n            }\n            // Consider every query token in turn. If expanded, each query token\n            // corresponds to a set of tokens, which is all tokens in the \n            // index matching the pattern queryToken* .\n            // For the set of tokens corresponding to a query token, find and score\n            // all matching documents. Store those scores in queryTokenScores, \n            // keyed by docRef.\n            // Then, depending on the value of booleanType, combine the scores\n            // for this query token with previous scores.  If booleanType is OR,\n            // then merge the scores by summing into the accumulated total, adding\n            // new document scores are required (effectively a union operator). \n            // If booleanType is AND, accumulate scores only if the document \n            // has previously been scored by another query token (an intersection\n            // operation0. \n            // Furthermore, since when booleanType is AND, additional \n            // query tokens can't add new documents to the result set, use the\n            // current document set to limit the processing of each new query \n            // token for efficiency (i.e., incremental intersection).\n            var queryTokenScores = {};\n            tokens.forEach(function(key) {\n                var docs = this.index[fieldName].getDocs(key);\n                var idf = this.idf(key, fieldName);\n                if (scores && booleanType == \"AND\") {\n                    // special case, we can rule out documents that have been\n                    // already been filtered out because they weren't scored\n                    // by previous query token passes.\n                    var filteredDocs = {};\n                    for(var docRef in scores){\n                        if (docRef in docs) {\n                            filteredDocs[docRef] = docs[docRef];\n                        }\n                    }\n                    docs = filteredDocs;\n                }\n                // only record appeared token for retrieved documents for the\n                // original token, not for expaned token.\n                // beause for doing coordNorm for a retrieved document, coordNorm only care how many\n                // query token appear in that document.\n                // so expanded token should not be added into docTokens, if added, this will pollute the\n                // coordNorm\n                if (key == token) {\n                    this.fieldSearchStats(docTokens, key, docs);\n                }\n                for(var docRef in docs){\n                    var tf = this.index[fieldName].getTermFrequency(key, docRef);\n                    var fieldLength = this.documentStore.getFieldLength(docRef, fieldName);\n                    var fieldLengthNorm = 1;\n                    if (fieldLength != 0) {\n                        fieldLengthNorm = 1 / Math.sqrt(fieldLength);\n                    }\n                    var penality = 1;\n                    if (key != token) {\n                        // currently I'm not sure if this penality is enough,\n                        // need to do verification\n                        penality = (1 - (key.length - token.length) / key.length) * 0.15;\n                    }\n                    var score = tf * idf * fieldLengthNorm * penality;\n                    if (docRef in queryTokenScores) {\n                        queryTokenScores[docRef] += score;\n                    } else {\n                        queryTokenScores[docRef] = score;\n                    }\n                }\n            }, this);\n            scores = this.mergeScores(scores, queryTokenScores, booleanType);\n        }, this);\n        scores = this.coordNorm(scores, docTokens, queryTokens.length);\n        return scores;\n    };\n    /**\n * Merge the scores from one set of tokens into an accumulated score table.\n * Exact operation depends on the op parameter. If op is 'AND', then only the\n * intersection of the two score lists is retained. Otherwise, the union of\n * the two score lists is returned. For internal use only.\n *\n * @param {Object} bool accumulated scores. Should be null on first call.\n * @param {String} scores new scores to merge into accumScores.\n * @param {Object} op merge operation (should be 'AND' or 'OR').\n *\n */ elasticlunr.Index.prototype.mergeScores = function(accumScores, scores, op) {\n        if (!accumScores) {\n            return scores;\n        }\n        if (op == \"AND\") {\n            var intersection = {};\n            for(var docRef in scores){\n                if (docRef in accumScores) {\n                    intersection[docRef] = accumScores[docRef] + scores[docRef];\n                }\n            }\n            return intersection;\n        } else {\n            for(var docRef in scores){\n                if (docRef in accumScores) {\n                    accumScores[docRef] += scores[docRef];\n                } else {\n                    accumScores[docRef] = scores[docRef];\n                }\n            }\n            return accumScores;\n        }\n    };\n    /**\n * Record the occuring query token of retrieved doc specified by doc field.\n * Only for inner user.\n *\n * @param {Object} docTokens a data structure stores which token appears in the retrieved doc.\n * @param {String} token query token\n * @param {Object} docs the retrieved documents of the query token\n *\n */ elasticlunr.Index.prototype.fieldSearchStats = function(docTokens, token, docs) {\n        for(var doc in docs){\n            if (doc in docTokens) {\n                docTokens[doc].push(token);\n            } else {\n                docTokens[doc] = [\n                    token\n                ];\n            }\n        }\n    };\n    /**\n * coord norm the score of a doc.\n * if a doc contain more query tokens, then the score will larger than the doc\n * contains less query tokens.\n *\n * only for inner use.\n *\n * @param {Object} results first results\n * @param {Object} docs field search results of a token\n * @param {Integer} n query token number\n * @return {Object}\n */ elasticlunr.Index.prototype.coordNorm = function(scores, docTokens, n) {\n        for(var doc in scores){\n            if (!(doc in docTokens)) continue;\n            var tokens = docTokens[doc].length;\n            scores[doc] = scores[doc] * tokens / n;\n        }\n        return scores;\n    };\n    /**\n * Returns a representation of the index ready for serialisation.\n *\n * @return {Object}\n * @memberOf Index\n */ elasticlunr.Index.prototype.toJSON = function() {\n        var indexJson = {};\n        this._fields.forEach(function(field) {\n            indexJson[field] = this.index[field].toJSON();\n        }, this);\n        return {\n            version: elasticlunr.version,\n            fields: this._fields,\n            ref: this._ref,\n            documentStore: this.documentStore.toJSON(),\n            index: indexJson,\n            pipeline: this.pipeline.toJSON()\n        };\n    };\n    /**\n * Applies a plugin to the current index.\n *\n * A plugin is a function that is called with the index as its context.\n * Plugins can be used to customise or extend the behaviour the index\n * in some way. A plugin is just a function, that encapsulated the custom\n * behaviour that should be applied to the index.\n *\n * The plugin function will be called with the index as its argument, additional\n * arguments can also be passed when calling use. The function will be called\n * with the index as its context.\n *\n * Example:\n *\n *     var myPlugin = function (idx, arg1, arg2) {\n *       // `this` is the index to be extended\n *       // apply any extensions etc here.\n *     }\n *\n *     var idx = elasticlunr(function () {\n *       this.use(myPlugin, 'arg1', 'arg2')\n *     })\n *\n * @param {Function} plugin The plugin to apply.\n * @memberOf Index\n */ elasticlunr.Index.prototype.use = function(plugin) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        args.unshift(this);\n        plugin.apply(this, args);\n    };\n    /*!\n * elasticlunr.DocumentStore\n * Copyright (C) 2016 Wei Song\n */ /**\n * elasticlunr.DocumentStore is a simple key-value document store used for storing sets of tokens for\n * documents stored in index.\n *\n * elasticlunr.DocumentStore store original JSON format documents that you could build search snippet by this original JSON document.\n *\n * user could choose whether original JSON format document should be store, if no configuration then document will be stored defaultly.\n * If user care more about the index size, user could select not store JSON documents, then this will has some defects, such as user\n * could not use JSON document to generate snippets of search results.\n *\n * @param {Boolean} save If the original JSON document should be stored.\n * @constructor\n * @module\n */ elasticlunr.DocumentStore = function(save) {\n        if (save === null || save === undefined) {\n            this._save = true;\n        } else {\n            this._save = save;\n        }\n        this.docs = {};\n        this.docInfo = {};\n        this.length = 0;\n    };\n    /**\n * Loads a previously serialised document store\n *\n * @param {Object} serialisedData The serialised document store to load.\n * @return {elasticlunr.DocumentStore}\n */ elasticlunr.DocumentStore.load = function(serialisedData) {\n        var store = new this;\n        store.length = serialisedData.length;\n        store.docs = serialisedData.docs;\n        store.docInfo = serialisedData.docInfo;\n        store._save = serialisedData.save;\n        return store;\n    };\n    /**\n * check if current instance store the original doc\n *\n * @return {Boolean}\n */ elasticlunr.DocumentStore.prototype.isDocStored = function() {\n        return this._save;\n    };\n    /**\n * Stores the given doc in the document store against the given id.\n * If docRef already exist, then update doc.\n *\n * Document is store by original JSON format, then you could use original document to generate search snippets.\n *\n * @param {Integer|String} docRef The key used to store the JSON format doc.\n * @param {Object} doc The JSON format doc.\n */ elasticlunr.DocumentStore.prototype.addDoc = function(docRef, doc) {\n        if (!this.hasDoc(docRef)) this.length++;\n        if (this._save === true) {\n            this.docs[docRef] = clone(doc);\n        } else {\n            this.docs[docRef] = null;\n        }\n    };\n    /**\n * Retrieves the JSON doc from the document store for a given key.\n *\n * If docRef not found, return null.\n * If user set not storing the documents, return null.\n *\n * @param {Integer|String} docRef The key to lookup and retrieve from the document store.\n * @return {Object}\n * @memberOf DocumentStore\n */ elasticlunr.DocumentStore.prototype.getDoc = function(docRef) {\n        if (this.hasDoc(docRef) === false) return null;\n        return this.docs[docRef];\n    };\n    /**\n * Checks whether the document store contains a key (docRef).\n *\n * @param {Integer|String} docRef The id to look up in the document store.\n * @return {Boolean}\n * @memberOf DocumentStore\n */ elasticlunr.DocumentStore.prototype.hasDoc = function(docRef) {\n        return docRef in this.docs;\n    };\n    /**\n * Removes the value for a key in the document store.\n *\n * @param {Integer|String} docRef The id to remove from the document store.\n * @memberOf DocumentStore\n */ elasticlunr.DocumentStore.prototype.removeDoc = function(docRef) {\n        if (!this.hasDoc(docRef)) return;\n        delete this.docs[docRef];\n        delete this.docInfo[docRef];\n        this.length--;\n    };\n    /**\n * Add field length of a document's field tokens from pipeline results.\n * The field length of a document is used to do field length normalization even without the original JSON document stored.\n *\n * @param {Integer|String} docRef document's id or reference\n * @param {String} fieldName field name\n * @param {Integer} length field length\n */ elasticlunr.DocumentStore.prototype.addFieldLength = function(docRef, fieldName, length) {\n        if (docRef === null || docRef === undefined) return;\n        if (this.hasDoc(docRef) == false) return;\n        if (!this.docInfo[docRef]) this.docInfo[docRef] = {};\n        this.docInfo[docRef][fieldName] = length;\n    };\n    /**\n * Update field length of a document's field tokens from pipeline results.\n * The field length of a document is used to do field length normalization even without the original JSON document stored.\n *\n * @param {Integer|String} docRef document's id or reference\n * @param {String} fieldName field name\n * @param {Integer} length field length\n */ elasticlunr.DocumentStore.prototype.updateFieldLength = function(docRef, fieldName, length) {\n        if (docRef === null || docRef === undefined) return;\n        if (this.hasDoc(docRef) == false) return;\n        this.addFieldLength(docRef, fieldName, length);\n    };\n    /**\n * get field length of a document by docRef\n *\n * @param {Integer|String} docRef document id or reference\n * @param {String} fieldName field name\n * @return {Integer} field length\n */ elasticlunr.DocumentStore.prototype.getFieldLength = function(docRef, fieldName) {\n        if (docRef === null || docRef === undefined) return 0;\n        if (!(docRef in this.docs)) return 0;\n        if (!(fieldName in this.docInfo[docRef])) return 0;\n        return this.docInfo[docRef][fieldName];\n    };\n    /**\n * Returns a JSON representation of the document store used for serialisation.\n *\n * @return {Object} JSON format\n * @memberOf DocumentStore\n */ elasticlunr.DocumentStore.prototype.toJSON = function() {\n        return {\n            docs: this.docs,\n            docInfo: this.docInfo,\n            length: this.length,\n            save: this._save\n        };\n    };\n    /**\n * Cloning object\n *\n * @param {Object} object in JSON format\n * @return {Object} copied object\n */ function clone(obj) {\n        if (null === obj || \"object\" !== typeof obj) return obj;\n        var copy = obj.constructor();\n        for(var attr in obj){\n            if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\n        }\n        return copy;\n    }\n    /*!\n * elasticlunr.stemmer\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n */ /**\n * elasticlunr.stemmer is an english language stemmer, this is a JavaScript\n * implementation of the PorterStemmer taken from http://tartarus.org/~martin\n *\n * @module\n * @param {String} str The string to stem\n * @return {String}\n * @see elasticlunr.Pipeline\n */ elasticlunr.stemmer = function() {\n        var step2list = {\n            \"ational\": \"ate\",\n            \"tional\": \"tion\",\n            \"enci\": \"ence\",\n            \"anci\": \"ance\",\n            \"izer\": \"ize\",\n            \"bli\": \"ble\",\n            \"alli\": \"al\",\n            \"entli\": \"ent\",\n            \"eli\": \"e\",\n            \"ousli\": \"ous\",\n            \"ization\": \"ize\",\n            \"ation\": \"ate\",\n            \"ator\": \"ate\",\n            \"alism\": \"al\",\n            \"iveness\": \"ive\",\n            \"fulness\": \"ful\",\n            \"ousness\": \"ous\",\n            \"aliti\": \"al\",\n            \"iviti\": \"ive\",\n            \"biliti\": \"ble\",\n            \"logi\": \"log\"\n        }, step3list = {\n            \"icate\": \"ic\",\n            \"ative\": \"\",\n            \"alize\": \"al\",\n            \"iciti\": \"ic\",\n            \"ical\": \"ic\",\n            \"ful\": \"\",\n            \"ness\": \"\"\n        }, c = \"[^aeiou]\", v = \"[aeiouy]\", C = c + \"[^aeiouy]*\", V = v + \"[aeiou]*\", mgr0 = \"^(\" + C + \")?\" + V + C, meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\", mgr1 = \"^(\" + C + \")?\" + V + C + V + C, s_v = \"^(\" + C + \")?\" + v; // vowel in stem\n        var re_mgr0 = new RegExp(mgr0);\n        var re_mgr1 = new RegExp(mgr1);\n        var re_meq1 = new RegExp(meq1);\n        var re_s_v = new RegExp(s_v);\n        var re_1a = /^(.+?)(ss|i)es$/;\n        var re2_1a = /^(.+?)([^s])s$/;\n        var re_1b = /^(.+?)eed$/;\n        var re2_1b = /^(.+?)(ed|ing)$/;\n        var re_1b_2 = /.$/;\n        var re2_1b_2 = /(at|bl|iz)$/;\n        var re3_1b_2 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n        var re4_1b_2 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n        var re_1c = /^(.+?[^aeiou])y$/;\n        var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n        var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n        var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n        var re2_4 = /^(.+?)(s|t)(ion)$/;\n        var re_5 = /^(.+?)e$/;\n        var re_5_1 = /ll$/;\n        var re3_5 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n        var porterStemmer = function porterStemmer(w) {\n            var stem, suffix, firstch, re, re2, re3, re4;\n            if (w.length < 3) {\n                return w;\n            }\n            firstch = w.substr(0, 1);\n            if (firstch == \"y\") {\n                w = firstch.toUpperCase() + w.substr(1);\n            }\n            // Step 1a\n            re = re_1a;\n            re2 = re2_1a;\n            if (re.test(w)) {\n                w = w.replace(re, \"$1$2\");\n            } else if (re2.test(w)) {\n                w = w.replace(re2, \"$1$2\");\n            }\n            // Step 1b\n            re = re_1b;\n            re2 = re2_1b;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                re = re_mgr0;\n                if (re.test(fp[1])) {\n                    re = re_1b_2;\n                    w = w.replace(re, \"\");\n                }\n            } else if (re2.test(w)) {\n                var fp = re2.exec(w);\n                stem = fp[1];\n                re2 = re_s_v;\n                if (re2.test(stem)) {\n                    w = stem;\n                    re2 = re2_1b_2;\n                    re3 = re3_1b_2;\n                    re4 = re4_1b_2;\n                    if (re2.test(w)) {\n                        w = w + \"e\";\n                    } else if (re3.test(w)) {\n                        re = re_1b_2;\n                        w = w.replace(re, \"\");\n                    } else if (re4.test(w)) {\n                        w = w + \"e\";\n                    }\n                }\n            }\n            // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)\n            re = re_1c;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                w = stem + \"i\";\n            }\n            // Step 2\n            re = re_2;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                suffix = fp[2];\n                re = re_mgr0;\n                if (re.test(stem)) {\n                    w = stem + step2list[suffix];\n                }\n            }\n            // Step 3\n            re = re_3;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                suffix = fp[2];\n                re = re_mgr0;\n                if (re.test(stem)) {\n                    w = stem + step3list[suffix];\n                }\n            }\n            // Step 4\n            re = re_4;\n            re2 = re2_4;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                re = re_mgr1;\n                if (re.test(stem)) {\n                    w = stem;\n                }\n            } else if (re2.test(w)) {\n                var fp = re2.exec(w);\n                stem = fp[1] + fp[2];\n                re2 = re_mgr1;\n                if (re2.test(stem)) {\n                    w = stem;\n                }\n            }\n            // Step 5\n            re = re_5;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                re = re_mgr1;\n                re2 = re_meq1;\n                re3 = re3_5;\n                if (re.test(stem) || re2.test(stem) && !re3.test(stem)) {\n                    w = stem;\n                }\n            }\n            re = re_5_1;\n            re2 = re_mgr1;\n            if (re.test(w) && re2.test(w)) {\n                re = re_1b_2;\n                w = w.replace(re, \"\");\n            }\n            // and turn initial Y back to y\n            if (firstch == \"y\") {\n                w = firstch.toLowerCase() + w.substr(1);\n            }\n            return w;\n        };\n        return porterStemmer;\n    }();\n    elasticlunr.Pipeline.registerFunction(elasticlunr.stemmer, \"stemmer\");\n    /*!\n * elasticlunr.stopWordFilter\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * elasticlunr.stopWordFilter is an English language stop words filter, any words\n * contained in the stop word list will not be passed through the filter.\n *\n * This is intended to be used in the Pipeline. If the token does not pass the\n * filter then undefined will be returned.\n * Currently this StopwordFilter using dictionary to do O(1) time complexity stop word filtering.\n *\n * @module\n * @param {String} token The token to pass through the filter\n * @return {String}\n * @see elasticlunr.Pipeline\n */ elasticlunr.stopWordFilter = function(token) {\n        if (token && elasticlunr.stopWordFilter.stopWords[token] !== true) {\n            return token;\n        }\n    };\n    /**\n * Remove predefined stop words\n * if user want to use customized stop words, user could use this function to delete\n * all predefined stopwords.\n *\n * @return {null}\n */ elasticlunr.clearStopWords = function() {\n        elasticlunr.stopWordFilter.stopWords = {};\n    };\n    /**\n * Add customized stop words\n * user could use this function to add customized stop words\n * \n * @params {Array} words customized stop words\n * @return {null}\n */ elasticlunr.addStopWords = function(words) {\n        if (words == null || Array.isArray(words) === false) return;\n        words.forEach(function(word) {\n            elasticlunr.stopWordFilter.stopWords[word] = true;\n        }, this);\n    };\n    /**\n * Reset to default stop words\n * user could use this function to restore default stop words\n *\n * @return {null}\n */ elasticlunr.resetStopWords = function() {\n        elasticlunr.stopWordFilter.stopWords = elasticlunr.defaultStopWords;\n    };\n    elasticlunr.defaultStopWords = {\n        \"\": true,\n        \"a\": true,\n        \"able\": true,\n        \"about\": true,\n        \"across\": true,\n        \"after\": true,\n        \"all\": true,\n        \"almost\": true,\n        \"also\": true,\n        \"am\": true,\n        \"among\": true,\n        \"an\": true,\n        \"and\": true,\n        \"any\": true,\n        \"are\": true,\n        \"as\": true,\n        \"at\": true,\n        \"be\": true,\n        \"because\": true,\n        \"been\": true,\n        \"but\": true,\n        \"by\": true,\n        \"can\": true,\n        \"cannot\": true,\n        \"could\": true,\n        \"dear\": true,\n        \"did\": true,\n        \"do\": true,\n        \"does\": true,\n        \"either\": true,\n        \"else\": true,\n        \"ever\": true,\n        \"every\": true,\n        \"for\": true,\n        \"from\": true,\n        \"get\": true,\n        \"got\": true,\n        \"had\": true,\n        \"has\": true,\n        \"have\": true,\n        \"he\": true,\n        \"her\": true,\n        \"hers\": true,\n        \"him\": true,\n        \"his\": true,\n        \"how\": true,\n        \"however\": true,\n        \"i\": true,\n        \"if\": true,\n        \"in\": true,\n        \"into\": true,\n        \"is\": true,\n        \"it\": true,\n        \"its\": true,\n        \"just\": true,\n        \"least\": true,\n        \"let\": true,\n        \"like\": true,\n        \"likely\": true,\n        \"may\": true,\n        \"me\": true,\n        \"might\": true,\n        \"most\": true,\n        \"must\": true,\n        \"my\": true,\n        \"neither\": true,\n        \"no\": true,\n        \"nor\": true,\n        \"not\": true,\n        \"of\": true,\n        \"off\": true,\n        \"often\": true,\n        \"on\": true,\n        \"only\": true,\n        \"or\": true,\n        \"other\": true,\n        \"our\": true,\n        \"own\": true,\n        \"rather\": true,\n        \"said\": true,\n        \"say\": true,\n        \"says\": true,\n        \"she\": true,\n        \"should\": true,\n        \"since\": true,\n        \"so\": true,\n        \"some\": true,\n        \"than\": true,\n        \"that\": true,\n        \"the\": true,\n        \"their\": true,\n        \"them\": true,\n        \"then\": true,\n        \"there\": true,\n        \"these\": true,\n        \"they\": true,\n        \"this\": true,\n        \"tis\": true,\n        \"to\": true,\n        \"too\": true,\n        \"twas\": true,\n        \"us\": true,\n        \"wants\": true,\n        \"was\": true,\n        \"we\": true,\n        \"were\": true,\n        \"what\": true,\n        \"when\": true,\n        \"where\": true,\n        \"which\": true,\n        \"while\": true,\n        \"who\": true,\n        \"whom\": true,\n        \"why\": true,\n        \"will\": true,\n        \"with\": true,\n        \"would\": true,\n        \"yet\": true,\n        \"you\": true,\n        \"your\": true\n    };\n    elasticlunr.stopWordFilter.stopWords = elasticlunr.defaultStopWords;\n    elasticlunr.Pipeline.registerFunction(elasticlunr.stopWordFilter, \"stopWordFilter\");\n    /*!\n * elasticlunr.trimmer\n * Copyright (C) 2016 Oliver Nightingale\n * Copyright (C) 2016 Wei Song\n */ /**\n * elasticlunr.trimmer is a pipeline function for trimming non word\n * characters from the begining and end of tokens before they\n * enter the index.\n *\n * This implementation may not work correctly for non latin\n * characters and should either be removed or adapted for use\n * with languages with non-latin characters.\n *\n * @module\n * @param {String} token The token to pass through the filter\n * @return {String}\n * @see elasticlunr.Pipeline\n */ elasticlunr.trimmer = function(token) {\n        if (token === null || token === undefined) {\n            throw new Error(\"token should not be undefined\");\n        }\n        return token.replace(/^\\W+/, \"\").replace(/\\W+$/, \"\");\n    };\n    elasticlunr.Pipeline.registerFunction(elasticlunr.trimmer, \"trimmer\");\n    /*!\n * elasticlunr.InvertedIndex\n * Copyright (C) 2016 Wei Song\n * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n */ /**\n * elasticlunr.InvertedIndex is used for efficiently storing and\n * lookup of documents that contain a given token.\n *\n * @constructor\n */ elasticlunr.InvertedIndex = function() {\n        this.root = {\n            docs: {},\n            df: 0\n        };\n    };\n    /**\n * Loads a previously serialised inverted index.\n *\n * @param {Object} serialisedData The serialised inverted index to load.\n * @return {elasticlunr.InvertedIndex}\n */ elasticlunr.InvertedIndex.load = function(serialisedData) {\n        var idx = new this;\n        idx.root = serialisedData.root;\n        return idx;\n    };\n    /**\n * Adds a {token: tokenInfo} pair to the inverted index.\n * If the token already exist, then update the tokenInfo.\n *\n * tokenInfo format: { ref: 1, tf: 2}\n * tokenInfor should contains the document's ref and the tf(token frequency) of that token in\n * the document.\n *\n * By default this function starts at the root of the current inverted index, however\n * it can start at any node of the inverted index if required.\n *\n * @param {String} token \n * @param {Object} tokenInfo format: { ref: 1, tf: 2}\n * @param {Object} root An optional node at which to start looking for the\n * correct place to enter the doc, by default the root of this elasticlunr.InvertedIndex\n * is used.\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.addToken = function(token, tokenInfo, root) {\n        var root = root || this.root, idx = 0;\n        while(idx <= token.length - 1){\n            var key = token[idx];\n            if (!(key in root)) root[key] = {\n                docs: {},\n                df: 0\n            };\n            idx += 1;\n            root = root[key];\n        }\n        var docRef = tokenInfo.ref;\n        if (!root.docs[docRef]) {\n            // if this doc not exist, then add this doc\n            root.docs[docRef] = {\n                tf: tokenInfo.tf\n            };\n            root.df += 1;\n        } else {\n            // if this doc already exist, then update tokenInfo\n            root.docs[docRef] = {\n                tf: tokenInfo.tf\n            };\n        }\n    };\n    /**\n * Checks whether a token is in this elasticlunr.InvertedIndex.\n * \n *\n * @param {String} token The token to be checked\n * @return {Boolean}\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.hasToken = function(token) {\n        if (!token) return false;\n        var node = this.root;\n        for(var i = 0; i < token.length; i++){\n            if (!node[token[i]]) return false;\n            node = node[token[i]];\n        }\n        return true;\n    };\n    /**\n * Retrieve a node from the inverted index for a given token.\n * If token not found in this InvertedIndex, return null.\n * \n *\n * @param {String} token The token to get the node for.\n * @return {Object}\n * @see InvertedIndex.prototype.get\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.getNode = function(token) {\n        if (!token) return null;\n        var node = this.root;\n        for(var i = 0; i < token.length; i++){\n            if (!node[token[i]]) return null;\n            node = node[token[i]];\n        }\n        return node;\n    };\n    /**\n * Retrieve the documents of a given token.\n * If token not found, return {}.\n *\n *\n * @param {String} token The token to get the documents for.\n * @return {Object}\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.getDocs = function(token) {\n        var node = this.getNode(token);\n        if (node == null) {\n            return {};\n        }\n        return node.docs;\n    };\n    /**\n * Retrieve term frequency of given token in given docRef.\n * If token or docRef not found, return 0.\n *\n *\n * @param {String} token The token to get the documents for.\n * @param {String|Integer} docRef\n * @return {Integer}\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.getTermFrequency = function(token, docRef) {\n        var node = this.getNode(token);\n        if (node == null) {\n            return 0;\n        }\n        if (!(docRef in node.docs)) {\n            return 0;\n        }\n        return node.docs[docRef].tf;\n    };\n    /**\n * Retrieve the document frequency of given token.\n * If token not found, return 0.\n *\n *\n * @param {String} token The token to get the documents for.\n * @return {Object}\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.getDocFreq = function(token) {\n        var node = this.getNode(token);\n        if (node == null) {\n            return 0;\n        }\n        return node.df;\n    };\n    /**\n * Remove the document identified by document's ref from the token in the inverted index.\n *\n *\n * @param {String} token Remove the document from which token.\n * @param {String} ref The ref of the document to remove from given token.\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.removeToken = function(token, ref) {\n        if (!token) return;\n        var node = this.getNode(token);\n        if (node == null) return;\n        if (ref in node.docs) {\n            delete node.docs[ref];\n            node.df -= 1;\n        }\n    };\n    /**\n * Find all the possible suffixes of given token using tokens currently in the inverted index.\n * If token not found, return empty Array.\n *\n * @param {String} token The token to expand.\n * @return {Array}\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.expandToken = function(token, memo, root) {\n        if (token == null || token == \"\") return [];\n        var memo = memo || [];\n        if (root == void 0) {\n            root = this.getNode(token);\n            if (root == null) return memo;\n        }\n        if (root.df > 0) memo.push(token);\n        for(var key in root){\n            if (key === \"docs\") continue;\n            if (key === \"df\") continue;\n            this.expandToken(token + key, memo, root[key]);\n        }\n        return memo;\n    };\n    /**\n * Returns a representation of the inverted index ready for serialisation.\n *\n * @return {Object}\n * @memberOf InvertedIndex\n */ elasticlunr.InvertedIndex.prototype.toJSON = function() {\n        return {\n            root: this.root\n        };\n    };\n    /*!\n * elasticlunr.Configuration\n * Copyright (C) 2016 Wei Song\n */ /** \n  * elasticlunr.Configuration is used to analyze the user search configuration.\n  * \n  * By elasticlunr.Configuration user could set query-time boosting, boolean model in each field.\n  * \n  * Currently configuration supports:\n  * 1. query-time boosting, user could set how to boost each field.\n  * 2. boolean model chosing, user could choose which boolean model to use for each field.\n  * 3. token expandation, user could set token expand to True to improve Recall. Default is False.\n  * \n  * Query time boosting must be configured by field category, \"boolean\" model could be configured \n  * by both field category or globally as the following example. Field configuration for \"boolean\"\n  * will overwrite global configuration.\n  * Token expand could be configured both by field category or golbally. Local field configuration will\n  * overwrite global configuration.\n  * \n  * configuration example:\n  * {\n  *   fields:{ \n  *     title: {boost: 2},\n  *     body: {boost: 1}\n  *   },\n  *   bool: \"OR\"\n  * }\n  * \n  * \"bool\" field configuation overwrite global configuation example:\n  * {\n  *   fields:{ \n  *     title: {boost: 2, bool: \"AND\"},\n  *     body: {boost: 1}\n  *   },\n  *   bool: \"OR\"\n  * }\n  * \n  * \"expand\" example:\n  * {\n  *   fields:{ \n  *     title: {boost: 2, bool: \"AND\"},\n  *     body: {boost: 1}\n  *   },\n  *   bool: \"OR\",\n  *   expand: true\n  * }\n  * \n  * \"expand\" example for field category:\n  * {\n  *   fields:{ \n  *     title: {boost: 2, bool: \"AND\", expand: true},\n  *     body: {boost: 1}\n  *   },\n  *   bool: \"OR\"\n  * }\n  * \n  * setting the boost to 0 ignores the field (this will only search the title):\n  * {\n  *   fields:{\n  *     title: {boost: 1},\n  *     body: {boost: 0}\n  *   }\n  * }\n  *\n  * then, user could search with configuration to do query-time boosting.\n  * idx.search('oracle database', {fields: {title: {boost: 2}, body: {boost: 1}}});\n  * \n  * \n  * @constructor\n  * \n  * @param {String} config user configuration\n  * @param {Array} fields fields of index instance\n  * @module\n  */ elasticlunr.Configuration = function(config, fields) {\n        var config = config || \"\";\n        if (fields == undefined || fields == null) {\n            throw new Error(\"fields should not be null\");\n        }\n        this.config = {};\n        var userConfig;\n        try {\n            userConfig = JSON.parse(config);\n            this.buildUserConfig(userConfig, fields);\n        } catch (error) {\n            elasticlunr.utils.warn(\"user configuration parse failed, will use default configuration\");\n            this.buildDefaultConfig(fields);\n        }\n    };\n    /**\n * Build default search configuration.\n * \n * @param {Array} fields fields of index instance\n */ elasticlunr.Configuration.prototype.buildDefaultConfig = function(fields) {\n        this.reset();\n        fields.forEach(function(field) {\n            this.config[field] = {\n                boost: 1,\n                bool: \"OR\",\n                expand: false\n            };\n        }, this);\n    };\n    /**\n * Build user configuration.\n * \n * @param {JSON} config User JSON configuratoin\n * @param {Array} fields fields of index instance\n */ elasticlunr.Configuration.prototype.buildUserConfig = function(config, fields) {\n        var global_bool = \"OR\";\n        var global_expand = false;\n        this.reset();\n        if (\"bool\" in config) {\n            global_bool = config[\"bool\"] || global_bool;\n        }\n        if (\"expand\" in config) {\n            global_expand = config[\"expand\"] || global_expand;\n        }\n        if (\"fields\" in config) {\n            for(var field in config[\"fields\"]){\n                if (fields.indexOf(field) > -1) {\n                    var field_config = config[\"fields\"][field];\n                    var field_expand = global_expand;\n                    if (field_config.expand != undefined) {\n                        field_expand = field_config.expand;\n                    }\n                    this.config[field] = {\n                        boost: field_config.boost || field_config.boost === 0 ? field_config.boost : 1,\n                        bool: field_config.bool || global_bool,\n                        expand: field_expand\n                    };\n                } else {\n                    elasticlunr.utils.warn(\"field name in user configuration not found in index instance fields\");\n                }\n            }\n        } else {\n            this.addAllFields2UserConfig(global_bool, global_expand, fields);\n        }\n    };\n    /**\n * Add all fields to user search configuration.\n * \n * @param {String} bool Boolean model\n * @param {String} expand Expand model\n * @param {Array} fields fields of index instance\n */ elasticlunr.Configuration.prototype.addAllFields2UserConfig = function(bool, expand, fields) {\n        fields.forEach(function(field) {\n            this.config[field] = {\n                boost: 1,\n                bool: bool,\n                expand: expand\n            };\n        }, this);\n    };\n    /**\n * get current user configuration\n */ elasticlunr.Configuration.prototype.get = function() {\n        return this.config;\n    };\n    /**\n * reset user search configuration.\n */ elasticlunr.Configuration.prototype.reset = function() {\n        this.config = {};\n    };\n    /**\n * sorted_set.js is added only to make elasticlunr.js compatible with lunr-languages.\n * if elasticlunr.js support different languages by default, this will make elasticlunr.js\n * much bigger that not good for browser usage.\n *\n */ /*!\n * lunr.SortedSet\n * Copyright (C) 2016 Oliver Nightingale\n */ /**\n * lunr.SortedSets are used to maintain an array of uniq values in a sorted\n * order.\n *\n * @constructor\n */ lunr.SortedSet = function() {\n        this.length = 0;\n        this.elements = [];\n    };\n    /**\n * Loads a previously serialised sorted set.\n *\n * @param {Array} serialisedData The serialised set to load.\n * @returns {lunr.SortedSet}\n * @memberOf SortedSet\n */ lunr.SortedSet.load = function(serialisedData) {\n        var set = new this;\n        set.elements = serialisedData;\n        set.length = serialisedData.length;\n        return set;\n    };\n    /**\n * Inserts new items into the set in the correct position to maintain the\n * order.\n *\n * @param {Object} The objects to add to this set.\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.add = function() {\n        var i, element;\n        for(i = 0; i < arguments.length; i++){\n            element = arguments[i];\n            if (~this.indexOf(element)) continue;\n            this.elements.splice(this.locationFor(element), 0, element);\n        }\n        this.length = this.elements.length;\n    };\n    /**\n * Converts this sorted set into an array.\n *\n * @returns {Array}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.toArray = function() {\n        return this.elements.slice();\n    };\n    /**\n * Creates a new array with the results of calling a provided function on every\n * element in this sorted set.\n *\n * Delegates to Array.prototype.map and has the same signature.\n *\n * @param {Function} fn The function that is called on each element of the\n * set.\n * @param {Object} ctx An optional object that can be used as the context\n * for the function fn.\n * @returns {Array}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.map = function(fn, ctx) {\n        return this.elements.map(fn, ctx);\n    };\n    /**\n * Executes a provided function once per sorted set element.\n *\n * Delegates to Array.prototype.forEach and has the same signature.\n *\n * @param {Function} fn The function that is called on each element of the\n * set.\n * @param {Object} ctx An optional object that can be used as the context\n * @memberOf SortedSet\n * for the function fn.\n */ lunr.SortedSet.prototype.forEach = function(fn, ctx) {\n        return this.elements.forEach(fn, ctx);\n    };\n    /**\n * Returns the index at which a given element can be found in the\n * sorted set, or -1 if it is not present.\n *\n * @param {Object} elem The object to locate in the sorted set.\n * @returns {Number}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.indexOf = function(elem) {\n        var start = 0, end = this.elements.length, sectionLength = end - start, pivot = start + Math.floor(sectionLength / 2), pivotElem = this.elements[pivot];\n        while(sectionLength > 1){\n            if (pivotElem === elem) return pivot;\n            if (pivotElem < elem) start = pivot;\n            if (pivotElem > elem) end = pivot;\n            sectionLength = end - start;\n            pivot = start + Math.floor(sectionLength / 2);\n            pivotElem = this.elements[pivot];\n        }\n        if (pivotElem === elem) return pivot;\n        return -1;\n    };\n    /**\n * Returns the position within the sorted set that an element should be\n * inserted at to maintain the current order of the set.\n *\n * This function assumes that the element to search for does not already exist\n * in the sorted set.\n *\n * @param {Object} elem The elem to find the position for in the set\n * @returns {Number}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.locationFor = function(elem) {\n        var start = 0, end = this.elements.length, sectionLength = end - start, pivot = start + Math.floor(sectionLength / 2), pivotElem = this.elements[pivot];\n        while(sectionLength > 1){\n            if (pivotElem < elem) start = pivot;\n            if (pivotElem > elem) end = pivot;\n            sectionLength = end - start;\n            pivot = start + Math.floor(sectionLength / 2);\n            pivotElem = this.elements[pivot];\n        }\n        if (pivotElem > elem) return pivot;\n        if (pivotElem < elem) return pivot + 1;\n    };\n    /**\n * Creates a new lunr.SortedSet that contains the elements in the intersection\n * of this set and the passed set.\n *\n * @param {lunr.SortedSet} otherSet The set to intersect with this set.\n * @returns {lunr.SortedSet}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.intersect = function(otherSet) {\n        var intersectSet = new lunr.SortedSet, i = 0, j = 0, a_len = this.length, b_len = otherSet.length, a = this.elements, b = otherSet.elements;\n        while(true){\n            if (i > a_len - 1 || j > b_len - 1) break;\n            if (a[i] === b[j]) {\n                intersectSet.add(a[i]);\n                i++, j++;\n                continue;\n            }\n            if (a[i] < b[j]) {\n                i++;\n                continue;\n            }\n            if (a[i] > b[j]) {\n                j++;\n                continue;\n            }\n        }\n        ;\n        return intersectSet;\n    };\n    /**\n * Makes a copy of this set\n *\n * @returns {lunr.SortedSet}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.clone = function() {\n        var clone = new lunr.SortedSet;\n        clone.elements = this.toArray();\n        clone.length = clone.elements.length;\n        return clone;\n    };\n    /**\n * Creates a new lunr.SortedSet that contains the elements in the union\n * of this set and the passed set.\n *\n * @param {lunr.SortedSet} otherSet The set to union with this set.\n * @returns {lunr.SortedSet}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.union = function(otherSet) {\n        var longSet, shortSet, unionSet;\n        if (this.length >= otherSet.length) {\n            longSet = this, shortSet = otherSet;\n        } else {\n            longSet = otherSet, shortSet = this;\n        }\n        unionSet = longSet.clone();\n        for(var i = 0, shortSetElements = shortSet.toArray(); i < shortSetElements.length; i++){\n            unionSet.add(shortSetElements[i]);\n        }\n        return unionSet;\n    };\n    /**\n * Returns a representation of the sorted set ready for serialisation.\n *\n * @returns {Array}\n * @memberOf SortedSet\n */ lunr.SortedSet.prototype.toJSON = function() {\n        return this.toArray();\n    } /**\n   * export the module via AMD, CommonJS or as a browser global\n   * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js\n   */ ;\n    (function(root, factory) {\n        if (true) {\n            // AMD. Register as an anonymous module.\n            !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else {}\n    })(this, function() {\n        /**\n     * Just return a value to define the module export.\n     * This example returns an object, but the module\n     * can return a function as the exported value.\n     */ return elasticlunr;\n    });\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWxhc3RpY2x1bnIvZWxhc3RpY2x1bnIuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7OztDQVFDLEdBRUE7SUFFRDs7OztDQUlDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvREMsR0FDRCxJQUFJQSxjQUFjLFNBQVVDLE1BQU07UUFDaEMsSUFBSUMsTUFBTSxJQUFJRixZQUFZRyxLQUFLO1FBRS9CRCxJQUFJRSxRQUFRLENBQUNDLEdBQUcsQ0FDZEwsWUFBWU0sT0FBTyxFQUNuQk4sWUFBWU8sY0FBYyxFQUMxQlAsWUFBWVEsT0FBTztRQUdyQixJQUFJUCxRQUFRQSxPQUFPUSxJQUFJLENBQUNQLEtBQUtBO1FBRTdCLE9BQU9BO0lBQ1Q7SUFFQUYsWUFBWVUsT0FBTyxHQUFHO0lBRXRCLHVFQUF1RTtJQUN2RSwwREFBMEQ7SUFDMURDLE9BQU9YO0lBRVA7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBQ0RBLFlBQVlZLEtBQUssR0FBRyxDQUFDO0lBRXJCOzs7OztDQUtDLEdBQ0RaLFlBQVlZLEtBQUssQ0FBQ0MsSUFBSSxHQUFHLFNBQVdDLE1BQU07UUFDeEMsT0FBTyxTQUFVQyxPQUFPO1lBQ3RCLElBQUlELE9BQU9FLE9BQU8sSUFBSUEsUUFBUUgsSUFBSSxFQUFFO2dCQUNsQ0csUUFBUUgsSUFBSSxDQUFDRTtZQUNmO1FBQ0Y7SUFDRixFQUFHLElBQUk7SUFFUDs7Ozs7Ozs7OztDQVVDLEdBQ0RmLFlBQVlZLEtBQUssQ0FBQ0ssUUFBUSxHQUFHLFNBQVVDLEdBQUc7UUFDeEMsSUFBSUEsUUFBUSxLQUFLLEtBQUtBLFFBQVEsTUFBTTtZQUNsQyxPQUFPO1FBQ1Q7UUFFQSxPQUFPQSxJQUFJRCxRQUFRO0lBQ3JCO0lBQ0E7Ozs7Q0FJQyxHQUVEOzs7Ozs7OztDQVFDLEdBQ0RqQixZQUFZbUIsWUFBWSxHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7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Q2tQLFVBQVUsSUFBSSxFQUFFQyxXQUFXTjtRQUM3QixPQUFPO1lBQ0xLLFVBQVVMLFVBQVVNLFdBQVcsSUFBSTtRQUNyQztRQUVBQyxXQUFXRixRQUFRN0YsS0FBSztRQUV4QixJQUFJLElBQUl0RyxJQUFJLEdBQUdzTSxtQkFBbUJGLFNBQVNoQixPQUFPLElBQUlwTCxJQUFJc00saUJBQWlCclAsTUFBTSxFQUFFK0MsSUFBSTtZQUNyRnFNLFNBQVN0UixHQUFHLENBQUN1UixnQkFBZ0IsQ0FBQ3RNLEVBQUU7UUFDbEM7UUFFQSxPQUFPcU07SUFDVDtJQUVBOzs7OztDQUtDLEdBQ0RoUixLQUFLMFAsU0FBUyxDQUFDaFAsU0FBUyxDQUFDcUUsTUFBTSxHQUFHO1FBQ2hDLE9BQU8sSUFBSSxDQUFDZ0wsT0FBTztJQUNyQixFQUNFOzs7R0FHQztJQUNDLFVBQVVwQixJQUFJLEVBQUV1QyxPQUFPO1FBQ3ZCLElBQUksSUFBMEMsRUFBRTtZQUM5Qyx3Q0FBd0M7WUFDeENDLG9DQUFPRCxPQUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtRQUNqQixPQUFPLEVBVU47SUFDSCxHQUFFLElBQUksRUFBRTtRQUNOOzs7O0tBSUMsR0FDRCxPQUFPN1I7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsYXN0aWNsdW5yL2VsYXN0aWNsdW5yLmpzPzU5NzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlbGFzdGljbHVuciAtIGh0dHA6Ly93ZWl4c29uZy5naXRodWIuaW9cbiAqIExpZ2h0d2VpZ2h0IGZ1bGwtdGV4dCBzZWFyY2ggZW5naW5lIGluIEphdmFzY3JpcHQgZm9yIGJyb3dzZXIgc2VhcmNoIGFuZCBvZmZsaW5lIHNlYXJjaC4gLSAwLjkuNVxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqIENvcHlyaWdodCAoQykgMjAxNiBXZWkgU29uZ1xuICogTUlUIExpY2Vuc2VkXG4gKiBAbGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpe1xuXG4vKiFcbiAqIGVsYXN0aWNsdW5yLmpzXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgV2VpIFNvbmdcbiAqL1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgbmV3IGVsYXN0aWNsdW5yIGluZGV4IGFuZCBjb25maWd1cmluZyBpdFxuICogd2l0aCB0aGUgZGVmYXVsdCBwaXBlbGluZSBmdW5jdGlvbnMgYW5kIHRoZSBwYXNzZWQgY29uZmlnIGZ1bmN0aW9uLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBhIG5ldyBpbmRleCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCB0aGVcbiAqIGZvbGxvd2luZyBmdW5jdGlvbnMgYWxyZWFkeSBpbiB0aGUgcGlwZWxpbmU6XG4gKiBcbiAqIDEuIGVsYXN0aWNsdW5yLnRyaW1tZXIgLSB0cmltIG5vbi13b3JkIGNoYXJhY3RlclxuICogMi4gZWxhc3RpY2x1bnIuU3RvcFdvcmRGaWx0ZXIgLSBmaWx0ZXJzIG91dCBhbnkgc3RvcCB3b3JkcyBiZWZvcmUgdGhleSBlbnRlciB0aGVcbiAqIGluZGV4XG4gKiAzLiBlbGFzdGljbHVuci5zdGVtbWVyIC0gc3RlbXMgdGhlIHRva2VucyBiZWZvcmUgZW50ZXJpbmcgdGhlIGluZGV4LlxuICpcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgaWR4ID0gZWxhc3RpY2x1bnIoZnVuY3Rpb24gKCkge1xuICogICAgICAgdGhpcy5hZGRGaWVsZCgnaWQnKTtcbiAqICAgICAgIHRoaXMuYWRkRmllbGQoJ3RpdGxlJyk7XG4gKiAgICAgICB0aGlzLmFkZEZpZWxkKCdib2R5Jyk7XG4gKiAgICAgICBcbiAqICAgICAgIC8vdGhpcy5zZXRSZWYoJ2lkJyk7IC8vIGRlZmF1bHQgcmVmIGlzICdpZCdcbiAqXG4gKiAgICAgICB0aGlzLnBpcGVsaW5lLmFkZChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIC8vIHNvbWUgY3VzdG9tIHBpcGVsaW5lIGZ1bmN0aW9uXG4gKiAgICAgICB9KTtcbiAqICAgICB9KTtcbiAqIFxuICogICAgaWR4LmFkZERvYyh7XG4gKiAgICAgIGlkOiAxLCBcbiAqICAgICAgdGl0bGU6ICdPcmFjbGUgcmVsZWFzZWQgZGF0YWJhc2UgMTJnJyxcbiAqICAgICAgYm9keTogJ1llc3RhZGF5LCBPcmFjbGUgaGFzIHJlbGVhc2VkIHRoZWlyIGxhdGVzdCBkYXRhYmFzZSwgbmFtZWQgMTJnLCBtb3JlIHJvYnVzdC4gdGhpcyBwcm9kdWN0IHdpbGwgaW5jcmVhc2UgT3JhY2xlIHByb2ZpdC4nXG4gKiAgICB9KTtcbiAqIFxuICogICAgaWR4LmFkZERvYyh7XG4gKiAgICAgIGlkOiAyLCBcbiAqICAgICAgdGl0bGU6ICdPcmFjbGUgcmVsZWFzZWQgYW5udWFsIHByb2ZpdCByZXBvcnQnLFxuICogICAgICBib2R5OiAnWWVzdGFkYXksIE9yYWNsZSBoYXMgcmVsZWFzZWQgdGhlaXIgYW5udWFsIHByb2ZpdCByZXBvcnQgb2YgMjAxNSwgdG90YWwgcHJvZml0IGlzIDEyLjUgQmlsbGlvbi4nXG4gKiAgICB9KTtcbiAqIFxuICogICAgIyBzaW1wbGUgc2VhcmNoXG4gKiAgICBpZHguc2VhcmNoKCdvcmFjbGUgZGF0YWJhc2UnKTtcbiAqIFxuICogICAgIyBzZWFyY2ggd2l0aCBxdWVyeS10aW1lIGJvb3N0aW5nXG4gKiAgICBpZHguc2VhcmNoKCdvcmFjbGUgZGF0YWJhc2UnLCB7ZmllbGRzOiB7dGl0bGU6IHtib29zdDogMn0sIGJvZHk6IHtib29zdDogMX19fSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgaW5zdGFuY2VcbiAqIG9mIHRoZSBlbGFzdGljbHVuci5JbmRleCBhcyBib3RoIGl0cyBjb250ZXh0IGFuZCBmaXJzdCBwYXJhbWV0ZXIuIEl0IGNhbiBiZSB1c2VkIHRvXG4gKiBjdXN0b21pemUgdGhlIGluc3RhbmNlIG9mIG5ldyBlbGFzdGljbHVuci5JbmRleC5cbiAqIEBuYW1lc3BhY2VcbiAqIEBtb2R1bGVcbiAqIEByZXR1cm4ge2VsYXN0aWNsdW5yLkluZGV4fVxuICpcbiAqL1xudmFyIGVsYXN0aWNsdW5yID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgaWR4ID0gbmV3IGVsYXN0aWNsdW5yLkluZGV4O1xuXG4gIGlkeC5waXBlbGluZS5hZGQoXG4gICAgZWxhc3RpY2x1bnIudHJpbW1lcixcbiAgICBlbGFzdGljbHVuci5zdG9wV29yZEZpbHRlcixcbiAgICBlbGFzdGljbHVuci5zdGVtbWVyXG4gICk7XG5cbiAgaWYgKGNvbmZpZykgY29uZmlnLmNhbGwoaWR4LCBpZHgpO1xuXG4gIHJldHVybiBpZHg7XG59O1xuXG5lbGFzdGljbHVuci52ZXJzaW9uID0gXCIwLjkuNVwiO1xuXG4vLyBvbmx5IHVzZWQgdGhpcyB0byBtYWtlIGVsYXN0aWNsdW5yLmpzIGNvbXBhdGlibGUgd2l0aCBsdW5yLWxhbmd1YWdlc1xuLy8gdGhpcyBpcyBhIHRyaWNrIHRvIGRlZmluZSBhIGdsb2JhbCBhbGlhcyBvZiBlbGFzdGljbHVuclxubHVuciA9IGVsYXN0aWNsdW5yO1xuXG4vKiFcbiAqIGVsYXN0aWNsdW5yLnV0aWxzXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgV2VpIFNvbmdcbiAqL1xuXG4vKipcbiAqIEEgbmFtZXNwYWNlIGNvbnRhaW5pbmcgdXRpbHMgZm9yIHRoZSByZXN0IG9mIHRoZSBlbGFzdGljbHVuciBsaWJyYXJ5XG4gKi9cbmVsYXN0aWNsdW5yLnV0aWxzID0ge307XG5cbi8qKlxuICogUHJpbnQgYSB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgcHJpbnRlZC5cbiAqIEBtZW1iZXJPZiBVdGlsc1xuICovXG5lbGFzdGljbHVuci51dGlscy53YXJuID0gKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKGdsb2JhbC5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbn0pKHRoaXMpO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIHN0cmluZy5cbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiBhbiBlbXB0eSBzdHJpbmcsIGluIGFsbCBvdGhlciBjYXNlcyB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAqIGB0b1N0cmluZ2Agb24gdGhlIHBhc3NlZCBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGFzc2VkIG9iamVjdC5cbiAqIEBtZW1iZXJPZiBVdGlsc1xuICovXG5lbGFzdGljbHVuci51dGlscy50b1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gdm9pZCAwIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIG9iai50b1N0cmluZygpO1xufTtcbi8qIVxuICogZWxhc3RpY2x1bnIuRXZlbnRFbWl0dGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgV2VpIFNvbmdcbiAqL1xuXG4vKipcbiAqIGVsYXN0aWNsdW5yLkV2ZW50RW1pdHRlciBpcyBhbiBldmVudCBlbWl0dGVyIGZvciBlbGFzdGljbHVuci5cbiAqIEl0IG1hbmFnZXMgYWRkaW5nIGFuZCByZW1vdmluZyBldmVudCBoYW5kbGVycyBhbmQgdHJpZ2dlcmluZyBldmVudHMgYW5kIHRoZWlyIGhhbmRsZXJzLlxuICpcbiAqIEVhY2ggZXZlbnQgY291bGQgaGFzIG11bHRpcGxlIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb25zLFxuICogdGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIGFzIHRoZSBzZXF1ZW5jZSB0aGF0IHRoZXkgYXJlIGFkZGVkIGludG8gdGhlIGV2ZW50LlxuICogXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZWxhc3RpY2x1bnIuRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmV2ZW50cyA9IHt9O1xufTtcblxuLyoqXG4gKiBCaW5kcyBhIGhhbmRsZXIgZnVuY3Rpb24gdG8gYSBzcGVjaWZpYyBldmVudChzKS5cbiAqXG4gKiBDYW4gYmluZCBhIHNpbmdsZSBmdW5jdGlvbiB0byBtYW55IGRpZmZlcmVudCBldmVudHMgaW4gb25lIGNhbGwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtldmVudE5hbWVdIFRoZSBuYW1lKHMpIG9mIGV2ZW50cyB0byBiaW5kIHRoaXMgZnVuY3Rpb24gdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIGV2ZW50IGlzIGZpcmVkLlxuICogQG1lbWJlck9mIEV2ZW50RW1pdHRlclxuICovXG5lbGFzdGljbHVuci5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICBmbiA9IGFyZ3MucG9wKCksXG4gICAgICBuYW1lcyA9IGFyZ3M7XG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yIChcImxhc3QgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gIG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaGFzSGFuZGxlcihuYW1lKSkgdGhpcy5ldmVudHNbbmFtZV0gPSBbXTtcbiAgICB0aGlzLmV2ZW50c1tuYW1lXS5wdXNoKGZuKTtcbiAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIGZyb20gYSBzcGVjaWZpYyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhpcyBmdW5jdGlvbiBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIGFuIGV2ZW50LlxuICogQG1lbWJlck9mIEV2ZW50RW1pdHRlclxuICovXG5lbGFzdGljbHVuci5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gIGlmICghdGhpcy5oYXNIYW5kbGVyKG5hbWUpKSByZXR1cm47XG5cbiAgdmFyIGZuSW5kZXggPSB0aGlzLmV2ZW50c1tuYW1lXS5pbmRleE9mKGZuKTtcbiAgaWYgKGZuSW5kZXggPT09IC0xKSByZXR1cm47XG5cbiAgdGhpcy5ldmVudHNbbmFtZV0uc3BsaWNlKGZuSW5kZXgsIDEpO1xuXG4gIGlmICh0aGlzLmV2ZW50c1tuYW1lXS5sZW5ndGggPT0gMCkgZGVsZXRlIHRoaXMuZXZlbnRzW25hbWVdO1xufTtcblxuLyoqXG4gKiBDYWxsIGFsbCBmdW5jdGlvbnMgdGhhdCBib3VuZGVkIHRvIHRoZSBnaXZlbiBldmVudC5cbiAqXG4gKiBBZGRpdGlvbmFsIGRhdGEgY2FuIGJlIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlciBhcyBhcmd1bWVudHMgdG8gYGVtaXRgXG4gKiBhZnRlciB0aGUgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0LlxuICogQG1lbWJlck9mIEV2ZW50RW1pdHRlclxuICovXG5lbGFzdGljbHVuci5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIXRoaXMuaGFzSGFuZGxlcihuYW1lKSkgcmV0dXJuO1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICB0aGlzLmV2ZW50c1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGhhbmRsZXIgaGFzIGV2ZXIgYmVlbiBzdG9yZWQgYWdhaW5zdCBhbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBjaGVjay5cbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyT2YgRXZlbnRFbWl0dGVyXG4gKi9cbmVsYXN0aWNsdW5yLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzSGFuZGxlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lIGluIHRoaXMuZXZlbnRzO1xufTtcbi8qIVxuICogZWxhc3RpY2x1bnIudG9rZW5pemVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgV2VpIFNvbmdcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gZm9yIHNwbGl0dGluZyBhIHN0cmluZyBpbnRvIHRva2Vucy5cbiAqIEN1cnJlbnRseSBFbmdsaXNoIGlzIHN1cHBvcnRlZCBhcyBkZWZhdWx0LlxuICogVXNlcyBgZWxhc3RpY2x1bnIudG9rZW5pemVyLnNlcGVyYXRvcmAgdG8gc3BsaXQgc3RyaW5ncywgeW91IGNvdWxkIGNoYW5nZVxuICogdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgdG8gc2V0IGhvdyB5b3Ugd2FudCBzdHJpbmdzIGFyZSBzcGxpdCBpbnRvIHRva2Vucy5cbiAqIElNUE9SVEFOVDogdXNlIGVsYXN0aWNsdW5yLnRva2VuaXplci5zZXBlcmF0b3IgY2FyZWZ1bGx5LCBpZiB5b3UgYXJlIG5vdCBmYW1pbGlhciB3aXRoXG4gKiB0ZXh0IHByb2Nlc3MsIHRoZW4geW91J2QgYmV0dGVyIG5vdCBjaGFuZ2UgaXQuXG4gKlxuICogQG1vZHVsZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgeW91IHdhbnQgdG8gdG9rZW5pemUuXG4gKiBAc2VlIGVsYXN0aWNsdW5yLnRva2VuaXplci5zZXBlcmF0b3JcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5lbGFzdGljbHVuci50b2tlbml6ZXIgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCBzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyKSkge1xuICAgIHZhciBhcnIgPSBzdHIuZmlsdGVyKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgYXJyID0gYXJyLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIGVsYXN0aWNsdW5yLnV0aWxzLnRvU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgb3V0ID0gW107XG4gICAgYXJyLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIHRva2VucyA9IGl0ZW0uc3BsaXQoZWxhc3RpY2x1bnIudG9rZW5pemVyLnNlcGVyYXRvcik7XG4gICAgICBvdXQgPSBvdXQuY29uY2F0KHRva2Vucyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgcmV0dXJuIHN0ci50b1N0cmluZygpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnNwbGl0KGVsYXN0aWNsdW5yLnRva2VuaXplci5zZXBlcmF0b3IpO1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmluZyBzZXBlcmF0b3IuXG4gKi9cbmVsYXN0aWNsdW5yLnRva2VuaXplci5kZWZhdWx0U2VwZXJhdG9yID0gL1tcXHNcXC1dKy87XG5cbi8qKlxuICogVGhlIHNwZXJhdG9yIHVzZWQgdG8gc3BsaXQgYSBzdHJpbmcgaW50byB0b2tlbnMuIE92ZXJyaWRlIHRoaXMgcHJvcGVydHkgdG8gY2hhbmdlIHRoZSBiZWhhdmlvdXIgb2ZcbiAqIGBlbGFzdGljbHVuci50b2tlbml6ZXJgIGJlaGF2aW91ciB3aGVuIHRva2VuaXppbmcgc3RyaW5ncy4gQnkgZGVmYXVsdCB0aGlzIHNwbGl0cyBvbiB3aGl0ZXNwYWNlIGFuZCBoeXBoZW5zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzZWUgZWxhc3RpY2x1bnIudG9rZW5pemVyXG4gKi9cbmVsYXN0aWNsdW5yLnRva2VuaXplci5zZXBlcmF0b3IgPSBlbGFzdGljbHVuci50b2tlbml6ZXIuZGVmYXVsdFNlcGVyYXRvcjtcblxuLyoqXG4gKiBTZXQgdXAgY3VzdG9taXplZCBzdHJpbmcgc2VwZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlcCBUaGUgY3VzdG9taXplZCBzZXBlcmF0b3IgdGhhdCB5b3Ugd2FudCB0byB1c2UgdG8gdG9rZW5pemUgYSBzdHJpbmcuXG4gKi9cbmVsYXN0aWNsdW5yLnRva2VuaXplci5zZXRTZXBlcmF0b3IgPSBmdW5jdGlvbihzZXApIHtcbiAgICBpZiAoc2VwICE9PSBudWxsICYmIHNlcCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZihzZXApID09PSAnb2JqZWN0Jykge1xuICAgICAgICBlbGFzdGljbHVuci50b2tlbml6ZXIuc2VwZXJhdG9yID0gc2VwO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXNldCBzdHJpbmcgc2VwZXJhdG9yXG4gKlxuICovXG5lbGFzdGljbHVuci50b2tlbml6ZXIucmVzZXRTZXBlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICBlbGFzdGljbHVuci50b2tlbml6ZXIuc2VwZXJhdG9yID0gZWxhc3RpY2x1bnIudG9rZW5pemVyLmRlZmF1bHRTZXBlcmF0b3I7XG59XG5cbi8qKlxuICogR2V0IHN0cmluZyBzZXBlcmF0b3JcbiAqXG4gKi9cbmVsYXN0aWNsdW5yLnRva2VuaXplci5nZXRTZXBlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZWxhc3RpY2x1bnIudG9rZW5pemVyLnNlcGVyYXRvcjtcbn1cbi8qIVxuICogZWxhc3RpY2x1bnIuUGlwZWxpbmVcbiAqIENvcHlyaWdodCAoQykgMjAxNiBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqIENvcHlyaWdodCAoQykgMjAxNiBXZWkgU29uZ1xuICovXG5cbi8qKlxuICogZWxhc3RpY2x1bnIuUGlwZWxpbmVzIG1haW50YWluIGFuIG9yZGVyZWQgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byBcbiAqIGJvdGggZG9jdW1lbnRzIHRva2VucyBhbmQgcXVlcnkgdG9rZW5zLlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIGVsYXN0aWNsdW5yLkluZGV4IHdpbGwgY29udGFpbiBhIHBpcGVsaW5lXG4gKiB3aXRoIGEgdHJpbW1lciwgYSBzdG9wIHdvcmQgZmlsdGVyLCBhbiBFbmdsaXNoIHN0ZW1tZXIuIEV4dHJhXG4gKiBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIGJlZm9yZSBvciBhZnRlciBlaXRoZXIgb2YgdGhlc2UgZnVuY3Rpb25zIG9yIHRoZXNlXG4gKiBkZWZhdWx0IGZ1bmN0aW9ucyBjYW4gYmUgcmVtb3ZlZC5cbiAqXG4gKiBXaGVuIHJ1biB0aGUgcGlwZWxpbmUsIGl0IHdpbGwgY2FsbCBlYWNoIGZ1bmN0aW9uIGluIHR1cm4uXG4gKlxuICogVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb25zIGluIHRoZSBwaXBlbGluZSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbmV4dCBmdW5jdGlvblxuICogaW4gdGhlIHBpcGVsaW5lLiBUbyBleGNsdWRlIGEgdG9rZW4gZnJvbSBlbnRlcmluZyB0aGUgaW5kZXggdGhlIGZ1bmN0aW9uXG4gKiBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZCwgdGhlIHJlc3Qgb2YgdGhlIHBpcGVsaW5lIHdpbGwgbm90IGJlIGNhbGxlZCB3aXRoXG4gKiB0aGlzIHRva2VuLlxuICpcbiAqIEZvciBzZXJpYWxpc2F0aW9uIG9mIHBpcGVsaW5lcyB0byB3b3JrLCBhbGwgZnVuY3Rpb25zIHVzZWQgaW4gYW4gaW5zdGFuY2Ugb2ZcbiAqIGEgcGlwZWxpbmUgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCBlbGFzdGljbHVuci5QaXBlbGluZS4gUmVnaXN0ZXJlZCBmdW5jdGlvbnMgY2FuXG4gKiB0aGVuIGJlIGxvYWRlZC4gSWYgdHJ5aW5nIHRvIGxvYWQgYSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRoYXQgdXNlcyBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIG5vdCByZWdpc3RlcmVkIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIElmIG5vdCBwbGFubmluZyBvbiBzZXJpYWxpc2luZyB0aGUgcGlwZWxpbmUgdGhlbiByZWdpc3RlcmluZyBwaXBlbGluZSBmdW5jdGlvbnNcbiAqIGlzIG5vdCBuZWNlc3NhcnkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9xdWV1ZSA9IFtdO1xufTtcblxuZWxhc3RpY2x1bnIuUGlwZWxpbmUucmVnaXN0ZXJlZEZ1bmN0aW9ucyA9IHt9O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gaW4gdGhlIHBpcGVsaW5lLlxuICpcbiAqIEZ1bmN0aW9ucyB0aGF0IGFyZSB1c2VkIGluIHRoZSBwaXBlbGluZSBzaG91bGQgYmUgcmVnaXN0ZXJlZCBpZiB0aGUgcGlwZWxpbmVcbiAqIG5lZWRzIHRvIGJlIHNlcmlhbGlzZWQsIG9yIGEgc2VyaWFsaXNlZCBwaXBlbGluZSBuZWVkcyB0byBiZSBsb2FkZWQuXG4gKlxuICogUmVnaXN0ZXJpbmcgYSBmdW5jdGlvbiBkb2VzIG5vdCBhZGQgaXQgdG8gYSBwaXBlbGluZSwgZnVuY3Rpb25zIG11c3Qgc3RpbGwgYmVcbiAqIGFkZGVkIHRvIGluc3RhbmNlcyBvZiB0aGUgcGlwZWxpbmUgZm9yIHRoZW0gdG8gYmUgdXNlZCB3aGVuIHJ1bm5pbmcgYSBwaXBlbGluZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgVGhlIGxhYmVsIHRvIHJlZ2lzdGVyIHRoaXMgZnVuY3Rpb24gd2l0aFxuICogQG1lbWJlck9mIFBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4sIGxhYmVsKSB7XG4gIGlmIChsYWJlbCBpbiBlbGFzdGljbHVuci5QaXBlbGluZS5yZWdpc3RlcmVkRnVuY3Rpb25zKSB7XG4gICAgZWxhc3RpY2x1bnIudXRpbHMud2FybignT3ZlcndyaXRpbmcgZXhpc3RpbmcgcmVnaXN0ZXJlZCBmdW5jdGlvbjogJyArIGxhYmVsKTtcbiAgfVxuXG4gIGZuLmxhYmVsID0gbGFiZWw7XG4gIGVsYXN0aWNsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyZWRGdW5jdGlvbnNbbGFiZWxdID0gZm47XG59O1xuXG4vKipcbiAqIEdldCBhIHJlZ2lzdGVyZWQgZnVuY3Rpb24gaW4gdGhlIHBpcGVsaW5lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgb2YgcmVnaXN0ZXJlZCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQG1lbWJlck9mIFBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLmdldFJlZ2lzdGVyZWRGdW5jdGlvbiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICBpZiAoKGxhYmVsIGluIGVsYXN0aWNsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyZWRGdW5jdGlvbnMpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxhc3RpY2x1bnIuUGlwZWxpbmUucmVnaXN0ZXJlZEZ1bmN0aW9uc1tsYWJlbF07XG59O1xuXG4vKipcbiAqIFdhcm5zIGlmIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVnaXN0ZXJlZCBhcyBhIFBpcGVsaW5lIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjaGVjayBmb3IuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIFBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZCA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaXNSZWdpc3RlcmVkID0gZm4ubGFiZWwgJiYgKGZuLmxhYmVsIGluIHRoaXMucmVnaXN0ZXJlZEZ1bmN0aW9ucyk7XG5cbiAgaWYgKCFpc1JlZ2lzdGVyZWQpIHtcbiAgICBlbGFzdGljbHVuci51dGlscy53YXJuKCdGdW5jdGlvbiBpcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHBpcGVsaW5lLiBUaGlzIG1heSBjYXVzZSBwcm9ibGVtcyB3aGVuIHNlcmlhbGlzaW5nIHRoZSBpbmRleC5cXG4nLCBmbik7XG4gIH1cbn07XG5cbi8qKlxuICogTG9hZHMgYSBwcmV2aW91c2x5IHNlcmlhbGlzZWQgcGlwZWxpbmUuXG4gKlxuICogQWxsIGZ1bmN0aW9ucyB0byBiZSBsb2FkZWQgbXVzdCBhbHJlYWR5IGJlIHJlZ2lzdGVyZWQgd2l0aCBlbGFzdGljbHVuci5QaXBlbGluZS5cbiAqIElmIGFueSBmdW5jdGlvbiBmcm9tIHRoZSBzZXJpYWxpc2VkIGRhdGEgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgdGhlbiBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGlzZWQgVGhlIHNlcmlhbGlzZWQgcGlwZWxpbmUgdG8gbG9hZC5cbiAqIEByZXR1cm4ge2VsYXN0aWNsdW5yLlBpcGVsaW5lfVxuICogQG1lbWJlck9mIFBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLmxvYWQgPSBmdW5jdGlvbiAoc2VyaWFsaXNlZCkge1xuICB2YXIgcGlwZWxpbmUgPSBuZXcgZWxhc3RpY2x1bnIuUGlwZWxpbmU7XG5cbiAgc2VyaWFsaXNlZC5mb3JFYWNoKGZ1bmN0aW9uIChmbk5hbWUpIHtcbiAgICB2YXIgZm4gPSBlbGFzdGljbHVuci5QaXBlbGluZS5nZXRSZWdpc3RlcmVkRnVuY3Rpb24oZm5OYW1lKTtcblxuICAgIGlmIChmbikge1xuICAgICAgcGlwZWxpbmUuYWRkKGZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB1bi1yZWdpc3RlcmVkIGZ1bmN0aW9uOiAnICsgZm5OYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwaXBlbGluZTtcbn07XG5cbi8qKlxuICogQWRkcyBuZXcgZnVuY3Rpb25zIHRvIHRoZSBlbmQgb2YgdGhlIHBpcGVsaW5lLlxuICpcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbnMgQW55IG51bWJlciBvZiBmdW5jdGlvbnMgdG8gYWRkIHRvIHRoZSBwaXBlbGluZS5cbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxuICovXG5lbGFzdGljbHVuci5QaXBlbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm5zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICBlbGFzdGljbHVuci5QaXBlbGluZS53YXJuSWZGdW5jdGlvbk5vdFJlZ2lzdGVyZWQoZm4pO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goZm4pO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHNpbmdsZSBmdW5jdGlvbiBhZnRlciBhIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlXG4gKiBwaXBlbGluZS5cbiAqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKiBJZiBleGlzdGluZ0ZuIGlzIG5vdCBmb3VuZCwgdGhyb3cgYW4gRXhjZXB0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4aXN0aW5nRm4gQSBmdW5jdGlvbiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBwaXBlbGluZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0ZuIFRoZSBuZXcgZnVuY3Rpb24gdG8gYWRkIHRvIHRoZSBwaXBlbGluZS5cbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxuICovXG5lbGFzdGljbHVuci5QaXBlbGluZS5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoZXhpc3RpbmdGbiwgbmV3Rm4pIHtcbiAgZWxhc3RpY2x1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKG5ld0ZuKTtcblxuICB2YXIgcG9zID0gdGhpcy5fcXVldWUuaW5kZXhPZihleGlzdGluZ0ZuKTtcbiAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGV4aXN0aW5nRm4nKTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXVlLnNwbGljZShwb3MgKyAxLCAwLCBuZXdGbik7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBzaW5nbGUgZnVuY3Rpb24gYmVmb3JlIGEgZnVuY3Rpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGVcbiAqIHBpcGVsaW5lLlxuICpcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cbiAqIElmIGV4aXN0aW5nRm4gaXMgbm90IGZvdW5kLCB0aHJvdyBhbiBFeGNlcHRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhpc3RpbmdGbiBBIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3Rm4gVGhlIG5ldyBmdW5jdGlvbiB0byBhZGQgdG8gdGhlIHBpcGVsaW5lLlxuICogQG1lbWJlck9mIFBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAoZXhpc3RpbmdGbiwgbmV3Rm4pIHtcbiAgZWxhc3RpY2x1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKG5ld0ZuKTtcblxuICB2YXIgcG9zID0gdGhpcy5fcXVldWUuaW5kZXhPZihleGlzdGluZ0ZuKTtcbiAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGV4aXN0aW5nRm4nKTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXVlLnNwbGljZShwb3MsIDAsIG5ld0ZuKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZ1bmN0aW9uIGZyb20gdGhlIHBpcGVsaW5lLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgcGlwZWxpbmUuXG4gKiBAbWVtYmVyT2YgUGlwZWxpbmVcbiAqL1xuZWxhc3RpY2x1bnIuUGlwZWxpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgcG9zID0gdGhpcy5fcXVldWUuaW5kZXhPZihmbik7XG4gIGlmIChwb3MgPT09IC0xKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcXVldWUuc3BsaWNlKHBvcywgMSk7XG59O1xuXG4vKipcbiAqIFJ1bnMgdGhlIGN1cnJlbnQgbGlzdCBvZiBmdW5jdGlvbnMgdGhhdCByZWdpc3RlcmVkIGluIHRoZSBwaXBlbGluZSBhZ2FpbnN0IHRoZVxuICogaW5wdXQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIHJ1biB0aHJvdWdoIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQG1lbWJlck9mIFBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHZhciBvdXQgPSBbXSxcbiAgICAgIHRva2VuTGVuZ3RoID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgIHBpcGVsaW5lTGVuZ3RoID0gdGhpcy5fcXVldWUubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGlwZWxpbmVMZW5ndGg7IGorKykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9xdWV1ZVtqXSh0b2tlbiwgaSwgdG9rZW5zKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwIHx8IHRva2VuID09PSBudWxsKSBicmVhaztcbiAgICB9O1xuXG4gICAgaWYgKHRva2VuICE9PSB2b2lkIDAgJiYgdG9rZW4gIT09IG51bGwpIG91dC5wdXNoKHRva2VuKTtcbiAgfTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHBpcGVsaW5lIGJ5IHJlbW92aW5nIGFueSBleGlzdGluZyBwcm9jZXNzb3JzLlxuICpcbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxuICovXG5lbGFzdGljbHVuci5QaXBlbGluZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3F1ZXVlID0gW107XG59O1xuXG4gLyoqXG4gICogR2V0IHRoZSBwaXBlbGluZSBpZiB1c2VyIHdhbnQgdG8gY2hlY2sgdGhlIHBpcGVsaW5lLlxuICAqXG4gICogQG1lbWJlck9mIFBpcGVsaW5lXG4gICovXG4gZWxhc3RpY2x1bnIuUGlwZWxpbmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9xdWV1ZTtcbiB9O1xuXG4vKipcbiAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGlwZWxpbmUgcmVhZHkgZm9yIHNlcmlhbGlzYXRpb24uXG4gKiBPbmx5IHNlcmlhbGl6ZSBwaXBlbGluZSBmdW5jdGlvbidzIG5hbWUuIE5vdCBzdG9yaW5nIGZ1bmN0aW9uLCBzbyB3aGVuXG4gKiBsb2FkaW5nIHRoZSBhcmNoaXZlZCBKU09OIGluZGV4IGZpbGUsIGNvcnJlc3BvbmRpbmcgcGlwZWxpbmUgZnVuY3Rpb24gaXMgXG4gKiBhZGRlZCBieSByZWdpc3RlcmVkIGZ1bmN0aW9uIG9mIGVsYXN0aWNsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyZWRGdW5jdGlvbnNcbiAqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAbWVtYmVyT2YgUGlwZWxpbmVcbiAqL1xuZWxhc3RpY2x1bnIuUGlwZWxpbmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3F1ZXVlLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICBlbGFzdGljbHVuci5QaXBlbGluZS53YXJuSWZGdW5jdGlvbk5vdFJlZ2lzdGVyZWQoZm4pO1xuICAgIHJldHVybiBmbi5sYWJlbDtcbiAgfSk7XG59O1xuLyohXG4gKiBlbGFzdGljbHVuci5JbmRleFxuICogQ29weXJpZ2h0IChDKSAyMDE2IE9saXZlciBOaWdodGluZ2FsZVxuICogQ29weXJpZ2h0IChDKSAyMDE2IFdlaSBTb25nXG4gKi9cblxuLyoqXG4gKiBlbGFzdGljbHVuci5JbmRleCBpcyBvYmplY3QgdGhhdCBtYW5hZ2VzIGEgc2VhcmNoIGluZGV4LiAgSXQgY29udGFpbnMgdGhlIGluZGV4ZXNcbiAqIGFuZCBzdG9yZXMgYWxsIHRoZSB0b2tlbnMgYW5kIGRvY3VtZW50IGxvb2t1cHMuICBJdCBhbHNvIHByb3ZpZGVzIHRoZSBtYWluXG4gKiB1c2VyIGZhY2luZyBBUEkgZm9yIHRoZSBsaWJyYXJ5LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5lbGFzdGljbHVuci5JbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZmllbGRzID0gW107XG4gIHRoaXMuX3JlZiA9ICdpZCc7XG4gIHRoaXMucGlwZWxpbmUgPSBuZXcgZWxhc3RpY2x1bnIuUGlwZWxpbmU7XG4gIHRoaXMuZG9jdW1lbnRTdG9yZSA9IG5ldyBlbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlO1xuICB0aGlzLmluZGV4ID0ge307XG4gIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IGVsYXN0aWNsdW5yLkV2ZW50RW1pdHRlcjtcbiAgdGhpcy5faWRmQ2FjaGUgPSB7fTtcblxuICB0aGlzLm9uKCdhZGQnLCAncmVtb3ZlJywgJ3VwZGF0ZScsIChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faWRmQ2FjaGUgPSB7fTtcbiAgfSkuYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEJpbmQgYSBoYW5kbGVyIHRvIGV2ZW50cyBiZWluZyBlbWl0dGVkIGJ5IHRoZSBpbmRleC5cbiAqXG4gKiBUaGUgaGFuZGxlciBjYW4gYmUgYm91bmQgdG8gbWFueSBldmVudHMgYXQgdGhlIHNhbWUgdGltZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2V2ZW50TmFtZV0gVGhlIG5hbWUocykgb2YgZXZlbnRzIHRvIGJpbmQgdGhlIGZ1bmN0aW9uIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHNlcmlhbGlzZWQgc2V0IHRvIGxvYWQuXG4gKiBAbWVtYmVyT2YgSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5hZGRMaXN0ZW5lci5hcHBseSh0aGlzLmV2ZW50RW1pdHRlciwgYXJncyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBoYW5kbGVyIGZyb20gYW4gZXZlbnQgYmVpbmcgZW1pdHRlZCBieSB0aGUgaW5kZXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiBldmVudHMgdG8gcmVtb3ZlIHRoZSBmdW5jdGlvbiBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHNlcmlhbGlzZWQgc2V0IHRvIGxvYWQuXG4gKiBAbWVtYmVyT2YgSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZm4pO1xufTtcblxuLyoqXG4gKiBMb2FkcyBhIHByZXZpb3VzbHkgc2VyaWFsaXNlZCBpbmRleC5cbiAqXG4gKiBJc3N1ZXMgYSB3YXJuaW5nIGlmIHRoZSBpbmRleCBiZWluZyBpbXBvcnRlZCB3YXMgc2VyaWFsaXNlZFxuICogYnkgYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiBlbGFzdGljbHVuci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXNlZERhdGEgVGhlIHNlcmlhbGlzZWQgc2V0IHRvIGxvYWQuXG4gKiBAcmV0dXJuIHtlbGFzdGljbHVuci5JbmRleH1cbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5sb2FkID0gZnVuY3Rpb24gKHNlcmlhbGlzZWREYXRhKSB7XG4gIGlmIChzZXJpYWxpc2VkRGF0YS52ZXJzaW9uICE9PSBlbGFzdGljbHVuci52ZXJzaW9uKSB7XG4gICAgZWxhc3RpY2x1bnIudXRpbHMud2FybigndmVyc2lvbiBtaXNtYXRjaDogY3VycmVudCAnXG4gICAgICAgICAgICAgICAgICAgICsgZWxhc3RpY2x1bnIudmVyc2lvbiArICcgaW1wb3J0aW5nICcgKyBzZXJpYWxpc2VkRGF0YS52ZXJzaW9uKTtcbiAgfVxuXG4gIHZhciBpZHggPSBuZXcgdGhpcztcblxuICBpZHguX2ZpZWxkcyA9IHNlcmlhbGlzZWREYXRhLmZpZWxkcztcbiAgaWR4Ll9yZWYgPSBzZXJpYWxpc2VkRGF0YS5yZWY7XG4gIGlkeC5kb2N1bWVudFN0b3JlID0gZWxhc3RpY2x1bnIuRG9jdW1lbnRTdG9yZS5sb2FkKHNlcmlhbGlzZWREYXRhLmRvY3VtZW50U3RvcmUpO1xuICBpZHgucGlwZWxpbmUgPSBlbGFzdGljbHVuci5QaXBlbGluZS5sb2FkKHNlcmlhbGlzZWREYXRhLnBpcGVsaW5lKTtcbiAgaWR4LmluZGV4ID0ge307XG4gIGZvciAodmFyIGZpZWxkIGluIHNlcmlhbGlzZWREYXRhLmluZGV4KSB7XG4gICAgaWR4LmluZGV4W2ZpZWxkXSA9IGVsYXN0aWNsdW5yLkludmVydGVkSW5kZXgubG9hZChzZXJpYWxpc2VkRGF0YS5pbmRleFtmaWVsZF0pO1xuICB9XG5cbiAgcmV0dXJuIGlkeDtcbn07XG5cbi8qKlxuICogQWRkcyBhIGZpZWxkIHRvIHRoZSBsaXN0IG9mIGZpZWxkcyB0aGF0IHdpbGwgYmUgc2VhcmNoYWJsZSB3aXRoaW4gZG9jdW1lbnRzIGluIHRoZSBpbmRleC5cbiAqXG4gKiBSZW1lbWJlciB0aGF0IGlubmVyIGluZGV4IGlzIGJ1aWxkIGJhc2VkIG9uIGZpZWxkLCB3aGljaCBtZWFucyBlYWNoIGZpZWxkIGhhcyBvbmUgaW52ZXJ0ZWQgaW5kZXguXG4gKlxuICogRmllbGRzIHNob3VsZCBiZSBhZGRlZCBiZWZvcmUgYW55IGRvY3VtZW50cyBhcmUgYWRkZWQgdG8gdGhlIGluZGV4LCBmaWVsZHNcbiAqIHRoYXQgYXJlIGFkZGVkIGFmdGVyIGRvY3VtZW50cyBhcmUgYWRkZWQgdG8gdGhlIGluZGV4IHdpbGwgb25seSBhcHBseSB0byBuZXdcbiAqIGRvY3VtZW50cyBhZGRlZCB0byB0aGUgaW5kZXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkTmFtZSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2l0aGluIHRoZSBkb2N1bWVudCB0aGF0IHNob3VsZCBiZSBpbmRleGVkXG4gKiBAcmV0dXJuIHtlbGFzdGljbHVuci5JbmRleH1cbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5wcm90b3R5cGUuYWRkRmllbGQgPSBmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gIHRoaXMuX2ZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XG4gIHRoaXMuaW5kZXhbZmllbGROYW1lXSA9IG5ldyBlbGFzdGljbHVuci5JbnZlcnRlZEluZGV4O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcHJvcGVydHkgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBkb2N1bWVudHMgYWRkZWQgdG8gdGhlIGluZGV4LFxuICogYnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzICdpZCcuXG4gKlxuICogVGhpcyBzaG91bGQgb25seSBiZSBjaGFuZ2VkIGJlZm9yZSBhZGRpbmcgZG9jdW1lbnRzIHRvIHRoZSBpbmRleCwgY2hhbmdpbmdcbiAqIHRoZSByZWYgcHJvcGVydHkgd2l0aG91dCByZXNldHRpbmcgdGhlIGluZGV4IGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVmTmFtZSBUaGUgcHJvcGVydHkgdG8gdXNlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZVxuICogZG9jdW1lbnRzIGluIHRoZSBpbmRleC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1pdEV2ZW50IFdoZXRoZXIgdG8gZW1pdCBhZGQgZXZlbnRzLCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtlbGFzdGljbHVuci5JbmRleH1cbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5wcm90b3R5cGUuc2V0UmVmID0gZnVuY3Rpb24gKHJlZk5hbWUpIHtcbiAgdGhpcy5fcmVmID0gcmVmTmFtZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBTZXQgaWYgdGhlIEpTT04gZm9ybWF0IG9yaWdpbmFsIGRvY3VtZW50cyBhcmUgc2F2ZSBpbnRvIGVsYXN0aWNsdW5yLkRvY3VtZW50U3RvcmVcbiAqXG4gKiBEZWZhdWx0bHkgc2F2ZSBhbGwgdGhlIG9yaWdpbmFsIEpTT04gZG9jdW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2F2ZSBXaGV0aGVyIHRvIHNhdmUgdGhlIG9yaWdpbmFsIEpTT04gZG9jdW1lbnRzLlxuICogQHJldHVybiB7ZWxhc3RpY2x1bnIuSW5kZXh9XG4gKiBAbWVtYmVyT2YgSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLnNhdmVEb2N1bWVudCA9IGZ1bmN0aW9uIChzYXZlKSB7XG4gIHRoaXMuZG9jdW1lbnRTdG9yZSA9IG5ldyBlbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlKHNhdmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgSlNPTiBmb3JtYXQgZG9jdW1lbnQgdG8gdGhlIGluZGV4LlxuICpcbiAqIFRoaXMgaXMgdGhlIHdheSBuZXcgZG9jdW1lbnRzIGVudGVyIHRoZSBpbmRleCwgdGhpcyBmdW5jdGlvbiB3aWxsIHJ1biB0aGVcbiAqIGZpZWxkcyBmcm9tIHRoZSBkb2N1bWVudCB0aHJvdWdoIHRoZSBpbmRleCdzIHBpcGVsaW5lIGFuZCB0aGVuIGFkZCBpdCB0b1xuICogdGhlIGluZGV4LCBpdCB3aWxsIHRoZW4gc2hvdyB1cCBpbiBzZWFyY2ggcmVzdWx0cy5cbiAqXG4gKiBBbiAnYWRkJyBldmVudCBpcyBlbWl0dGVkIHdpdGggdGhlIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gYWRkZWQgYW5kIHRoZSBpbmRleFxuICogdGhlIGRvY3VtZW50IGhhcyBiZWVuIGFkZGVkIHRvLiBUaGlzIGV2ZW50IGNhbiBiZSBzaWxlbmNlZCBieSBwYXNzaW5nIGZhbHNlXG4gKiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGFkZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBKU09OIGZvcm1hdCBkb2N1bWVudCB0byBhZGQgdG8gdGhlIGluZGV4LlxuICogQHBhcmFtIHtCb29sZWFufSBlbWl0RXZlbnQgV2hldGhlciBvciBub3QgdG8gZW1pdCBldmVudHMsIGRlZmF1bHQgdHJ1ZS5cbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5wcm90b3R5cGUuYWRkRG9jID0gZnVuY3Rpb24gKGRvYywgZW1pdEV2ZW50KSB7XG4gIGlmICghZG9jKSByZXR1cm47XG4gIHZhciBlbWl0RXZlbnQgPSBlbWl0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBlbWl0RXZlbnQ7XG5cbiAgdmFyIGRvY1JlZiA9IGRvY1t0aGlzLl9yZWZdO1xuXG4gIHRoaXMuZG9jdW1lbnRTdG9yZS5hZGREb2MoZG9jUmVmLCBkb2MpO1xuICB0aGlzLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZmllbGRUb2tlbnMgPSB0aGlzLnBpcGVsaW5lLnJ1bihlbGFzdGljbHVuci50b2tlbml6ZXIoZG9jW2ZpZWxkXSkpO1xuICAgIHRoaXMuZG9jdW1lbnRTdG9yZS5hZGRGaWVsZExlbmd0aChkb2NSZWYsIGZpZWxkLCBmaWVsZFRva2Vucy5sZW5ndGgpO1xuXG4gICAgdmFyIHRva2VuQ291bnQgPSB7fTtcbiAgICBmaWVsZFRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgaWYgKHRva2VuIGluIHRva2VuQ291bnQpIHRva2VuQ291bnRbdG9rZW5dICs9IDE7XG4gICAgICBlbHNlIHRva2VuQ291bnRbdG9rZW5dID0gMTtcbiAgICB9LCB0aGlzKTtcblxuICAgIGZvciAodmFyIHRva2VuIGluIHRva2VuQ291bnQpIHtcbiAgICAgIHZhciB0ZXJtRnJlcXVlbmN5ID0gdG9rZW5Db3VudFt0b2tlbl07XG4gICAgICB0ZXJtRnJlcXVlbmN5ID0gTWF0aC5zcXJ0KHRlcm1GcmVxdWVuY3kpO1xuICAgICAgdGhpcy5pbmRleFtmaWVsZF0uYWRkVG9rZW4odG9rZW4sIHsgcmVmOiBkb2NSZWYsIHRmOiB0ZXJtRnJlcXVlbmN5IH0pO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgaWYgKGVtaXRFdmVudCkgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnYWRkJywgZG9jLCB0aGlzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGRvY3VtZW50IGZyb20gdGhlIGluZGV4IGJ5IGRvYyByZWYuXG4gKlxuICogVG8gbWFrZSBzdXJlIGRvY3VtZW50cyBubyBsb25nZXIgc2hvdyB1cCBpbiBzZWFyY2ggcmVzdWx0cyB0aGV5IGNhbiBiZVxuICogcmVtb3ZlZCBmcm9tIHRoZSBpbmRleCB1c2luZyB0aGlzIG1ldGhvZC5cbiAqXG4gKiBBICdyZW1vdmUnIGV2ZW50IGlzIGVtaXR0ZWQgd2l0aCB0aGUgZG9jdW1lbnQgdGhhdCBoYXMgYmVlbiByZW1vdmVkIGFuZCB0aGUgaW5kZXhcbiAqIHRoZSBkb2N1bWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20uIFRoaXMgZXZlbnQgY2FuIGJlIHNpbGVuY2VkIGJ5IHBhc3NpbmcgZmFsc2VcbiAqIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gcmVtb3ZlLlxuICpcbiAqIElmIHVzZXIgc2V0dGluZyBEb2N1bWVudFN0b3JlIG5vdCBzdG9yaW5nIHRoZSBkb2N1bWVudHMsIHRoZW4gcmVtb3ZlIGRvYyBieSBkb2NSZWYgaXMgbm90IGFsbG93ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8SW50ZWdlcn0gZG9jUmVmIFRoZSBkb2N1bWVudCByZWYgdG8gcmVtb3ZlIGZyb20gdGhlIGluZGV4LlxuICogQHBhcmFtIHtCb29sZWFufSBlbWl0RXZlbnQgV2hldGhlciB0byBlbWl0IHJlbW92ZSBldmVudHMsIGRlZmF1bHRzIHRvIHRydWVcbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5wcm90b3R5cGUucmVtb3ZlRG9jQnlSZWYgPSBmdW5jdGlvbiAoZG9jUmVmLCBlbWl0RXZlbnQpIHtcbiAgaWYgKCFkb2NSZWYpIHJldHVybjtcbiAgaWYgKHRoaXMuZG9jdW1lbnRTdG9yZS5pc0RvY1N0b3JlZCgpID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdGhpcy5kb2N1bWVudFN0b3JlLmhhc0RvYyhkb2NSZWYpKSByZXR1cm47XG4gIHZhciBkb2MgPSB0aGlzLmRvY3VtZW50U3RvcmUuZ2V0RG9jKGRvY1JlZik7XG4gIHRoaXMucmVtb3ZlRG9jKGRvYywgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgZG9jdW1lbnQgZnJvbSB0aGUgaW5kZXguXG4gKiBUaGlzIHJlbW92ZSBvcGVyYXRpb24gY291bGQgd29yayBldmVuIHRoZSBvcmlnaW5hbCBkb2MgaXMgbm90IHN0b3JlIGluIHRoZSBEb2N1bWVudFN0b3JlLlxuICpcbiAqIFRvIG1ha2Ugc3VyZSBkb2N1bWVudHMgbm8gbG9uZ2VyIHNob3cgdXAgaW4gc2VhcmNoIHJlc3VsdHMgdGhleSBjYW4gYmVcbiAqIHJlbW92ZWQgZnJvbSB0aGUgaW5kZXggdXNpbmcgdGhpcyBtZXRob2QuXG4gKlxuICogQSAncmVtb3ZlJyBldmVudCBpcyBlbWl0dGVkIHdpdGggdGhlIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gcmVtb3ZlZCBhbmQgdGhlIGluZGV4XG4gKiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tLiBUaGlzIGV2ZW50IGNhbiBiZSBzaWxlbmNlZCBieSBwYXNzaW5nIGZhbHNlXG4gKiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHJlbW92ZS5cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgcmVmIHRvIHJlbW92ZSBmcm9tIHRoZSBpbmRleC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1pdEV2ZW50IFdoZXRoZXIgdG8gZW1pdCByZW1vdmUgZXZlbnRzLCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAbWVtYmVyT2YgSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLnJlbW92ZURvYyA9IGZ1bmN0aW9uIChkb2MsIGVtaXRFdmVudCkge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuXG4gIHZhciBlbWl0RXZlbnQgPSBlbWl0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBlbWl0RXZlbnQ7XG5cbiAgdmFyIGRvY1JlZiA9IGRvY1t0aGlzLl9yZWZdO1xuICBpZiAoIXRoaXMuZG9jdW1lbnRTdG9yZS5oYXNEb2MoZG9jUmVmKSkgcmV0dXJuO1xuXG4gIHRoaXMuZG9jdW1lbnRTdG9yZS5yZW1vdmVEb2MoZG9jUmVmKTtcblxuICB0aGlzLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICB2YXIgZmllbGRUb2tlbnMgPSB0aGlzLnBpcGVsaW5lLnJ1bihlbGFzdGljbHVuci50b2tlbml6ZXIoZG9jW2ZpZWxkXSkpO1xuICAgIGZpZWxkVG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICB0aGlzLmluZGV4W2ZpZWxkXS5yZW1vdmVUb2tlbih0b2tlbiwgZG9jUmVmKTtcbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKGVtaXRFdmVudCkgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgncmVtb3ZlJywgZG9jLCB0aGlzKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhIGRvY3VtZW50IGluIHRoZSBpbmRleC5cbiAqXG4gKiBXaGVuIGEgZG9jdW1lbnQgY29udGFpbmVkIHdpdGhpbiB0aGUgaW5kZXggZ2V0cyB1cGRhdGVkLCBmaWVsZHMgY2hhbmdlZCxcbiAqIGFkZGVkIG9yIHJlbW92ZWQsIHRvIG1ha2Ugc3VyZSBpdCBjb3JyZWN0bHkgbWF0Y2hlZCBhZ2FpbnN0IHNlYXJjaCBxdWVyaWVzLFxuICogaXQgc2hvdWxkIGJlIHVwZGF0ZWQgaW4gdGhlIGluZGV4LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGp1c3QgYSB3cmFwcGVyIGFyb3VuZCBgcmVtb3ZlYCBhbmQgYGFkZGBcbiAqXG4gKiBBbiAndXBkYXRlJyBldmVudCBpcyBlbWl0dGVkIHdpdGggdGhlIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gdXBkYXRlZCBhbmQgdGhlIGluZGV4LlxuICogVGhpcyBldmVudCBjYW4gYmUgc2lsZW5jZWQgYnkgcGFzc2luZyBmYWxzZSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHVwZGF0ZS4gT25seVxuICogYW4gdXBkYXRlIGV2ZW50IHdpbGwgYmUgZmlyZWQsIHRoZSAnYWRkJyBhbmQgJ3JlbW92ZScgZXZlbnRzIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxzXG4gKiBhcmUgc2lsZW5jZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgdG8gdXBkYXRlIGluIHRoZSBpbmRleC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1pdEV2ZW50IFdoZXRoZXIgdG8gZW1pdCB1cGRhdGUgZXZlbnRzLCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAc2VlIEluZGV4LnByb3RvdHlwZS5yZW1vdmVcbiAqIEBzZWUgSW5kZXgucHJvdG90eXBlLmFkZFxuICogQG1lbWJlck9mIEluZGV4XG4gKi9cbmVsYXN0aWNsdW5yLkluZGV4LnByb3RvdHlwZS51cGRhdGVEb2MgPSBmdW5jdGlvbiAoZG9jLCBlbWl0RXZlbnQpIHtcbiAgdmFyIGVtaXRFdmVudCA9IGVtaXRFdmVudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGVtaXRFdmVudDtcblxuICB0aGlzLnJlbW92ZURvY0J5UmVmKGRvY1t0aGlzLl9yZWZdLCBmYWxzZSk7XG4gIHRoaXMuYWRkRG9jKGRvYywgZmFsc2UpO1xuXG4gIGlmIChlbWl0RXZlbnQpIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZScsIGRvYywgdGhpcyk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2UgZG9jdW1lbnQgZnJlcXVlbmN5IGZvciBhIHRva2VuIHdpdGhpbiB0aGUgaW5kZXggb2YgYSBmaWVsZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIGNhbGN1bGF0ZSB0aGUgaWRmIG9mLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0byBjb21wdXRlIGlkZi5cbiAqIEBzZWUgSW5kZXgucHJvdG90eXBlLmlkZlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5wcm90b3R5cGUuaWRmID0gZnVuY3Rpb24gKHRlcm0sIGZpZWxkKSB7XG4gIHZhciBjYWNoZUtleSA9IFwiQFwiICsgZmllbGQgKyAnLycgKyB0ZXJtO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2lkZkNhY2hlLCBjYWNoZUtleSkpIHJldHVybiB0aGlzLl9pZGZDYWNoZVtjYWNoZUtleV07XG5cbiAgdmFyIGRmID0gdGhpcy5pbmRleFtmaWVsZF0uZ2V0RG9jRnJlcSh0ZXJtKTtcbiAgdmFyIGlkZiA9IDEgKyBNYXRoLmxvZyh0aGlzLmRvY3VtZW50U3RvcmUubGVuZ3RoIC8gKGRmICsgMSkpO1xuICB0aGlzLl9pZGZDYWNoZVtjYWNoZUtleV0gPSBpZGY7XG5cbiAgcmV0dXJuIGlkZjtcbn07XG5cbi8qKlxuICogZ2V0IGZpZWxkcyBvZiBjdXJyZW50IGluZGV4IGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmVsYXN0aWNsdW5yLkluZGV4LnByb3RvdHlwZS5nZXRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9maWVsZHMuc2xpY2UoKTtcbn07XG5cbi8qKlxuICogU2VhcmNoZXMgdGhlIGluZGV4IHVzaW5nIHRoZSBwYXNzZWQgcXVlcnkuXG4gKiBRdWVyaWVzIHNob3VsZCBiZSBhIHN0cmluZywgbXVsdGlwbGUgd29yZHMgYXJlIGFsbG93ZWQuXG4gKlxuICogSWYgY29uZmlnIGlzIG51bGwsIHdpbGwgc2VhcmNoIGFsbCBmaWVsZHMgZGVmYXVsdGx5LCBhbmQgbGVhZCB0byBPUiBiYXNlZCBxdWVyeS5cbiAqIElmIGNvbmZpZyBpcyBzcGVjaWZpZWQsIHdpbGwgc2VhcmNoIHNwZWNpZmllZCB3aXRoIHF1ZXJ5IHRpbWUgYm9vc3RpbmcuXG4gKlxuICogQWxsIHF1ZXJ5IHRva2VucyBhcmUgcGFzc2VkIHRocm91Z2ggdGhlIHNhbWUgcGlwZWxpbmUgdGhhdCBkb2N1bWVudCB0b2tlbnNcbiAqIGFyZSBwYXNzZWQgdGhyb3VnaCwgc28gYW55IGxhbmd1YWdlIHByb2Nlc3NpbmcgaW52b2x2ZWQgd2lsbCBiZSBydW4gb24gZXZlcnlcbiAqIHF1ZXJ5IHRlcm0uXG4gKlxuICogRWFjaCBxdWVyeSB0ZXJtIGlzIGV4cGFuZGVkLCBzbyB0aGF0IHRoZSB0ZXJtICdoZScgbWlnaHQgYmUgZXhwYW5kZWQgdG9cbiAqICdoZWxsbycgYW5kICdoZWxwJyBpZiB0aG9zZSB0ZXJtcyB3ZXJlIGFscmVhZHkgaW5jbHVkZWQgaW4gdGhlIGluZGV4LlxuICpcbiAqIE1hdGNoaW5nIGRvY3VtZW50cyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgY29udGFpbnNcbiAqIHRoZSBtYXRjaGluZyBkb2N1bWVudCByZWYsIGFzIHNldCBmb3IgdGhpcyBpbmRleCwgYW5kIHRoZSBzaW1pbGFyaXR5IHNjb3JlXG4gKiBmb3IgdGhpcyBkb2N1bWVudCBhZ2FpbnN0IHRoZSBxdWVyeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHRvIHNlYXJjaCB0aGUgaW5kZXggd2l0aC5cbiAqIEBwYXJhbSB7SlNPTn0gdXNlckNvbmZpZyBUaGUgdXNlciBxdWVyeSBjb25maWcsIEpTT04gZm9ybWF0LlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBJbmRleC5wcm90b3R5cGUuaWRmXG4gKiBAc2VlIEluZGV4LnByb3RvdHlwZS5kb2N1bWVudFZlY3RvclxuICogQG1lbWJlck9mIEluZGV4XG4gKi9cbmVsYXN0aWNsdW5yLkluZGV4LnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAocXVlcnksIHVzZXJDb25maWcpIHtcbiAgaWYgKCFxdWVyeSkgcmV0dXJuIFtdO1xuXG4gIHZhciBjb25maWdTdHIgPSBudWxsO1xuICBpZiAodXNlckNvbmZpZyAhPSBudWxsKSB7XG4gICAgY29uZmlnU3RyID0gSlNPTi5zdHJpbmdpZnkodXNlckNvbmZpZyk7XG4gIH1cblxuICB2YXIgY29uZmlnID0gbmV3IGVsYXN0aWNsdW5yLkNvbmZpZ3VyYXRpb24oY29uZmlnU3RyLCB0aGlzLmdldEZpZWxkcygpKS5nZXQoKTtcblxuICB2YXIgcXVlcnlUb2tlbnMgPSB0aGlzLnBpcGVsaW5lLnJ1bihlbGFzdGljbHVuci50b2tlbml6ZXIocXVlcnkpKTtcblxuICB2YXIgcXVlcnlSZXN1bHRzID0ge307XG5cbiAgZm9yICh2YXIgZmllbGQgaW4gY29uZmlnKSB7XG4gICAgdmFyIGZpZWxkU2VhcmNoUmVzdWx0cyA9IHRoaXMuZmllbGRTZWFyY2gocXVlcnlUb2tlbnMsIGZpZWxkLCBjb25maWcpO1xuICAgIHZhciBmaWVsZEJvb3N0ID0gY29uZmlnW2ZpZWxkXS5ib29zdDtcblxuICAgIGZvciAodmFyIGRvY1JlZiBpbiBmaWVsZFNlYXJjaFJlc3VsdHMpIHtcbiAgICAgIGZpZWxkU2VhcmNoUmVzdWx0c1tkb2NSZWZdID0gZmllbGRTZWFyY2hSZXN1bHRzW2RvY1JlZl0gKiBmaWVsZEJvb3N0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGRvY1JlZiBpbiBmaWVsZFNlYXJjaFJlc3VsdHMpIHtcbiAgICAgIGlmIChkb2NSZWYgaW4gcXVlcnlSZXN1bHRzKSB7XG4gICAgICAgIHF1ZXJ5UmVzdWx0c1tkb2NSZWZdICs9IGZpZWxkU2VhcmNoUmVzdWx0c1tkb2NSZWZdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlSZXN1bHRzW2RvY1JlZl0gPSBmaWVsZFNlYXJjaFJlc3VsdHNbZG9jUmVmXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBmb3IgKHZhciBkb2NSZWYgaW4gcXVlcnlSZXN1bHRzKSB7XG4gICAgcmVzdWx0cy5wdXNoKHtyZWY6IGRvY1JlZiwgc2NvcmU6IHF1ZXJ5UmVzdWx0c1tkb2NSZWZdfSk7XG4gIH1cblxuICByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuc2NvcmUgLSBhLnNjb3JlOyB9KTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIHNlYXJjaCBxdWVyeVRva2VucyBpbiBzcGVjaWZpZWQgZmllbGQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcXVlcnlUb2tlbnMgVGhlIHF1ZXJ5IHRva2VucyB0byBxdWVyeSBpbiB0aGlzIGZpZWxkLlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIEZpZWxkIHRvIHF1ZXJ5IGluLlxuICogQHBhcmFtIHtlbGFzdGljbHVuci5Db25maWd1cmF0aW9ufSBjb25maWcgVGhlIHVzZXIgcXVlcnkgY29uZmlnLCBKU09OIGZvcm1hdC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLmZpZWxkU2VhcmNoID0gZnVuY3Rpb24gKHF1ZXJ5VG9rZW5zLCBmaWVsZE5hbWUsIGNvbmZpZykge1xuICB2YXIgYm9vbGVhblR5cGUgPSBjb25maWdbZmllbGROYW1lXS5ib29sO1xuICB2YXIgZXhwYW5kID0gY29uZmlnW2ZpZWxkTmFtZV0uZXhwYW5kO1xuICB2YXIgYm9vc3QgPSBjb25maWdbZmllbGROYW1lXS5ib29zdDtcbiAgdmFyIHNjb3JlcyA9IG51bGw7XG4gIHZhciBkb2NUb2tlbnMgPSB7fTtcblxuICAvLyBEbyBub3RoaW5nIGlmIHRoZSBib29zdCBpcyAwXG4gIGlmIChib29zdCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHF1ZXJ5VG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIHRva2VucyA9IFt0b2tlbl07XG4gICAgaWYgKGV4cGFuZCA9PSB0cnVlKSB7XG4gICAgICB0b2tlbnMgPSB0aGlzLmluZGV4W2ZpZWxkTmFtZV0uZXhwYW5kVG9rZW4odG9rZW4pO1xuICAgIH1cbiAgICAvLyBDb25zaWRlciBldmVyeSBxdWVyeSB0b2tlbiBpbiB0dXJuLiBJZiBleHBhbmRlZCwgZWFjaCBxdWVyeSB0b2tlblxuICAgIC8vIGNvcnJlc3BvbmRzIHRvIGEgc2V0IG9mIHRva2Vucywgd2hpY2ggaXMgYWxsIHRva2VucyBpbiB0aGUgXG4gICAgLy8gaW5kZXggbWF0Y2hpbmcgdGhlIHBhdHRlcm4gcXVlcnlUb2tlbiogLlxuICAgIC8vIEZvciB0aGUgc2V0IG9mIHRva2VucyBjb3JyZXNwb25kaW5nIHRvIGEgcXVlcnkgdG9rZW4sIGZpbmQgYW5kIHNjb3JlXG4gICAgLy8gYWxsIG1hdGNoaW5nIGRvY3VtZW50cy4gU3RvcmUgdGhvc2Ugc2NvcmVzIGluIHF1ZXJ5VG9rZW5TY29yZXMsIFxuICAgIC8vIGtleWVkIGJ5IGRvY1JlZi5cbiAgICAvLyBUaGVuLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGJvb2xlYW5UeXBlLCBjb21iaW5lIHRoZSBzY29yZXNcbiAgICAvLyBmb3IgdGhpcyBxdWVyeSB0b2tlbiB3aXRoIHByZXZpb3VzIHNjb3Jlcy4gIElmIGJvb2xlYW5UeXBlIGlzIE9SLFxuICAgIC8vIHRoZW4gbWVyZ2UgdGhlIHNjb3JlcyBieSBzdW1taW5nIGludG8gdGhlIGFjY3VtdWxhdGVkIHRvdGFsLCBhZGRpbmdcbiAgICAvLyBuZXcgZG9jdW1lbnQgc2NvcmVzIGFyZSByZXF1aXJlZCAoZWZmZWN0aXZlbHkgYSB1bmlvbiBvcGVyYXRvcikuIFxuICAgIC8vIElmIGJvb2xlYW5UeXBlIGlzIEFORCwgYWNjdW11bGF0ZSBzY29yZXMgb25seSBpZiB0aGUgZG9jdW1lbnQgXG4gICAgLy8gaGFzIHByZXZpb3VzbHkgYmVlbiBzY29yZWQgYnkgYW5vdGhlciBxdWVyeSB0b2tlbiAoYW4gaW50ZXJzZWN0aW9uXG4gICAgLy8gb3BlcmF0aW9uMC4gXG4gICAgLy8gRnVydGhlcm1vcmUsIHNpbmNlIHdoZW4gYm9vbGVhblR5cGUgaXMgQU5ELCBhZGRpdGlvbmFsIFxuICAgIC8vIHF1ZXJ5IHRva2VucyBjYW4ndCBhZGQgbmV3IGRvY3VtZW50cyB0byB0aGUgcmVzdWx0IHNldCwgdXNlIHRoZVxuICAgIC8vIGN1cnJlbnQgZG9jdW1lbnQgc2V0IHRvIGxpbWl0IHRoZSBwcm9jZXNzaW5nIG9mIGVhY2ggbmV3IHF1ZXJ5IFxuICAgIC8vIHRva2VuIGZvciBlZmZpY2llbmN5IChpLmUuLCBpbmNyZW1lbnRhbCBpbnRlcnNlY3Rpb24pLlxuICAgIFxuICAgIHZhciBxdWVyeVRva2VuU2NvcmVzID0ge307XG4gICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGRvY3MgPSB0aGlzLmluZGV4W2ZpZWxkTmFtZV0uZ2V0RG9jcyhrZXkpO1xuICAgICAgdmFyIGlkZiA9IHRoaXMuaWRmKGtleSwgZmllbGROYW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHNjb3JlcyAmJiBib29sZWFuVHlwZSA9PSAnQU5EJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSwgd2UgY2FuIHJ1bGUgb3V0IGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlblxuICAgICAgICAgIC8vIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCBvdXQgYmVjYXVzZSB0aGV5IHdlcmVuJ3Qgc2NvcmVkXG4gICAgICAgICAgLy8gYnkgcHJldmlvdXMgcXVlcnkgdG9rZW4gcGFzc2VzLlxuICAgICAgICAgIHZhciBmaWx0ZXJlZERvY3MgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBkb2NSZWYgaW4gc2NvcmVzKSB7XG4gICAgICAgICAgICAgIGlmIChkb2NSZWYgaW4gZG9jcykge1xuICAgICAgICAgICAgICAgICAgZmlsdGVyZWREb2NzW2RvY1JlZl0gPSBkb2NzW2RvY1JlZl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jcyA9IGZpbHRlcmVkRG9jcztcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgcmVjb3JkIGFwcGVhcmVkIHRva2VuIGZvciByZXRyaWV2ZWQgZG9jdW1lbnRzIGZvciB0aGVcbiAgICAgIC8vIG9yaWdpbmFsIHRva2VuLCBub3QgZm9yIGV4cGFuZWQgdG9rZW4uXG4gICAgICAvLyBiZWF1c2UgZm9yIGRvaW5nIGNvb3JkTm9ybSBmb3IgYSByZXRyaWV2ZWQgZG9jdW1lbnQsIGNvb3JkTm9ybSBvbmx5IGNhcmUgaG93IG1hbnlcbiAgICAgIC8vIHF1ZXJ5IHRva2VuIGFwcGVhciBpbiB0aGF0IGRvY3VtZW50LlxuICAgICAgLy8gc28gZXhwYW5kZWQgdG9rZW4gc2hvdWxkIG5vdCBiZSBhZGRlZCBpbnRvIGRvY1Rva2VucywgaWYgYWRkZWQsIHRoaXMgd2lsbCBwb2xsdXRlIHRoZVxuICAgICAgLy8gY29vcmROb3JtXG4gICAgICBpZiAoa2V5ID09IHRva2VuKSB7XG4gICAgICAgIHRoaXMuZmllbGRTZWFyY2hTdGF0cyhkb2NUb2tlbnMsIGtleSwgZG9jcyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGRvY1JlZiBpbiBkb2NzKSB7XG4gICAgICAgIHZhciB0ZiA9IHRoaXMuaW5kZXhbZmllbGROYW1lXS5nZXRUZXJtRnJlcXVlbmN5KGtleSwgZG9jUmVmKTtcbiAgICAgICAgdmFyIGZpZWxkTGVuZ3RoID0gdGhpcy5kb2N1bWVudFN0b3JlLmdldEZpZWxkTGVuZ3RoKGRvY1JlZiwgZmllbGROYW1lKTtcbiAgICAgICAgdmFyIGZpZWxkTGVuZ3RoTm9ybSA9IDE7XG4gICAgICAgIGlmIChmaWVsZExlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgZmllbGRMZW5ndGhOb3JtID0gMSAvIE1hdGguc3FydChmaWVsZExlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVuYWxpdHkgPSAxO1xuICAgICAgICBpZiAoa2V5ICE9IHRva2VuKSB7XG4gICAgICAgICAgLy8gY3VycmVudGx5IEknbSBub3Qgc3VyZSBpZiB0aGlzIHBlbmFsaXR5IGlzIGVub3VnaCxcbiAgICAgICAgICAvLyBuZWVkIHRvIGRvIHZlcmlmaWNhdGlvblxuICAgICAgICAgIHBlbmFsaXR5ID0gKDEgLSAoa2V5Lmxlbmd0aCAtIHRva2VuLmxlbmd0aCkgLyBrZXkubGVuZ3RoKSAqIDAuMTU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NvcmUgPSB0ZiAqIGlkZiAqIGZpZWxkTGVuZ3RoTm9ybSAqIHBlbmFsaXR5O1xuXG4gICAgICAgIGlmIChkb2NSZWYgaW4gcXVlcnlUb2tlblNjb3Jlcykge1xuICAgICAgICAgIHF1ZXJ5VG9rZW5TY29yZXNbZG9jUmVmXSArPSBzY29yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWVyeVRva2VuU2NvcmVzW2RvY1JlZl0gPSBzY29yZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIFxuICAgIHNjb3JlcyA9IHRoaXMubWVyZ2VTY29yZXMoc2NvcmVzLCBxdWVyeVRva2VuU2NvcmVzLCBib29sZWFuVHlwZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHNjb3JlcyA9IHRoaXMuY29vcmROb3JtKHNjb3JlcywgZG9jVG9rZW5zLCBxdWVyeVRva2Vucy5sZW5ndGgpO1xuICByZXR1cm4gc2NvcmVzO1xufTtcblxuLyoqXG4gKiBNZXJnZSB0aGUgc2NvcmVzIGZyb20gb25lIHNldCBvZiB0b2tlbnMgaW50byBhbiBhY2N1bXVsYXRlZCBzY29yZSB0YWJsZS5cbiAqIEV4YWN0IG9wZXJhdGlvbiBkZXBlbmRzIG9uIHRoZSBvcCBwYXJhbWV0ZXIuIElmIG9wIGlzICdBTkQnLCB0aGVuIG9ubHkgdGhlXG4gKiBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBzY29yZSBsaXN0cyBpcyByZXRhaW5lZC4gT3RoZXJ3aXNlLCB0aGUgdW5pb24gb2ZcbiAqIHRoZSB0d28gc2NvcmUgbGlzdHMgaXMgcmV0dXJuZWQuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYm9vbCBhY2N1bXVsYXRlZCBzY29yZXMuIFNob3VsZCBiZSBudWxsIG9uIGZpcnN0IGNhbGwuXG4gKiBAcGFyYW0ge1N0cmluZ30gc2NvcmVzIG5ldyBzY29yZXMgdG8gbWVyZ2UgaW50byBhY2N1bVNjb3Jlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcCBtZXJnZSBvcGVyYXRpb24gKHNob3VsZCBiZSAnQU5EJyBvciAnT1InKS5cbiAqXG4gKi9cblxuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLm1lcmdlU2NvcmVzID0gZnVuY3Rpb24gKGFjY3VtU2NvcmVzLCBzY29yZXMsIG9wKSB7XG4gICAgaWYgKCFhY2N1bVNjb3Jlcykge1xuICAgICAgICByZXR1cm4gc2NvcmVzOyBcbiAgICB9XG4gICAgaWYgKG9wID09ICdBTkQnKSB7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZG9jUmVmIGluIHNjb3Jlcykge1xuICAgICAgICAgICAgaWYgKGRvY1JlZiBpbiBhY2N1bVNjb3Jlcykge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbltkb2NSZWZdID0gYWNjdW1TY29yZXNbZG9jUmVmXSArIHNjb3Jlc1tkb2NSZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgZG9jUmVmIGluIHNjb3Jlcykge1xuICAgICAgICAgICAgaWYgKGRvY1JlZiBpbiBhY2N1bVNjb3Jlcykge1xuICAgICAgICAgICAgICAgIGFjY3VtU2NvcmVzW2RvY1JlZl0gKz0gc2NvcmVzW2RvY1JlZl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY3VtU2NvcmVzW2RvY1JlZl0gPSBzY29yZXNbZG9jUmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW1TY29yZXM7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJlY29yZCB0aGUgb2NjdXJpbmcgcXVlcnkgdG9rZW4gb2YgcmV0cmlldmVkIGRvYyBzcGVjaWZpZWQgYnkgZG9jIGZpZWxkLlxuICogT25seSBmb3IgaW5uZXIgdXNlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jVG9rZW5zIGEgZGF0YSBzdHJ1Y3R1cmUgc3RvcmVzIHdoaWNoIHRva2VuIGFwcGVhcnMgaW4gdGhlIHJldHJpZXZlZCBkb2MuXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gcXVlcnkgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NzIHRoZSByZXRyaWV2ZWQgZG9jdW1lbnRzIG9mIHRoZSBxdWVyeSB0b2tlblxuICpcbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLmZpZWxkU2VhcmNoU3RhdHMgPSBmdW5jdGlvbiAoZG9jVG9rZW5zLCB0b2tlbiwgZG9jcykge1xuICBmb3IgKHZhciBkb2MgaW4gZG9jcykge1xuICAgIGlmIChkb2MgaW4gZG9jVG9rZW5zKSB7XG4gICAgICBkb2NUb2tlbnNbZG9jXS5wdXNoKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jVG9rZW5zW2RvY10gPSBbdG9rZW5dO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBjb29yZCBub3JtIHRoZSBzY29yZSBvZiBhIGRvYy5cbiAqIGlmIGEgZG9jIGNvbnRhaW4gbW9yZSBxdWVyeSB0b2tlbnMsIHRoZW4gdGhlIHNjb3JlIHdpbGwgbGFyZ2VyIHRoYW4gdGhlIGRvY1xuICogY29udGFpbnMgbGVzcyBxdWVyeSB0b2tlbnMuXG4gKlxuICogb25seSBmb3IgaW5uZXIgdXNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRzIGZpcnN0IHJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NzIGZpZWxkIHNlYXJjaCByZXN1bHRzIG9mIGEgdG9rZW5cbiAqIEBwYXJhbSB7SW50ZWdlcn0gbiBxdWVyeSB0b2tlbiBudW1iZXJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLmNvb3JkTm9ybSA9IGZ1bmN0aW9uIChzY29yZXMsIGRvY1Rva2Vucywgbikge1xuICBmb3IgKHZhciBkb2MgaW4gc2NvcmVzKSB7XG4gICAgaWYgKCEoZG9jIGluIGRvY1Rva2VucykpIGNvbnRpbnVlO1xuICAgIHZhciB0b2tlbnMgPSBkb2NUb2tlbnNbZG9jXS5sZW5ndGg7XG4gICAgc2NvcmVzW2RvY10gPSBzY29yZXNbZG9jXSAqIHRva2VucyAvIG47XG4gIH1cblxuICByZXR1cm4gc2NvcmVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluZGV4IHJlYWR5IGZvciBzZXJpYWxpc2F0aW9uLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBtZW1iZXJPZiBJbmRleFxuICovXG5lbGFzdGljbHVuci5JbmRleC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW5kZXhKc29uID0ge307XG4gIHRoaXMuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGluZGV4SnNvbltmaWVsZF0gPSB0aGlzLmluZGV4W2ZpZWxkXS50b0pTT04oKTtcbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiBlbGFzdGljbHVuci52ZXJzaW9uLFxuICAgIGZpZWxkczogdGhpcy5fZmllbGRzLFxuICAgIHJlZjogdGhpcy5fcmVmLFxuICAgIGRvY3VtZW50U3RvcmU6IHRoaXMuZG9jdW1lbnRTdG9yZS50b0pTT04oKSxcbiAgICBpbmRleDogaW5kZXhKc29uLFxuICAgIHBpcGVsaW5lOiB0aGlzLnBpcGVsaW5lLnRvSlNPTigpXG4gIH07XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBwbHVnaW4gdG8gdGhlIGN1cnJlbnQgaW5kZXguXG4gKlxuICogQSBwbHVnaW4gaXMgYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIHRoZSBpbmRleCBhcyBpdHMgY29udGV4dC5cbiAqIFBsdWdpbnMgY2FuIGJlIHVzZWQgdG8gY3VzdG9taXNlIG9yIGV4dGVuZCB0aGUgYmVoYXZpb3VyIHRoZSBpbmRleFxuICogaW4gc29tZSB3YXkuIEEgcGx1Z2luIGlzIGp1c3QgYSBmdW5jdGlvbiwgdGhhdCBlbmNhcHN1bGF0ZWQgdGhlIGN1c3RvbVxuICogYmVoYXZpb3VyIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGluZGV4LlxuICpcbiAqIFRoZSBwbHVnaW4gZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgaW5kZXggYXMgaXRzIGFyZ3VtZW50LCBhZGRpdGlvbmFsXG4gKiBhcmd1bWVudHMgY2FuIGFsc28gYmUgcGFzc2VkIHdoZW4gY2FsbGluZyB1c2UuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZFxuICogd2l0aCB0aGUgaW5kZXggYXMgaXRzIGNvbnRleHQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIG15UGx1Z2luID0gZnVuY3Rpb24gKGlkeCwgYXJnMSwgYXJnMikge1xuICogICAgICAgLy8gYHRoaXNgIGlzIHRoZSBpbmRleCB0byBiZSBleHRlbmRlZFxuICogICAgICAgLy8gYXBwbHkgYW55IGV4dGVuc2lvbnMgZXRjIGhlcmUuXG4gKiAgICAgfVxuICpcbiAqICAgICB2YXIgaWR4ID0gZWxhc3RpY2x1bnIoZnVuY3Rpb24gKCkge1xuICogICAgICAgdGhpcy51c2UobXlQbHVnaW4sICdhcmcxJywgJ2FyZzInKVxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIFRoZSBwbHVnaW4gdG8gYXBwbHkuXG4gKiBAbWVtYmVyT2YgSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW5kZXgucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gIHBsdWdpbi5hcHBseSh0aGlzLCBhcmdzKTtcbn07XG4vKiFcbiAqIGVsYXN0aWNsdW5yLkRvY3VtZW50U3RvcmVcbiAqIENvcHlyaWdodCAoQykgMjAxNiBXZWkgU29uZ1xuICovXG5cbi8qKlxuICogZWxhc3RpY2x1bnIuRG9jdW1lbnRTdG9yZSBpcyBhIHNpbXBsZSBrZXktdmFsdWUgZG9jdW1lbnQgc3RvcmUgdXNlZCBmb3Igc3RvcmluZyBzZXRzIG9mIHRva2VucyBmb3JcbiAqIGRvY3VtZW50cyBzdG9yZWQgaW4gaW5kZXguXG4gKlxuICogZWxhc3RpY2x1bnIuRG9jdW1lbnRTdG9yZSBzdG9yZSBvcmlnaW5hbCBKU09OIGZvcm1hdCBkb2N1bWVudHMgdGhhdCB5b3UgY291bGQgYnVpbGQgc2VhcmNoIHNuaXBwZXQgYnkgdGhpcyBvcmlnaW5hbCBKU09OIGRvY3VtZW50LlxuICpcbiAqIHVzZXIgY291bGQgY2hvb3NlIHdoZXRoZXIgb3JpZ2luYWwgSlNPTiBmb3JtYXQgZG9jdW1lbnQgc2hvdWxkIGJlIHN0b3JlLCBpZiBubyBjb25maWd1cmF0aW9uIHRoZW4gZG9jdW1lbnQgd2lsbCBiZSBzdG9yZWQgZGVmYXVsdGx5LlxuICogSWYgdXNlciBjYXJlIG1vcmUgYWJvdXQgdGhlIGluZGV4IHNpemUsIHVzZXIgY291bGQgc2VsZWN0IG5vdCBzdG9yZSBKU09OIGRvY3VtZW50cywgdGhlbiB0aGlzIHdpbGwgaGFzIHNvbWUgZGVmZWN0cywgc3VjaCBhcyB1c2VyXG4gKiBjb3VsZCBub3QgdXNlIEpTT04gZG9jdW1lbnQgdG8gZ2VuZXJhdGUgc25pcHBldHMgb2Ygc2VhcmNoIHJlc3VsdHMuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzYXZlIElmIHRoZSBvcmlnaW5hbCBKU09OIGRvY3VtZW50IHNob3VsZCBiZSBzdG9yZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtb2R1bGVcbiAqL1xuZWxhc3RpY2x1bnIuRG9jdW1lbnRTdG9yZSA9IGZ1bmN0aW9uIChzYXZlKSB7XG4gIGlmIChzYXZlID09PSBudWxsIHx8IHNhdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX3NhdmUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NhdmUgPSBzYXZlO1xuICB9XG5cbiAgdGhpcy5kb2NzID0ge307XG4gIHRoaXMuZG9jSW5mbyA9IHt9O1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIExvYWRzIGEgcHJldmlvdXNseSBzZXJpYWxpc2VkIGRvY3VtZW50IHN0b3JlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGlzZWREYXRhIFRoZSBzZXJpYWxpc2VkIGRvY3VtZW50IHN0b3JlIHRvIGxvYWQuXG4gKiBAcmV0dXJuIHtlbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlfVxuICovXG5lbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlLmxvYWQgPSBmdW5jdGlvbiAoc2VyaWFsaXNlZERhdGEpIHtcbiAgdmFyIHN0b3JlID0gbmV3IHRoaXM7XG5cbiAgc3RvcmUubGVuZ3RoID0gc2VyaWFsaXNlZERhdGEubGVuZ3RoO1xuICBzdG9yZS5kb2NzID0gc2VyaWFsaXNlZERhdGEuZG9jcztcbiAgc3RvcmUuZG9jSW5mbyA9IHNlcmlhbGlzZWREYXRhLmRvY0luZm87XG4gIHN0b3JlLl9zYXZlID0gc2VyaWFsaXNlZERhdGEuc2F2ZTtcblxuICByZXR1cm4gc3RvcmU7XG59O1xuXG4vKipcbiAqIGNoZWNrIGlmIGN1cnJlbnQgaW5zdGFuY2Ugc3RvcmUgdGhlIG9yaWdpbmFsIGRvY1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmVsYXN0aWNsdW5yLkRvY3VtZW50U3RvcmUucHJvdG90eXBlLmlzRG9jU3RvcmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc2F2ZTtcbn07XG5cbi8qKlxuICogU3RvcmVzIHRoZSBnaXZlbiBkb2MgaW4gdGhlIGRvY3VtZW50IHN0b3JlIGFnYWluc3QgdGhlIGdpdmVuIGlkLlxuICogSWYgZG9jUmVmIGFscmVhZHkgZXhpc3QsIHRoZW4gdXBkYXRlIGRvYy5cbiAqXG4gKiBEb2N1bWVudCBpcyBzdG9yZSBieSBvcmlnaW5hbCBKU09OIGZvcm1hdCwgdGhlbiB5b3UgY291bGQgdXNlIG9yaWdpbmFsIGRvY3VtZW50IHRvIGdlbmVyYXRlIHNlYXJjaCBzbmlwcGV0cy5cbiAqXG4gKiBAcGFyYW0ge0ludGVnZXJ8U3RyaW5nfSBkb2NSZWYgVGhlIGtleSB1c2VkIHRvIHN0b3JlIHRoZSBKU09OIGZvcm1hdCBkb2MuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBKU09OIGZvcm1hdCBkb2MuXG4gKi9cbmVsYXN0aWNsdW5yLkRvY3VtZW50U3RvcmUucHJvdG90eXBlLmFkZERvYyA9IGZ1bmN0aW9uIChkb2NSZWYsIGRvYykge1xuICBpZiAoIXRoaXMuaGFzRG9jKGRvY1JlZikpIHRoaXMubGVuZ3RoKys7XG5cbiAgaWYgKHRoaXMuX3NhdmUgPT09IHRydWUpIHtcbiAgICB0aGlzLmRvY3NbZG9jUmVmXSA9IGNsb25lKGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kb2NzW2RvY1JlZl0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgSlNPTiBkb2MgZnJvbSB0aGUgZG9jdW1lbnQgc3RvcmUgZm9yIGEgZ2l2ZW4ga2V5LlxuICpcbiAqIElmIGRvY1JlZiBub3QgZm91bmQsIHJldHVybiBudWxsLlxuICogSWYgdXNlciBzZXQgbm90IHN0b3JpbmcgdGhlIGRvY3VtZW50cywgcmV0dXJuIG51bGwuXG4gKlxuICogQHBhcmFtIHtJbnRlZ2VyfFN0cmluZ30gZG9jUmVmIFRoZSBrZXkgdG8gbG9va3VwIGFuZCByZXRyaWV2ZSBmcm9tIHRoZSBkb2N1bWVudCBzdG9yZS5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBtZW1iZXJPZiBEb2N1bWVudFN0b3JlXG4gKi9cbmVsYXN0aWNsdW5yLkRvY3VtZW50U3RvcmUucHJvdG90eXBlLmdldERvYyA9IGZ1bmN0aW9uIChkb2NSZWYpIHtcbiAgaWYgKHRoaXMuaGFzRG9jKGRvY1JlZikgPT09IGZhbHNlKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHRoaXMuZG9jc1tkb2NSZWZdO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZG9jdW1lbnQgc3RvcmUgY29udGFpbnMgYSBrZXkgKGRvY1JlZikuXG4gKlxuICogQHBhcmFtIHtJbnRlZ2VyfFN0cmluZ30gZG9jUmVmIFRoZSBpZCB0byBsb29rIHVwIGluIHRoZSBkb2N1bWVudCBzdG9yZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRTdG9yZVxuICovXG5lbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlLnByb3RvdHlwZS5oYXNEb2MgPSBmdW5jdGlvbiAoZG9jUmVmKSB7XG4gIHJldHVybiBkb2NSZWYgaW4gdGhpcy5kb2NzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSB2YWx1ZSBmb3IgYSBrZXkgaW4gdGhlIGRvY3VtZW50IHN0b3JlLlxuICpcbiAqIEBwYXJhbSB7SW50ZWdlcnxTdHJpbmd9IGRvY1JlZiBUaGUgaWQgdG8gcmVtb3ZlIGZyb20gdGhlIGRvY3VtZW50IHN0b3JlLlxuICogQG1lbWJlck9mIERvY3VtZW50U3RvcmVcbiAqL1xuZWxhc3RpY2x1bnIuRG9jdW1lbnRTdG9yZS5wcm90b3R5cGUucmVtb3ZlRG9jID0gZnVuY3Rpb24gKGRvY1JlZikge1xuICBpZiAoIXRoaXMuaGFzRG9jKGRvY1JlZikpIHJldHVybjtcblxuICBkZWxldGUgdGhpcy5kb2NzW2RvY1JlZl07XG4gIGRlbGV0ZSB0aGlzLmRvY0luZm9bZG9jUmVmXTtcbiAgdGhpcy5sZW5ndGgtLTtcbn07XG5cbi8qKlxuICogQWRkIGZpZWxkIGxlbmd0aCBvZiBhIGRvY3VtZW50J3MgZmllbGQgdG9rZW5zIGZyb20gcGlwZWxpbmUgcmVzdWx0cy5cbiAqIFRoZSBmaWVsZCBsZW5ndGggb2YgYSBkb2N1bWVudCBpcyB1c2VkIHRvIGRvIGZpZWxkIGxlbmd0aCBub3JtYWxpemF0aW9uIGV2ZW4gd2l0aG91dCB0aGUgb3JpZ2luYWwgSlNPTiBkb2N1bWVudCBzdG9yZWQuXG4gKlxuICogQHBhcmFtIHtJbnRlZ2VyfFN0cmluZ30gZG9jUmVmIGRvY3VtZW50J3MgaWQgb3IgcmVmZXJlbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lIGZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gbGVuZ3RoIGZpZWxkIGxlbmd0aFxuICovXG5lbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlLnByb3RvdHlwZS5hZGRGaWVsZExlbmd0aCA9IGZ1bmN0aW9uIChkb2NSZWYsIGZpZWxkTmFtZSwgbGVuZ3RoKSB7XG4gIGlmIChkb2NSZWYgPT09IG51bGwgfHwgZG9jUmVmID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHRoaXMuaGFzRG9jKGRvY1JlZikgPT0gZmFsc2UpIHJldHVybjtcblxuICBpZiAoIXRoaXMuZG9jSW5mb1tkb2NSZWZdKSB0aGlzLmRvY0luZm9bZG9jUmVmXSA9IHt9O1xuICB0aGlzLmRvY0luZm9bZG9jUmVmXVtmaWVsZE5hbWVdID0gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZmllbGQgbGVuZ3RoIG9mIGEgZG9jdW1lbnQncyBmaWVsZCB0b2tlbnMgZnJvbSBwaXBlbGluZSByZXN1bHRzLlxuICogVGhlIGZpZWxkIGxlbmd0aCBvZiBhIGRvY3VtZW50IGlzIHVzZWQgdG8gZG8gZmllbGQgbGVuZ3RoIG5vcm1hbGl6YXRpb24gZXZlbiB3aXRob3V0IHRoZSBvcmlnaW5hbCBKU09OIGRvY3VtZW50IHN0b3JlZC5cbiAqXG4gKiBAcGFyYW0ge0ludGVnZXJ8U3RyaW5nfSBkb2NSZWYgZG9jdW1lbnQncyBpZCBvciByZWZlcmVuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWUgZmllbGQgbmFtZVxuICogQHBhcmFtIHtJbnRlZ2VyfSBsZW5ndGggZmllbGQgbGVuZ3RoXG4gKi9cbmVsYXN0aWNsdW5yLkRvY3VtZW50U3RvcmUucHJvdG90eXBlLnVwZGF0ZUZpZWxkTGVuZ3RoID0gZnVuY3Rpb24gKGRvY1JlZiwgZmllbGROYW1lLCBsZW5ndGgpIHtcbiAgaWYgKGRvY1JlZiA9PT0gbnVsbCB8fCBkb2NSZWYgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAodGhpcy5oYXNEb2MoZG9jUmVmKSA9PSBmYWxzZSkgcmV0dXJuO1xuXG4gIHRoaXMuYWRkRmllbGRMZW5ndGgoZG9jUmVmLCBmaWVsZE5hbWUsIGxlbmd0aCk7XG59O1xuXG4vKipcbiAqIGdldCBmaWVsZCBsZW5ndGggb2YgYSBkb2N1bWVudCBieSBkb2NSZWZcbiAqXG4gKiBAcGFyYW0ge0ludGVnZXJ8U3RyaW5nfSBkb2NSZWYgZG9jdW1lbnQgaWQgb3IgcmVmZXJlbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lIGZpZWxkIG5hbWVcbiAqIEByZXR1cm4ge0ludGVnZXJ9IGZpZWxkIGxlbmd0aFxuICovXG5lbGFzdGljbHVuci5Eb2N1bWVudFN0b3JlLnByb3RvdHlwZS5nZXRGaWVsZExlbmd0aCA9IGZ1bmN0aW9uIChkb2NSZWYsIGZpZWxkTmFtZSkge1xuICBpZiAoZG9jUmVmID09PSBudWxsIHx8IGRvY1JlZiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcblxuICBpZiAoIShkb2NSZWYgaW4gdGhpcy5kb2NzKSkgcmV0dXJuIDA7XG4gIGlmICghKGZpZWxkTmFtZSBpbiB0aGlzLmRvY0luZm9bZG9jUmVmXSkpIHJldHVybiAwO1xuICByZXR1cm4gdGhpcy5kb2NJbmZvW2RvY1JlZl1bZmllbGROYW1lXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IHN0b3JlIHVzZWQgZm9yIHNlcmlhbGlzYXRpb24uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBKU09OIGZvcm1hdFxuICogQG1lbWJlck9mIERvY3VtZW50U3RvcmVcbiAqL1xuZWxhc3RpY2x1bnIuRG9jdW1lbnRTdG9yZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGRvY3M6IHRoaXMuZG9jcyxcbiAgICBkb2NJbmZvOiB0aGlzLmRvY0luZm8sXG4gICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICBzYXZlOiB0aGlzLl9zYXZlXG4gIH07XG59O1xuXG4vKipcbiAqIENsb25pbmcgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBpbiBKU09OIGZvcm1hdFxuICogQHJldHVybiB7T2JqZWN0fSBjb3BpZWQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICBpZiAobnVsbCA9PT0gb2JqIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmopIHJldHVybiBvYmo7XG5cbiAgdmFyIGNvcHkgPSBvYmouY29uc3RydWN0b3IoKTtcblxuICBmb3IgKHZhciBhdHRyIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoYXR0cikpIGNvcHlbYXR0cl0gPSBvYmpbYXR0cl07XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cbi8qIVxuICogZWxhc3RpY2x1bnIuc3RlbW1lclxuICogQ29weXJpZ2h0IChDKSAyMDE2IE9saXZlciBOaWdodGluZ2FsZVxuICogQ29weXJpZ2h0IChDKSAyMDE2IFdlaSBTb25nXG4gKiBJbmNsdWRlcyBjb2RlIGZyb20gLSBodHRwOi8vdGFydGFydXMub3JnL35tYXJ0aW4vUG9ydGVyU3RlbW1lci9qcy50eHRcbiAqL1xuXG4vKipcbiAqIGVsYXN0aWNsdW5yLnN0ZW1tZXIgaXMgYW4gZW5nbGlzaCBsYW5ndWFnZSBzdGVtbWVyLCB0aGlzIGlzIGEgSmF2YVNjcmlwdFxuICogaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvcnRlclN0ZW1tZXIgdGFrZW4gZnJvbSBodHRwOi8vdGFydGFydXMub3JnL35tYXJ0aW5cbiAqXG4gKiBAbW9kdWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc3RlbVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQHNlZSBlbGFzdGljbHVuci5QaXBlbGluZVxuICovXG5lbGFzdGljbHVuci5zdGVtbWVyID0gKGZ1bmN0aW9uKCl7XG4gIHZhciBzdGVwMmxpc3QgPSB7XG4gICAgICBcImF0aW9uYWxcIiA6IFwiYXRlXCIsXG4gICAgICBcInRpb25hbFwiIDogXCJ0aW9uXCIsXG4gICAgICBcImVuY2lcIiA6IFwiZW5jZVwiLFxuICAgICAgXCJhbmNpXCIgOiBcImFuY2VcIixcbiAgICAgIFwiaXplclwiIDogXCJpemVcIixcbiAgICAgIFwiYmxpXCIgOiBcImJsZVwiLFxuICAgICAgXCJhbGxpXCIgOiBcImFsXCIsXG4gICAgICBcImVudGxpXCIgOiBcImVudFwiLFxuICAgICAgXCJlbGlcIiA6IFwiZVwiLFxuICAgICAgXCJvdXNsaVwiIDogXCJvdXNcIixcbiAgICAgIFwiaXphdGlvblwiIDogXCJpemVcIixcbiAgICAgIFwiYXRpb25cIiA6IFwiYXRlXCIsXG4gICAgICBcImF0b3JcIiA6IFwiYXRlXCIsXG4gICAgICBcImFsaXNtXCIgOiBcImFsXCIsXG4gICAgICBcIml2ZW5lc3NcIiA6IFwiaXZlXCIsXG4gICAgICBcImZ1bG5lc3NcIiA6IFwiZnVsXCIsXG4gICAgICBcIm91c25lc3NcIiA6IFwib3VzXCIsXG4gICAgICBcImFsaXRpXCIgOiBcImFsXCIsXG4gICAgICBcIml2aXRpXCIgOiBcIml2ZVwiLFxuICAgICAgXCJiaWxpdGlcIiA6IFwiYmxlXCIsXG4gICAgICBcImxvZ2lcIiA6IFwibG9nXCJcbiAgICB9LFxuXG4gICAgc3RlcDNsaXN0ID0ge1xuICAgICAgXCJpY2F0ZVwiIDogXCJpY1wiLFxuICAgICAgXCJhdGl2ZVwiIDogXCJcIixcbiAgICAgIFwiYWxpemVcIiA6IFwiYWxcIixcbiAgICAgIFwiaWNpdGlcIiA6IFwiaWNcIixcbiAgICAgIFwiaWNhbFwiIDogXCJpY1wiLFxuICAgICAgXCJmdWxcIiA6IFwiXCIsXG4gICAgICBcIm5lc3NcIiA6IFwiXCJcbiAgICB9LFxuXG4gICAgYyA9IFwiW15hZWlvdV1cIiwgICAgICAgICAgLy8gY29uc29uYW50XG4gICAgdiA9IFwiW2FlaW91eV1cIiwgICAgICAgICAgLy8gdm93ZWxcbiAgICBDID0gYyArIFwiW15hZWlvdXldKlwiLCAgICAvLyBjb25zb25hbnQgc2VxdWVuY2VcbiAgICBWID0gdiArIFwiW2FlaW91XSpcIiwgICAgICAvLyB2b3dlbCBzZXF1ZW5jZVxuXG4gICAgbWdyMCA9IFwiXihcIiArIEMgKyBcIik/XCIgKyBWICsgQywgICAgICAgICAgICAgICAvLyBbQ11WQy4uLiBpcyBtPjBcbiAgICBtZXExID0gXCJeKFwiICsgQyArIFwiKT9cIiArIFYgKyBDICsgXCIoXCIgKyBWICsgXCIpPyRcIiwgIC8vIFtDXVZDW1ZdIGlzIG09MVxuICAgIG1ncjEgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgViArIEMgKyBWICsgQywgICAgICAgLy8gW0NdVkNWQy4uLiBpcyBtPjFcbiAgICBzX3YgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgdjsgICAgICAgICAgICAgICAgICAgLy8gdm93ZWwgaW4gc3RlbVxuXG4gIHZhciByZV9tZ3IwID0gbmV3IFJlZ0V4cChtZ3IwKTtcbiAgdmFyIHJlX21ncjEgPSBuZXcgUmVnRXhwKG1ncjEpO1xuICB2YXIgcmVfbWVxMSA9IG5ldyBSZWdFeHAobWVxMSk7XG4gIHZhciByZV9zX3YgPSBuZXcgUmVnRXhwKHNfdik7XG5cbiAgdmFyIHJlXzFhID0gL14oLis/KShzc3xpKWVzJC87XG4gIHZhciByZTJfMWEgPSAvXiguKz8pKFtec10pcyQvO1xuICB2YXIgcmVfMWIgPSAvXiguKz8pZWVkJC87XG4gIHZhciByZTJfMWIgPSAvXiguKz8pKGVkfGluZykkLztcbiAgdmFyIHJlXzFiXzIgPSAvLiQvO1xuICB2YXIgcmUyXzFiXzIgPSAvKGF0fGJsfGl6KSQvO1xuICB2YXIgcmUzXzFiXzIgPSBuZXcgUmVnRXhwKFwiKFteYWVpb3V5bHN6XSlcXFxcMSRcIik7XG4gIHZhciByZTRfMWJfMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBDICsgdiArIFwiW15hZWlvdXd4eV0kXCIpO1xuXG4gIHZhciByZV8xYyA9IC9eKC4rP1teYWVpb3VdKXkkLztcbiAgdmFyIHJlXzIgPSAvXiguKz8pKGF0aW9uYWx8dGlvbmFsfGVuY2l8YW5jaXxpemVyfGJsaXxhbGxpfGVudGxpfGVsaXxvdXNsaXxpemF0aW9ufGF0aW9ufGF0b3J8YWxpc218aXZlbmVzc3xmdWxuZXNzfG91c25lc3N8YWxpdGl8aXZpdGl8YmlsaXRpfGxvZ2kpJC87XG5cbiAgdmFyIHJlXzMgPSAvXiguKz8pKGljYXRlfGF0aXZlfGFsaXplfGljaXRpfGljYWx8ZnVsfG5lc3MpJC87XG5cbiAgdmFyIHJlXzQgPSAvXiguKz8pKGFsfGFuY2V8ZW5jZXxlcnxpY3xhYmxlfGlibGV8YW50fGVtZW50fG1lbnR8ZW50fG91fGlzbXxhdGV8aXRpfG91c3xpdmV8aXplKSQvO1xuICB2YXIgcmUyXzQgPSAvXiguKz8pKHN8dCkoaW9uKSQvO1xuXG4gIHZhciByZV81ID0gL14oLis/KWUkLztcbiAgdmFyIHJlXzVfMSA9IC9sbCQvO1xuICB2YXIgcmUzXzUgPSBuZXcgUmVnRXhwKFwiXlwiICsgQyArIHYgKyBcIlteYWVpb3V3eHldJFwiKTtcblxuICB2YXIgcG9ydGVyU3RlbW1lciA9IGZ1bmN0aW9uIHBvcnRlclN0ZW1tZXIodykge1xuICAgIHZhciAgIHN0ZW0sXG4gICAgICBzdWZmaXgsXG4gICAgICBmaXJzdGNoLFxuICAgICAgcmUsXG4gICAgICByZTIsXG4gICAgICByZTMsXG4gICAgICByZTQ7XG5cbiAgICBpZiAody5sZW5ndGggPCAzKSB7IHJldHVybiB3OyB9XG5cbiAgICBmaXJzdGNoID0gdy5zdWJzdHIoMCwxKTtcbiAgICBpZiAoZmlyc3RjaCA9PSBcInlcIikge1xuICAgICAgdyA9IGZpcnN0Y2gudG9VcHBlckNhc2UoKSArIHcuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgMWFcbiAgICByZSA9IHJlXzFhXG4gICAgcmUyID0gcmUyXzFhO1xuXG4gICAgaWYgKHJlLnRlc3QodykpIHsgdyA9IHcucmVwbGFjZShyZSxcIiQxJDJcIik7IH1cbiAgICBlbHNlIGlmIChyZTIudGVzdCh3KSkgeyB3ID0gdy5yZXBsYWNlKHJlMixcIiQxJDJcIik7IH1cblxuICAgIC8vIFN0ZXAgMWJcbiAgICByZSA9IHJlXzFiO1xuICAgIHJlMiA9IHJlMl8xYjtcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHJlID0gcmVfbWdyMDtcbiAgICAgIGlmIChyZS50ZXN0KGZwWzFdKSkge1xuICAgICAgICByZSA9IHJlXzFiXzI7XG4gICAgICAgIHcgPSB3LnJlcGxhY2UocmUsXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZTIudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUyLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZTIgPSByZV9zX3Y7XG4gICAgICBpZiAocmUyLnRlc3Qoc3RlbSkpIHtcbiAgICAgICAgdyA9IHN0ZW07XG4gICAgICAgIHJlMiA9IHJlMl8xYl8yO1xuICAgICAgICByZTMgPSByZTNfMWJfMjtcbiAgICAgICAgcmU0ID0gcmU0XzFiXzI7XG4gICAgICAgIGlmIChyZTIudGVzdCh3KSkgeyAgdyA9IHcgKyBcImVcIjsgfVxuICAgICAgICBlbHNlIGlmIChyZTMudGVzdCh3KSkgeyByZSA9IHJlXzFiXzI7IHcgPSB3LnJlcGxhY2UocmUsXCJcIik7IH1cbiAgICAgICAgZWxzZSBpZiAocmU0LnRlc3QodykpIHsgdyA9IHcgKyBcImVcIjsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgMWMgLSByZXBsYWNlIHN1ZmZpeCB5IG9yIFkgYnkgaSBpZiBwcmVjZWRlZCBieSBhIG5vbi12b3dlbCB3aGljaCBpcyBub3QgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgd29yZCAoc28gY3J5IC0+IGNyaSwgYnkgLT4gYnksIHNheSAtPiBzYXkpXG4gICAgcmUgPSByZV8xYztcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXTtcbiAgICAgIHcgPSBzdGVtICsgXCJpXCI7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAyXG4gICAgcmUgPSByZV8yO1xuICAgIGlmIChyZS50ZXN0KHcpKSB7XG4gICAgICB2YXIgZnAgPSByZS5leGVjKHcpO1xuICAgICAgc3RlbSA9IGZwWzFdO1xuICAgICAgc3VmZml4ID0gZnBbMl07XG4gICAgICByZSA9IHJlX21ncjA7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbSArIHN0ZXAybGlzdFtzdWZmaXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgM1xuICAgIHJlID0gcmVfMztcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXTtcbiAgICAgIHN1ZmZpeCA9IGZwWzJdO1xuICAgICAgcmUgPSByZV9tZ3IwO1xuICAgICAgaWYgKHJlLnRlc3Qoc3RlbSkpIHtcbiAgICAgICAgdyA9IHN0ZW0gKyBzdGVwM2xpc3Rbc3VmZml4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIDRcbiAgICByZSA9IHJlXzQ7XG4gICAgcmUyID0gcmUyXzQ7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZSA9IHJlX21ncjE7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlMi50ZXN0KHcpKSB7XG4gICAgICB2YXIgZnAgPSByZTIuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXSArIGZwWzJdO1xuICAgICAgcmUyID0gcmVfbWdyMTtcbiAgICAgIGlmIChyZTIudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIDVcbiAgICByZSA9IHJlXzU7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZSA9IHJlX21ncjE7XG4gICAgICByZTIgPSByZV9tZXExO1xuICAgICAgcmUzID0gcmUzXzU7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSB8fCAocmUyLnRlc3Qoc3RlbSkgJiYgIShyZTMudGVzdChzdGVtKSkpKSB7XG4gICAgICAgIHcgPSBzdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlID0gcmVfNV8xO1xuICAgIHJlMiA9IHJlX21ncjE7XG4gICAgaWYgKHJlLnRlc3QodykgJiYgcmUyLnRlc3QodykpIHtcbiAgICAgIHJlID0gcmVfMWJfMjtcbiAgICAgIHcgPSB3LnJlcGxhY2UocmUsXCJcIik7XG4gICAgfVxuXG4gICAgLy8gYW5kIHR1cm4gaW5pdGlhbCBZIGJhY2sgdG8geVxuXG4gICAgaWYgKGZpcnN0Y2ggPT0gXCJ5XCIpIHtcbiAgICAgIHcgPSBmaXJzdGNoLnRvTG93ZXJDYXNlKCkgKyB3LnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfTtcblxuICByZXR1cm4gcG9ydGVyU3RlbW1lcjtcbn0pKCk7XG5cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24oZWxhc3RpY2x1bnIuc3RlbW1lciwgJ3N0ZW1tZXInKTtcbi8qIVxuICogZWxhc3RpY2x1bnIuc3RvcFdvcmRGaWx0ZXJcbiAqIENvcHlyaWdodCAoQykgMjAxNiBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqIENvcHlyaWdodCAoQykgMjAxNiBXZWkgU29uZ1xuICovXG5cbi8qKlxuICogZWxhc3RpY2x1bnIuc3RvcFdvcmRGaWx0ZXIgaXMgYW4gRW5nbGlzaCBsYW5ndWFnZSBzdG9wIHdvcmRzIGZpbHRlciwgYW55IHdvcmRzXG4gKiBjb250YWluZWQgaW4gdGhlIHN0b3Agd29yZCBsaXN0IHdpbGwgbm90IGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBmaWx0ZXIuXG4gKlxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIHRoZSBQaXBlbGluZS4gSWYgdGhlIHRva2VuIGRvZXMgbm90IHBhc3MgdGhlXG4gKiBmaWx0ZXIgdGhlbiB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEN1cnJlbnRseSB0aGlzIFN0b3B3b3JkRmlsdGVyIHVzaW5nIGRpY3Rpb25hcnkgdG8gZG8gTygxKSB0aW1lIGNvbXBsZXhpdHkgc3RvcCB3b3JkIGZpbHRlcmluZy5cbiAqXG4gKiBAbW9kdWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIHBhc3MgdGhyb3VnaCB0aGUgZmlsdGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAc2VlIGVsYXN0aWNsdW5yLlBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLnN0b3BXb3JkRmlsdGVyID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIGlmICh0b2tlbiAmJiBlbGFzdGljbHVuci5zdG9wV29yZEZpbHRlci5zdG9wV29yZHNbdG9rZW5dICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBwcmVkZWZpbmVkIHN0b3Agd29yZHNcbiAqIGlmIHVzZXIgd2FudCB0byB1c2UgY3VzdG9taXplZCBzdG9wIHdvcmRzLCB1c2VyIGNvdWxkIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGRlbGV0ZVxuICogYWxsIHByZWRlZmluZWQgc3RvcHdvcmRzLlxuICpcbiAqIEByZXR1cm4ge251bGx9XG4gKi9cbmVsYXN0aWNsdW5yLmNsZWFyU3RvcFdvcmRzID0gZnVuY3Rpb24gKCkge1xuICBlbGFzdGljbHVuci5zdG9wV29yZEZpbHRlci5zdG9wV29yZHMgPSB7fTtcbn07XG5cbi8qKlxuICogQWRkIGN1c3RvbWl6ZWQgc3RvcCB3b3Jkc1xuICogdXNlciBjb3VsZCB1c2UgdGhpcyBmdW5jdGlvbiB0byBhZGQgY3VzdG9taXplZCBzdG9wIHdvcmRzXG4gKiBcbiAqIEBwYXJhbXMge0FycmF5fSB3b3JkcyBjdXN0b21pemVkIHN0b3Agd29yZHNcbiAqIEByZXR1cm4ge251bGx9XG4gKi9cbmVsYXN0aWNsdW5yLmFkZFN0b3BXb3JkcyA9IGZ1bmN0aW9uICh3b3Jkcykge1xuICBpZiAod29yZHMgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHdvcmRzKSA9PT0gZmFsc2UpIHJldHVybjtcblxuICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgZWxhc3RpY2x1bnIuc3RvcFdvcmRGaWx0ZXIuc3RvcFdvcmRzW3dvcmRdID0gdHJ1ZTtcbiAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRvIGRlZmF1bHQgc3RvcCB3b3Jkc1xuICogdXNlciBjb3VsZCB1c2UgdGhpcyBmdW5jdGlvbiB0byByZXN0b3JlIGRlZmF1bHQgc3RvcCB3b3Jkc1xuICpcbiAqIEByZXR1cm4ge251bGx9XG4gKi9cbmVsYXN0aWNsdW5yLnJlc2V0U3RvcFdvcmRzID0gZnVuY3Rpb24gKCkge1xuICBlbGFzdGljbHVuci5zdG9wV29yZEZpbHRlci5zdG9wV29yZHMgPSBlbGFzdGljbHVuci5kZWZhdWx0U3RvcFdvcmRzO1xufTtcblxuZWxhc3RpY2x1bnIuZGVmYXVsdFN0b3BXb3JkcyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJhXCI6IHRydWUsXG4gIFwiYWJsZVwiOiB0cnVlLFxuICBcImFib3V0XCI6IHRydWUsXG4gIFwiYWNyb3NzXCI6IHRydWUsXG4gIFwiYWZ0ZXJcIjogdHJ1ZSxcbiAgXCJhbGxcIjogdHJ1ZSxcbiAgXCJhbG1vc3RcIjogdHJ1ZSxcbiAgXCJhbHNvXCI6IHRydWUsXG4gIFwiYW1cIjogdHJ1ZSxcbiAgXCJhbW9uZ1wiOiB0cnVlLFxuICBcImFuXCI6IHRydWUsXG4gIFwiYW5kXCI6IHRydWUsXG4gIFwiYW55XCI6IHRydWUsXG4gIFwiYXJlXCI6IHRydWUsXG4gIFwiYXNcIjogdHJ1ZSxcbiAgXCJhdFwiOiB0cnVlLFxuICBcImJlXCI6IHRydWUsXG4gIFwiYmVjYXVzZVwiOiB0cnVlLFxuICBcImJlZW5cIjogdHJ1ZSxcbiAgXCJidXRcIjogdHJ1ZSxcbiAgXCJieVwiOiB0cnVlLFxuICBcImNhblwiOiB0cnVlLFxuICBcImNhbm5vdFwiOiB0cnVlLFxuICBcImNvdWxkXCI6IHRydWUsXG4gIFwiZGVhclwiOiB0cnVlLFxuICBcImRpZFwiOiB0cnVlLFxuICBcImRvXCI6IHRydWUsXG4gIFwiZG9lc1wiOiB0cnVlLFxuICBcImVpdGhlclwiOiB0cnVlLFxuICBcImVsc2VcIjogdHJ1ZSxcbiAgXCJldmVyXCI6IHRydWUsXG4gIFwiZXZlcnlcIjogdHJ1ZSxcbiAgXCJmb3JcIjogdHJ1ZSxcbiAgXCJmcm9tXCI6IHRydWUsXG4gIFwiZ2V0XCI6IHRydWUsXG4gIFwiZ290XCI6IHRydWUsXG4gIFwiaGFkXCI6IHRydWUsXG4gIFwiaGFzXCI6IHRydWUsXG4gIFwiaGF2ZVwiOiB0cnVlLFxuICBcImhlXCI6IHRydWUsXG4gIFwiaGVyXCI6IHRydWUsXG4gIFwiaGVyc1wiOiB0cnVlLFxuICBcImhpbVwiOiB0cnVlLFxuICBcImhpc1wiOiB0cnVlLFxuICBcImhvd1wiOiB0cnVlLFxuICBcImhvd2V2ZXJcIjogdHJ1ZSxcbiAgXCJpXCI6IHRydWUsXG4gIFwiaWZcIjogdHJ1ZSxcbiAgXCJpblwiOiB0cnVlLFxuICBcImludG9cIjogdHJ1ZSxcbiAgXCJpc1wiOiB0cnVlLFxuICBcIml0XCI6IHRydWUsXG4gIFwiaXRzXCI6IHRydWUsXG4gIFwianVzdFwiOiB0cnVlLFxuICBcImxlYXN0XCI6IHRydWUsXG4gIFwibGV0XCI6IHRydWUsXG4gIFwibGlrZVwiOiB0cnVlLFxuICBcImxpa2VseVwiOiB0cnVlLFxuICBcIm1heVwiOiB0cnVlLFxuICBcIm1lXCI6IHRydWUsXG4gIFwibWlnaHRcIjogdHJ1ZSxcbiAgXCJtb3N0XCI6IHRydWUsXG4gIFwibXVzdFwiOiB0cnVlLFxuICBcIm15XCI6IHRydWUsXG4gIFwibmVpdGhlclwiOiB0cnVlLFxuICBcIm5vXCI6IHRydWUsXG4gIFwibm9yXCI6IHRydWUsXG4gIFwibm90XCI6IHRydWUsXG4gIFwib2ZcIjogdHJ1ZSxcbiAgXCJvZmZcIjogdHJ1ZSxcbiAgXCJvZnRlblwiOiB0cnVlLFxuICBcIm9uXCI6IHRydWUsXG4gIFwib25seVwiOiB0cnVlLFxuICBcIm9yXCI6IHRydWUsXG4gIFwib3RoZXJcIjogdHJ1ZSxcbiAgXCJvdXJcIjogdHJ1ZSxcbiAgXCJvd25cIjogdHJ1ZSxcbiAgXCJyYXRoZXJcIjogdHJ1ZSxcbiAgXCJzYWlkXCI6IHRydWUsXG4gIFwic2F5XCI6IHRydWUsXG4gIFwic2F5c1wiOiB0cnVlLFxuICBcInNoZVwiOiB0cnVlLFxuICBcInNob3VsZFwiOiB0cnVlLFxuICBcInNpbmNlXCI6IHRydWUsXG4gIFwic29cIjogdHJ1ZSxcbiAgXCJzb21lXCI6IHRydWUsXG4gIFwidGhhblwiOiB0cnVlLFxuICBcInRoYXRcIjogdHJ1ZSxcbiAgXCJ0aGVcIjogdHJ1ZSxcbiAgXCJ0aGVpclwiOiB0cnVlLFxuICBcInRoZW1cIjogdHJ1ZSxcbiAgXCJ0aGVuXCI6IHRydWUsXG4gIFwidGhlcmVcIjogdHJ1ZSxcbiAgXCJ0aGVzZVwiOiB0cnVlLFxuICBcInRoZXlcIjogdHJ1ZSxcbiAgXCJ0aGlzXCI6IHRydWUsXG4gIFwidGlzXCI6IHRydWUsXG4gIFwidG9cIjogdHJ1ZSxcbiAgXCJ0b29cIjogdHJ1ZSxcbiAgXCJ0d2FzXCI6IHRydWUsXG4gIFwidXNcIjogdHJ1ZSxcbiAgXCJ3YW50c1wiOiB0cnVlLFxuICBcIndhc1wiOiB0cnVlLFxuICBcIndlXCI6IHRydWUsXG4gIFwid2VyZVwiOiB0cnVlLFxuICBcIndoYXRcIjogdHJ1ZSxcbiAgXCJ3aGVuXCI6IHRydWUsXG4gIFwid2hlcmVcIjogdHJ1ZSxcbiAgXCJ3aGljaFwiOiB0cnVlLFxuICBcIndoaWxlXCI6IHRydWUsXG4gIFwid2hvXCI6IHRydWUsXG4gIFwid2hvbVwiOiB0cnVlLFxuICBcIndoeVwiOiB0cnVlLFxuICBcIndpbGxcIjogdHJ1ZSxcbiAgXCJ3aXRoXCI6IHRydWUsXG4gIFwid291bGRcIjogdHJ1ZSxcbiAgXCJ5ZXRcIjogdHJ1ZSxcbiAgXCJ5b3VcIjogdHJ1ZSxcbiAgXCJ5b3VyXCI6IHRydWVcbn07XG5cbmVsYXN0aWNsdW5yLnN0b3BXb3JkRmlsdGVyLnN0b3BXb3JkcyA9IGVsYXN0aWNsdW5yLmRlZmF1bHRTdG9wV29yZHM7XG5cbmVsYXN0aWNsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24oZWxhc3RpY2x1bnIuc3RvcFdvcmRGaWx0ZXIsICdzdG9wV29yZEZpbHRlcicpO1xuLyohXG4gKiBlbGFzdGljbHVuci50cmltbWVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgV2VpIFNvbmdcbiAqL1xuXG4vKipcbiAqIGVsYXN0aWNsdW5yLnRyaW1tZXIgaXMgYSBwaXBlbGluZSBmdW5jdGlvbiBmb3IgdHJpbW1pbmcgbm9uIHdvcmRcbiAqIGNoYXJhY3RlcnMgZnJvbSB0aGUgYmVnaW5pbmcgYW5kIGVuZCBvZiB0b2tlbnMgYmVmb3JlIHRoZXlcbiAqIGVudGVyIHRoZSBpbmRleC5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG1heSBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbiBsYXRpblxuICogY2hhcmFjdGVycyBhbmQgc2hvdWxkIGVpdGhlciBiZSByZW1vdmVkIG9yIGFkYXB0ZWQgZm9yIHVzZVxuICogd2l0aCBsYW5ndWFnZXMgd2l0aCBub24tbGF0aW4gY2hhcmFjdGVycy5cbiAqXG4gKiBAbW9kdWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIHBhc3MgdGhyb3VnaCB0aGUgZmlsdGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAc2VlIGVsYXN0aWNsdW5yLlBpcGVsaW5lXG4gKi9cbmVsYXN0aWNsdW5yLnRyaW1tZXIgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgaWYgKHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkJyk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5cbiAgICAucmVwbGFjZSgvXlxcVysvLCAnJylcbiAgICAucmVwbGFjZSgvXFxXKyQvLCAnJyk7XG59O1xuXG5lbGFzdGljbHVuci5QaXBlbGluZS5yZWdpc3RlckZ1bmN0aW9uKGVsYXN0aWNsdW5yLnRyaW1tZXIsICd0cmltbWVyJyk7XG4vKiFcbiAqIGVsYXN0aWNsdW5yLkludmVydGVkSW5kZXhcbiAqIENvcHlyaWdodCAoQykgMjAxNiBXZWkgU29uZ1xuICogSW5jbHVkZXMgY29kZSBmcm9tIC0gaHR0cDovL3RhcnRhcnVzLm9yZy9+bWFydGluL1BvcnRlclN0ZW1tZXIvanMudHh0XG4gKi9cblxuLyoqXG4gKiBlbGFzdGljbHVuci5JbnZlcnRlZEluZGV4IGlzIHVzZWQgZm9yIGVmZmljaWVudGx5IHN0b3JpbmcgYW5kXG4gKiBsb29rdXAgb2YgZG9jdW1lbnRzIHRoYXQgY29udGFpbiBhIGdpdmVuIHRva2VuLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5lbGFzdGljbHVuci5JbnZlcnRlZEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3QgPSB7IGRvY3M6IHt9LCBkZjogMCB9O1xufTtcblxuLyoqXG4gKiBMb2FkcyBhIHByZXZpb3VzbHkgc2VyaWFsaXNlZCBpbnZlcnRlZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXNlZERhdGEgVGhlIHNlcmlhbGlzZWQgaW52ZXJ0ZWQgaW5kZXggdG8gbG9hZC5cbiAqIEByZXR1cm4ge2VsYXN0aWNsdW5yLkludmVydGVkSW5kZXh9XG4gKi9cbmVsYXN0aWNsdW5yLkludmVydGVkSW5kZXgubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpc2VkRGF0YSkge1xuICB2YXIgaWR4ID0gbmV3IHRoaXM7XG4gIGlkeC5yb290ID0gc2VyaWFsaXNlZERhdGEucm9vdDtcblxuICByZXR1cm4gaWR4O1xufTtcblxuLyoqXG4gKiBBZGRzIGEge3Rva2VuOiB0b2tlbkluZm99IHBhaXIgdG8gdGhlIGludmVydGVkIGluZGV4LlxuICogSWYgdGhlIHRva2VuIGFscmVhZHkgZXhpc3QsIHRoZW4gdXBkYXRlIHRoZSB0b2tlbkluZm8uXG4gKlxuICogdG9rZW5JbmZvIGZvcm1hdDogeyByZWY6IDEsIHRmOiAyfVxuICogdG9rZW5JbmZvciBzaG91bGQgY29udGFpbnMgdGhlIGRvY3VtZW50J3MgcmVmIGFuZCB0aGUgdGYodG9rZW4gZnJlcXVlbmN5KSBvZiB0aGF0IHRva2VuIGluXG4gKiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQnkgZGVmYXVsdCB0aGlzIGZ1bmN0aW9uIHN0YXJ0cyBhdCB0aGUgcm9vdCBvZiB0aGUgY3VycmVudCBpbnZlcnRlZCBpbmRleCwgaG93ZXZlclxuICogaXQgY2FuIHN0YXJ0IGF0IGFueSBub2RlIG9mIHRoZSBpbnZlcnRlZCBpbmRleCBpZiByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5JbmZvIGZvcm1hdDogeyByZWY6IDEsIHRmOiAyfVxuICogQHBhcmFtIHtPYmplY3R9IHJvb3QgQW4gb3B0aW9uYWwgbm9kZSBhdCB3aGljaCB0byBzdGFydCBsb29raW5nIGZvciB0aGVcbiAqIGNvcnJlY3QgcGxhY2UgdG8gZW50ZXIgdGhlIGRvYywgYnkgZGVmYXVsdCB0aGUgcm9vdCBvZiB0aGlzIGVsYXN0aWNsdW5yLkludmVydGVkSW5kZXhcbiAqIGlzIHVzZWQuXG4gKiBAbWVtYmVyT2YgSW52ZXJ0ZWRJbmRleFxuICovXG5lbGFzdGljbHVuci5JbnZlcnRlZEluZGV4LnByb3RvdHlwZS5hZGRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5JbmZvLCByb290KSB7XG4gIHZhciByb290ID0gcm9vdCB8fCB0aGlzLnJvb3QsXG4gICAgICBpZHggPSAwO1xuXG4gIHdoaWxlIChpZHggPD0gdG9rZW4ubGVuZ3RoIC0gMSkge1xuICAgIHZhciBrZXkgPSB0b2tlbltpZHhdO1xuXG4gICAgaWYgKCEoa2V5IGluIHJvb3QpKSByb290W2tleV0gPSB7ZG9jczoge30sIGRmOiAwfTtcbiAgICBpZHggKz0gMTtcbiAgICByb290ID0gcm9vdFtrZXldO1xuICB9XG5cbiAgdmFyIGRvY1JlZiA9IHRva2VuSW5mby5yZWY7XG4gIGlmICghcm9vdC5kb2NzW2RvY1JlZl0pIHtcbiAgICAvLyBpZiB0aGlzIGRvYyBub3QgZXhpc3QsIHRoZW4gYWRkIHRoaXMgZG9jXG4gICAgcm9vdC5kb2NzW2RvY1JlZl0gPSB7dGY6IHRva2VuSW5mby50Zn07XG4gICAgcm9vdC5kZiArPSAxO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoaXMgZG9jIGFscmVhZHkgZXhpc3QsIHRoZW4gdXBkYXRlIHRva2VuSW5mb1xuICAgIHJvb3QuZG9jc1tkb2NSZWZdID0ge3RmOiB0b2tlbkluZm8udGZ9O1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdG9rZW4gaXMgaW4gdGhpcyBlbGFzdGljbHVuci5JbnZlcnRlZEluZGV4LlxuICogXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQG1lbWJlck9mIEludmVydGVkSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW52ZXJ0ZWRJbmRleC5wcm90b3R5cGUuaGFzVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgaWYgKCF0b2tlbikgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBub2RlID0gdGhpcy5yb290O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW5vZGVbdG9rZW5baV1dKSByZXR1cm4gZmFsc2U7XG4gICAgbm9kZSA9IG5vZGVbdG9rZW5baV1dO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgbm9kZSBmcm9tIHRoZSBpbnZlcnRlZCBpbmRleCBmb3IgYSBnaXZlbiB0b2tlbi5cbiAqIElmIHRva2VuIG5vdCBmb3VuZCBpbiB0aGlzIEludmVydGVkSW5kZXgsIHJldHVybiBudWxsLlxuICogXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBnZXQgdGhlIG5vZGUgZm9yLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBJbnZlcnRlZEluZGV4LnByb3RvdHlwZS5nZXRcbiAqIEBtZW1iZXJPZiBJbnZlcnRlZEluZGV4XG4gKi9cbmVsYXN0aWNsdW5yLkludmVydGVkSW5kZXgucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgaWYgKCF0b2tlbikgcmV0dXJuIG51bGw7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnJvb3Q7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbm9kZVt0b2tlbltpXV0pIHJldHVybiBudWxsO1xuICAgIG5vZGUgPSBub2RlW3Rva2VuW2ldXTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgZG9jdW1lbnRzIG9mIGEgZ2l2ZW4gdG9rZW4uXG4gKiBJZiB0b2tlbiBub3QgZm91bmQsIHJldHVybiB7fS5cbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBnZXQgdGhlIGRvY3VtZW50cyBmb3IuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAbWVtYmVyT2YgSW52ZXJ0ZWRJbmRleFxuICovXG5lbGFzdGljbHVuci5JbnZlcnRlZEluZGV4LnByb3RvdHlwZS5nZXREb2NzID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHZhciBub2RlID0gdGhpcy5nZXROb2RlKHRva2VuKTtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiBub2RlLmRvY3M7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRlcm0gZnJlcXVlbmN5IG9mIGdpdmVuIHRva2VuIGluIGdpdmVuIGRvY1JlZi5cbiAqIElmIHRva2VuIG9yIGRvY1JlZiBub3QgZm91bmQsIHJldHVybiAwLlxuICpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIGdldCB0aGUgZG9jdW1lbnRzIGZvci5cbiAqIEBwYXJhbSB7U3RyaW5nfEludGVnZXJ9IGRvY1JlZlxuICogQHJldHVybiB7SW50ZWdlcn1cbiAqIEBtZW1iZXJPZiBJbnZlcnRlZEluZGV4XG4gKi9cbmVsYXN0aWNsdW5yLkludmVydGVkSW5kZXgucHJvdG90eXBlLmdldFRlcm1GcmVxdWVuY3kgPSBmdW5jdGlvbiAodG9rZW4sIGRvY1JlZikge1xuICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSh0b2tlbik7XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKCEoZG9jUmVmIGluIG5vZGUuZG9jcykpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBub2RlLmRvY3NbZG9jUmVmXS50Zjtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGRvY3VtZW50IGZyZXF1ZW5jeSBvZiBnaXZlbiB0b2tlbi5cbiAqIElmIHRva2VuIG5vdCBmb3VuZCwgcmV0dXJuIDAuXG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4gdG8gZ2V0IHRoZSBkb2N1bWVudHMgZm9yLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQG1lbWJlck9mIEludmVydGVkSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW52ZXJ0ZWRJbmRleC5wcm90b3R5cGUuZ2V0RG9jRnJlcSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSh0b2tlbik7XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUuZGY7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZG9jdW1lbnQgaWRlbnRpZmllZCBieSBkb2N1bWVudCdzIHJlZiBmcm9tIHRoZSB0b2tlbiBpbiB0aGUgaW52ZXJ0ZWQgaW5kZXguXG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBSZW1vdmUgdGhlIGRvY3VtZW50IGZyb20gd2hpY2ggdG9rZW4uXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVmIFRoZSByZWYgb2YgdGhlIGRvY3VtZW50IHRvIHJlbW92ZSBmcm9tIGdpdmVuIHRva2VuLlxuICogQG1lbWJlck9mIEludmVydGVkSW5kZXhcbiAqL1xuZWxhc3RpY2x1bnIuSW52ZXJ0ZWRJbmRleC5wcm90b3R5cGUucmVtb3ZlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHJlZikge1xuICBpZiAoIXRva2VuKSByZXR1cm47XG4gIHZhciBub2RlID0gdGhpcy5nZXROb2RlKHRva2VuKTtcblxuICBpZiAobm9kZSA9PSBudWxsKSByZXR1cm47XG5cbiAgaWYgKHJlZiBpbiBub2RlLmRvY3MpIHtcbiAgICBkZWxldGUgbm9kZS5kb2NzW3JlZl07XG4gICAgbm9kZS5kZiAtPSAxO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbmQgYWxsIHRoZSBwb3NzaWJsZSBzdWZmaXhlcyBvZiBnaXZlbiB0b2tlbiB1c2luZyB0b2tlbnMgY3VycmVudGx5IGluIHRoZSBpbnZlcnRlZCBpbmRleC5cbiAqIElmIHRva2VuIG5vdCBmb3VuZCwgcmV0dXJuIGVtcHR5IEFycmF5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4gdG8gZXhwYW5kLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAbWVtYmVyT2YgSW52ZXJ0ZWRJbmRleFxuICovXG5lbGFzdGljbHVuci5JbnZlcnRlZEluZGV4LnByb3RvdHlwZS5leHBhbmRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVtbywgcm9vdCkge1xuICBpZiAodG9rZW4gPT0gbnVsbCB8fCB0b2tlbiA9PSAnJykgcmV0dXJuIFtdO1xuICB2YXIgbWVtbyA9IG1lbW8gfHwgW107XG5cbiAgaWYgKHJvb3QgPT0gdm9pZCAwKSB7XG4gICAgcm9vdCA9IHRoaXMuZ2V0Tm9kZSh0b2tlbik7XG4gICAgaWYgKHJvb3QgPT0gbnVsbCkgcmV0dXJuIG1lbW87XG4gIH1cblxuICBpZiAocm9vdC5kZiA+IDApIG1lbW8ucHVzaCh0b2tlbik7XG5cbiAgZm9yICh2YXIga2V5IGluIHJvb3QpIHtcbiAgICBpZiAoa2V5ID09PSAnZG9jcycpIGNvbnRpbnVlO1xuICAgIGlmIChrZXkgPT09ICdkZicpIGNvbnRpbnVlO1xuICAgIHRoaXMuZXhwYW5kVG9rZW4odG9rZW4gKyBrZXksIG1lbW8sIHJvb3Rba2V5XSk7XG4gIH1cblxuICByZXR1cm4gbWVtbztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnZlcnRlZCBpbmRleCByZWFkeSBmb3Igc2VyaWFsaXNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAbWVtYmVyT2YgSW52ZXJ0ZWRJbmRleFxuICovXG5lbGFzdGljbHVuci5JbnZlcnRlZEluZGV4LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgcm9vdDogdGhpcy5yb290XG4gIH07XG59O1xuXG4vKiFcbiAqIGVsYXN0aWNsdW5yLkNvbmZpZ3VyYXRpb25cbiAqIENvcHlyaWdodCAoQykgMjAxNiBXZWkgU29uZ1xuICovXG4gXG4gLyoqIFxuICAqIGVsYXN0aWNsdW5yLkNvbmZpZ3VyYXRpb24gaXMgdXNlZCB0byBhbmFseXplIHRoZSB1c2VyIHNlYXJjaCBjb25maWd1cmF0aW9uLlxuICAqIFxuICAqIEJ5IGVsYXN0aWNsdW5yLkNvbmZpZ3VyYXRpb24gdXNlciBjb3VsZCBzZXQgcXVlcnktdGltZSBib29zdGluZywgYm9vbGVhbiBtb2RlbCBpbiBlYWNoIGZpZWxkLlxuICAqIFxuICAqIEN1cnJlbnRseSBjb25maWd1cmF0aW9uIHN1cHBvcnRzOlxuICAqIDEuIHF1ZXJ5LXRpbWUgYm9vc3RpbmcsIHVzZXIgY291bGQgc2V0IGhvdyB0byBib29zdCBlYWNoIGZpZWxkLlxuICAqIDIuIGJvb2xlYW4gbW9kZWwgY2hvc2luZywgdXNlciBjb3VsZCBjaG9vc2Ugd2hpY2ggYm9vbGVhbiBtb2RlbCB0byB1c2UgZm9yIGVhY2ggZmllbGQuXG4gICogMy4gdG9rZW4gZXhwYW5kYXRpb24sIHVzZXIgY291bGQgc2V0IHRva2VuIGV4cGFuZCB0byBUcnVlIHRvIGltcHJvdmUgUmVjYWxsLiBEZWZhdWx0IGlzIEZhbHNlLlxuICAqIFxuICAqIFF1ZXJ5IHRpbWUgYm9vc3RpbmcgbXVzdCBiZSBjb25maWd1cmVkIGJ5IGZpZWxkIGNhdGVnb3J5LCBcImJvb2xlYW5cIiBtb2RlbCBjb3VsZCBiZSBjb25maWd1cmVkIFxuICAqIGJ5IGJvdGggZmllbGQgY2F0ZWdvcnkgb3IgZ2xvYmFsbHkgYXMgdGhlIGZvbGxvd2luZyBleGFtcGxlLiBGaWVsZCBjb25maWd1cmF0aW9uIGZvciBcImJvb2xlYW5cIlxuICAqIHdpbGwgb3ZlcndyaXRlIGdsb2JhbCBjb25maWd1cmF0aW9uLlxuICAqIFRva2VuIGV4cGFuZCBjb3VsZCBiZSBjb25maWd1cmVkIGJvdGggYnkgZmllbGQgY2F0ZWdvcnkgb3IgZ29sYmFsbHkuIExvY2FsIGZpZWxkIGNvbmZpZ3VyYXRpb24gd2lsbFxuICAqIG92ZXJ3cml0ZSBnbG9iYWwgY29uZmlndXJhdGlvbi5cbiAgKiBcbiAgKiBjb25maWd1cmF0aW9uIGV4YW1wbGU6XG4gICoge1xuICAqICAgZmllbGRzOnsgXG4gICogICAgIHRpdGxlOiB7Ym9vc3Q6IDJ9LFxuICAqICAgICBib2R5OiB7Ym9vc3Q6IDF9XG4gICogICB9LFxuICAqICAgYm9vbDogXCJPUlwiXG4gICogfVxuICAqIFxuICAqIFwiYm9vbFwiIGZpZWxkIGNvbmZpZ3VhdGlvbiBvdmVyd3JpdGUgZ2xvYmFsIGNvbmZpZ3VhdGlvbiBleGFtcGxlOlxuICAqIHtcbiAgKiAgIGZpZWxkczp7IFxuICAqICAgICB0aXRsZToge2Jvb3N0OiAyLCBib29sOiBcIkFORFwifSxcbiAgKiAgICAgYm9keToge2Jvb3N0OiAxfVxuICAqICAgfSxcbiAgKiAgIGJvb2w6IFwiT1JcIlxuICAqIH1cbiAgKiBcbiAgKiBcImV4cGFuZFwiIGV4YW1wbGU6XG4gICoge1xuICAqICAgZmllbGRzOnsgXG4gICogICAgIHRpdGxlOiB7Ym9vc3Q6IDIsIGJvb2w6IFwiQU5EXCJ9LFxuICAqICAgICBib2R5OiB7Ym9vc3Q6IDF9XG4gICogICB9LFxuICAqICAgYm9vbDogXCJPUlwiLFxuICAqICAgZXhwYW5kOiB0cnVlXG4gICogfVxuICAqIFxuICAqIFwiZXhwYW5kXCIgZXhhbXBsZSBmb3IgZmllbGQgY2F0ZWdvcnk6XG4gICoge1xuICAqICAgZmllbGRzOnsgXG4gICogICAgIHRpdGxlOiB7Ym9vc3Q6IDIsIGJvb2w6IFwiQU5EXCIsIGV4cGFuZDogdHJ1ZX0sXG4gICogICAgIGJvZHk6IHtib29zdDogMX1cbiAgKiAgIH0sXG4gICogICBib29sOiBcIk9SXCJcbiAgKiB9XG4gICogXG4gICogc2V0dGluZyB0aGUgYm9vc3QgdG8gMCBpZ25vcmVzIHRoZSBmaWVsZCAodGhpcyB3aWxsIG9ubHkgc2VhcmNoIHRoZSB0aXRsZSk6XG4gICoge1xuICAqICAgZmllbGRzOntcbiAgKiAgICAgdGl0bGU6IHtib29zdDogMX0sXG4gICogICAgIGJvZHk6IHtib29zdDogMH1cbiAgKiAgIH1cbiAgKiB9XG4gICpcbiAgKiB0aGVuLCB1c2VyIGNvdWxkIHNlYXJjaCB3aXRoIGNvbmZpZ3VyYXRpb24gdG8gZG8gcXVlcnktdGltZSBib29zdGluZy5cbiAgKiBpZHguc2VhcmNoKCdvcmFjbGUgZGF0YWJhc2UnLCB7ZmllbGRzOiB7dGl0bGU6IHtib29zdDogMn0sIGJvZHk6IHtib29zdDogMX19fSk7XG4gICogXG4gICogXG4gICogQGNvbnN0cnVjdG9yXG4gICogXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZyB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgZmllbGRzIG9mIGluZGV4IGluc3RhbmNlXG4gICogQG1vZHVsZVxuICAqL1xuZWxhc3RpY2x1bnIuQ29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIChjb25maWcsIGZpZWxkcykge1xuICB2YXIgY29uZmlnID0gY29uZmlnIHx8ICcnO1xuXG4gIGlmIChmaWVsZHMgPT0gdW5kZWZpbmVkIHx8IGZpZWxkcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZHMgc2hvdWxkIG5vdCBiZSBudWxsJyk7XG4gIH1cblxuICB0aGlzLmNvbmZpZyA9IHt9O1xuXG4gIHZhciB1c2VyQ29uZmlnO1xuICB0cnkge1xuICAgIHVzZXJDb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZyk7XG4gICAgdGhpcy5idWlsZFVzZXJDb25maWcodXNlckNvbmZpZywgZmllbGRzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlbGFzdGljbHVuci51dGlscy53YXJuKCd1c2VyIGNvbmZpZ3VyYXRpb24gcGFyc2UgZmFpbGVkLCB3aWxsIHVzZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24nKTtcbiAgICB0aGlzLmJ1aWxkRGVmYXVsdENvbmZpZyhmaWVsZHMpO1xuICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkIGRlZmF1bHQgc2VhcmNoIGNvbmZpZ3VyYXRpb24uXG4gKiBcbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBmaWVsZHMgb2YgaW5kZXggaW5zdGFuY2VcbiAqL1xuZWxhc3RpY2x1bnIuQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYnVpbGREZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24gKGZpZWxkcykge1xuICB0aGlzLnJlc2V0KCk7XG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHRoaXMuY29uZmlnW2ZpZWxkXSA9IHtcbiAgICAgIGJvb3N0OiAxLFxuICAgICAgYm9vbDogXCJPUlwiLFxuICAgICAgZXhwYW5kOiBmYWxzZVxuICAgIH07XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBCdWlsZCB1c2VyIGNvbmZpZ3VyYXRpb24uXG4gKiBcbiAqIEBwYXJhbSB7SlNPTn0gY29uZmlnIFVzZXIgSlNPTiBjb25maWd1cmF0b2luXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgZmllbGRzIG9mIGluZGV4IGluc3RhbmNlXG4gKi9cbmVsYXN0aWNsdW5yLkNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmJ1aWxkVXNlckNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIGZpZWxkcykge1xuICB2YXIgZ2xvYmFsX2Jvb2wgPSBcIk9SXCI7XG4gIHZhciBnbG9iYWxfZXhwYW5kID0gZmFsc2U7XG5cbiAgdGhpcy5yZXNldCgpO1xuICBpZiAoJ2Jvb2wnIGluIGNvbmZpZykge1xuICAgIGdsb2JhbF9ib29sID0gY29uZmlnWydib29sJ10gfHwgZ2xvYmFsX2Jvb2w7XG4gIH1cblxuICBpZiAoJ2V4cGFuZCcgaW4gY29uZmlnKSB7XG4gICAgZ2xvYmFsX2V4cGFuZCA9IGNvbmZpZ1snZXhwYW5kJ10gfHwgZ2xvYmFsX2V4cGFuZDtcbiAgfVxuXG4gIGlmICgnZmllbGRzJyBpbiBjb25maWcpIHtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBjb25maWdbJ2ZpZWxkcyddKSB7XG4gICAgICBpZiAoZmllbGRzLmluZGV4T2YoZmllbGQpID4gLTEpIHtcbiAgICAgICAgdmFyIGZpZWxkX2NvbmZpZyA9IGNvbmZpZ1snZmllbGRzJ11bZmllbGRdO1xuICAgICAgICB2YXIgZmllbGRfZXhwYW5kID0gZ2xvYmFsX2V4cGFuZDtcbiAgICAgICAgaWYgKGZpZWxkX2NvbmZpZy5leHBhbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmllbGRfZXhwYW5kID0gZmllbGRfY29uZmlnLmV4cGFuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnW2ZpZWxkXSA9IHtcbiAgICAgICAgICBib29zdDogKGZpZWxkX2NvbmZpZy5ib29zdCB8fCBmaWVsZF9jb25maWcuYm9vc3QgPT09IDApID8gZmllbGRfY29uZmlnLmJvb3N0IDogMSxcbiAgICAgICAgICBib29sOiBmaWVsZF9jb25maWcuYm9vbCB8fCBnbG9iYWxfYm9vbCxcbiAgICAgICAgICBleHBhbmQ6IGZpZWxkX2V4cGFuZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxhc3RpY2x1bnIudXRpbHMud2FybignZmllbGQgbmFtZSBpbiB1c2VyIGNvbmZpZ3VyYXRpb24gbm90IGZvdW5kIGluIGluZGV4IGluc3RhbmNlIGZpZWxkcycpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZEFsbEZpZWxkczJVc2VyQ29uZmlnKGdsb2JhbF9ib29sLCBnbG9iYWxfZXhwYW5kLCBmaWVsZHMpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbGwgZmllbGRzIHRvIHVzZXIgc2VhcmNoIGNvbmZpZ3VyYXRpb24uXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBib29sIEJvb2xlYW4gbW9kZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBhbmQgRXhwYW5kIG1vZGVsXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgZmllbGRzIG9mIGluZGV4IGluc3RhbmNlXG4gKi9cbmVsYXN0aWNsdW5yLkNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmFkZEFsbEZpZWxkczJVc2VyQ29uZmlnID0gZnVuY3Rpb24gKGJvb2wsIGV4cGFuZCwgZmllbGRzKSB7XG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHRoaXMuY29uZmlnW2ZpZWxkXSA9IHtcbiAgICAgIGJvb3N0OiAxLFxuICAgICAgYm9vbDogYm9vbCxcbiAgICAgIGV4cGFuZDogZXhwYW5kXG4gICAgfTtcbiAgfSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIGdldCBjdXJyZW50IHVzZXIgY29uZmlndXJhdGlvblxuICovXG5lbGFzdGljbHVuci5Db25maWd1cmF0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbmZpZztcbn07XG5cbi8qKlxuICogcmVzZXQgdXNlciBzZWFyY2ggY29uZmlndXJhdGlvbi5cbiAqL1xuZWxhc3RpY2x1bnIuQ29uZmlndXJhdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29uZmlnID0ge307XG59O1xuLyoqXG4gKiBzb3J0ZWRfc2V0LmpzIGlzIGFkZGVkIG9ubHkgdG8gbWFrZSBlbGFzdGljbHVuci5qcyBjb21wYXRpYmxlIHdpdGggbHVuci1sYW5ndWFnZXMuXG4gKiBpZiBlbGFzdGljbHVuci5qcyBzdXBwb3J0IGRpZmZlcmVudCBsYW5ndWFnZXMgYnkgZGVmYXVsdCwgdGhpcyB3aWxsIG1ha2UgZWxhc3RpY2x1bnIuanNcbiAqIG11Y2ggYmlnZ2VyIHRoYXQgbm90IGdvb2QgZm9yIGJyb3dzZXIgdXNhZ2UuXG4gKlxuICovXG5cblxuLyohXG4gKiBsdW5yLlNvcnRlZFNldFxuICogQ29weXJpZ2h0IChDKSAyMDE2IE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogbHVuci5Tb3J0ZWRTZXRzIGFyZSB1c2VkIHRvIG1haW50YWluIGFuIGFycmF5IG9mIHVuaXEgdmFsdWVzIGluIGEgc29ydGVkXG4gKiBvcmRlci5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xubHVuci5Tb3J0ZWRTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLmVsZW1lbnRzID0gW11cbn1cblxuLyoqXG4gKiBMb2FkcyBhIHByZXZpb3VzbHkgc2VyaWFsaXNlZCBzb3J0ZWQgc2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcmlhbGlzZWREYXRhIFRoZSBzZXJpYWxpc2VkIHNldCB0byBsb2FkLlxuICogQHJldHVybnMge2x1bnIuU29ydGVkU2V0fVxuICogQG1lbWJlck9mIFNvcnRlZFNldFxuICovXG5sdW5yLlNvcnRlZFNldC5sb2FkID0gZnVuY3Rpb24gKHNlcmlhbGlzZWREYXRhKSB7XG4gIHZhciBzZXQgPSBuZXcgdGhpc1xuXG4gIHNldC5lbGVtZW50cyA9IHNlcmlhbGlzZWREYXRhXG4gIHNldC5sZW5ndGggPSBzZXJpYWxpc2VkRGF0YS5sZW5ndGhcblxuICByZXR1cm4gc2V0XG59XG5cbi8qKlxuICogSW5zZXJ0cyBuZXcgaXRlbXMgaW50byB0aGUgc2V0IGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIHRvIG1haW50YWluIHRoZVxuICogb3JkZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFRoZSBvYmplY3RzIHRvIGFkZCB0byB0aGlzIHNldC5cbiAqIEBtZW1iZXJPZiBTb3J0ZWRTZXRcbiAqL1xubHVuci5Tb3J0ZWRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGksIGVsZW1lbnRcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IGFyZ3VtZW50c1tpXVxuICAgIGlmICh+dGhpcy5pbmRleE9mKGVsZW1lbnQpKSBjb250aW51ZVxuICAgIHRoaXMuZWxlbWVudHMuc3BsaWNlKHRoaXMubG9jYXRpb25Gb3IoZWxlbWVudCksIDAsIGVsZW1lbnQpXG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBzb3J0ZWQgc2V0IGludG8gYW4gYXJyYXkuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQG1lbWJlck9mIFNvcnRlZFNldFxuICovXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHMuc2xpY2UoKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnlcbiAqIGVsZW1lbnQgaW4gdGhpcyBzb3J0ZWQgc2V0LlxuICpcbiAqIERlbGVnYXRlcyB0byBBcnJheS5wcm90b3R5cGUubWFwIGFuZCBoYXMgdGhlIHNhbWUgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlXG4gKiBzZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBmb3IgdGhlIGZ1bmN0aW9uIGZuLlxuICogQHJldHVybnMge0FycmF5fVxuICogQG1lbWJlck9mIFNvcnRlZFNldFxuICovXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCBjdHgpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHMubWFwKGZuLCBjdHgpXG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBzb3J0ZWQgc2V0IGVsZW1lbnQuXG4gKlxuICogRGVsZWdhdGVzIHRvIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoIGFuZCBoYXMgdGhlIHNhbWUgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlXG4gKiBzZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XG4gKiBmb3IgdGhlIGZ1bmN0aW9uIGZuLlxuICovXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgY3R4KSB7XG4gIHJldHVybiB0aGlzLmVsZW1lbnRzLmZvckVhY2goZm4sIGN0eClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZVxuICogc29ydGVkIHNldCwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIG9iamVjdCB0byBsb2NhdGUgaW4gdGhlIHNvcnRlZCBzZXQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICogQG1lbWJlck9mIFNvcnRlZFNldFxuICovXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIHZhciBzdGFydCA9IDAsXG4gICAgICBlbmQgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIHNlY3Rpb25MZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgIHBpdm90ID0gc3RhcnQgKyBNYXRoLmZsb29yKHNlY3Rpb25MZW5ndGggLyAyKSxcbiAgICAgIHBpdm90RWxlbSA9IHRoaXMuZWxlbWVudHNbcGl2b3RdXG5cbiAgd2hpbGUgKHNlY3Rpb25MZW5ndGggPiAxKSB7XG4gICAgaWYgKHBpdm90RWxlbSA9PT0gZWxlbSkgcmV0dXJuIHBpdm90XG5cbiAgICBpZiAocGl2b3RFbGVtIDwgZWxlbSkgc3RhcnQgPSBwaXZvdFxuICAgIGlmIChwaXZvdEVsZW0gPiBlbGVtKSBlbmQgPSBwaXZvdFxuXG4gICAgc2VjdGlvbkxlbmd0aCA9IGVuZCAtIHN0YXJ0XG4gICAgcGl2b3QgPSBzdGFydCArIE1hdGguZmxvb3Ioc2VjdGlvbkxlbmd0aCAvIDIpXG4gICAgcGl2b3RFbGVtID0gdGhpcy5lbGVtZW50c1twaXZvdF1cbiAgfVxuXG4gIGlmIChwaXZvdEVsZW0gPT09IGVsZW0pIHJldHVybiBwaXZvdFxuXG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgc29ydGVkIHNldCB0aGF0IGFuIGVsZW1lbnQgc2hvdWxkIGJlXG4gKiBpbnNlcnRlZCBhdCB0byBtYWludGFpbiB0aGUgY3VycmVudCBvcmRlciBvZiB0aGUgc2V0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IgZG9lcyBub3QgYWxyZWFkeSBleGlzdFxuICogaW4gdGhlIHNvcnRlZCBzZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIGVsZW0gdG8gZmluZCB0aGUgcG9zaXRpb24gZm9yIGluIHRoZSBzZXRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XG4gKi9cbmx1bnIuU29ydGVkU2V0LnByb3RvdHlwZS5sb2NhdGlvbkZvciA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIHZhciBzdGFydCA9IDAsXG4gICAgICBlbmQgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIHNlY3Rpb25MZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgIHBpdm90ID0gc3RhcnQgKyBNYXRoLmZsb29yKHNlY3Rpb25MZW5ndGggLyAyKSxcbiAgICAgIHBpdm90RWxlbSA9IHRoaXMuZWxlbWVudHNbcGl2b3RdXG5cbiAgd2hpbGUgKHNlY3Rpb25MZW5ndGggPiAxKSB7XG4gICAgaWYgKHBpdm90RWxlbSA8IGVsZW0pIHN0YXJ0ID0gcGl2b3RcbiAgICBpZiAocGl2b3RFbGVtID4gZWxlbSkgZW5kID0gcGl2b3RcblxuICAgIHNlY3Rpb25MZW5ndGggPSBlbmQgLSBzdGFydFxuICAgIHBpdm90ID0gc3RhcnQgKyBNYXRoLmZsb29yKHNlY3Rpb25MZW5ndGggLyAyKVxuICAgIHBpdm90RWxlbSA9IHRoaXMuZWxlbWVudHNbcGl2b3RdXG4gIH1cblxuICBpZiAocGl2b3RFbGVtID4gZWxlbSkgcmV0dXJuIHBpdm90XG4gIGlmIChwaXZvdEVsZW0gPCBlbGVtKSByZXR1cm4gcGl2b3QgKyAxXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsdW5yLlNvcnRlZFNldCB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBpbiB0aGUgaW50ZXJzZWN0aW9uXG4gKiBvZiB0aGlzIHNldCBhbmQgdGhlIHBhc3NlZCBzZXQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlNvcnRlZFNldH0gb3RoZXJTZXQgVGhlIHNldCB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHNldC5cbiAqIEByZXR1cm5zIHtsdW5yLlNvcnRlZFNldH1cbiAqIEBtZW1iZXJPZiBTb3J0ZWRTZXRcbiAqL1xubHVuci5Tb3J0ZWRTZXQucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChvdGhlclNldCkge1xuICB2YXIgaW50ZXJzZWN0U2V0ID0gbmV3IGx1bnIuU29ydGVkU2V0LFxuICAgICAgaSA9IDAsIGogPSAwLFxuICAgICAgYV9sZW4gPSB0aGlzLmxlbmd0aCwgYl9sZW4gPSBvdGhlclNldC5sZW5ndGgsXG4gICAgICBhID0gdGhpcy5lbGVtZW50cywgYiA9IG90aGVyU2V0LmVsZW1lbnRzXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoaSA+IGFfbGVuIC0gMSB8fCBqID4gYl9sZW4gLSAxKSBicmVha1xuXG4gICAgaWYgKGFbaV0gPT09IGJbal0pIHtcbiAgICAgIGludGVyc2VjdFNldC5hZGQoYVtpXSlcbiAgICAgIGkrKywgaisrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChhW2ldIDwgYltqXSkge1xuICAgICAgaSsrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChhW2ldID4gYltqXSkge1xuICAgICAgaisrXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaW50ZXJzZWN0U2V0XG59XG5cbi8qKlxuICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgc2V0XG4gKlxuICogQHJldHVybnMge2x1bnIuU29ydGVkU2V0fVxuICogQG1lbWJlck9mIFNvcnRlZFNldFxuICovXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbG9uZSA9IG5ldyBsdW5yLlNvcnRlZFNldFxuXG4gIGNsb25lLmVsZW1lbnRzID0gdGhpcy50b0FycmF5KClcbiAgY2xvbmUubGVuZ3RoID0gY2xvbmUuZWxlbWVudHMubGVuZ3RoXG5cbiAgcmV0dXJuIGNsb25lXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsdW5yLlNvcnRlZFNldCB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBpbiB0aGUgdW5pb25cbiAqIG9mIHRoaXMgc2V0IGFuZCB0aGUgcGFzc2VkIHNldC5cbiAqXG4gKiBAcGFyYW0ge2x1bnIuU29ydGVkU2V0fSBvdGhlclNldCBUaGUgc2V0IHRvIHVuaW9uIHdpdGggdGhpcyBzZXQuXG4gKiBAcmV0dXJucyB7bHVuci5Tb3J0ZWRTZXR9XG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XG4gKi9cbmx1bnIuU29ydGVkU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIChvdGhlclNldCkge1xuICB2YXIgbG9uZ1NldCwgc2hvcnRTZXQsIHVuaW9uU2V0XG5cbiAgaWYgKHRoaXMubGVuZ3RoID49IG90aGVyU2V0Lmxlbmd0aCkge1xuICAgIGxvbmdTZXQgPSB0aGlzLCBzaG9ydFNldCA9IG90aGVyU2V0XG4gIH0gZWxzZSB7XG4gICAgbG9uZ1NldCA9IG90aGVyU2V0LCBzaG9ydFNldCA9IHRoaXNcbiAgfVxuXG4gIHVuaW9uU2V0ID0gbG9uZ1NldC5jbG9uZSgpXG5cbiAgZm9yKHZhciBpID0gMCwgc2hvcnRTZXRFbGVtZW50cyA9IHNob3J0U2V0LnRvQXJyYXkoKTsgaSA8IHNob3J0U2V0RWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgIHVuaW9uU2V0LmFkZChzaG9ydFNldEVsZW1lbnRzW2ldKVxuICB9XG5cbiAgcmV0dXJuIHVuaW9uU2V0XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzb3J0ZWQgc2V0IHJlYWR5IGZvciBzZXJpYWxpc2F0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBtZW1iZXJPZiBTb3J0ZWRTZXRcbiAqL1xubHVuci5Tb3J0ZWRTZXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9BcnJheSgpXG59XG4gIC8qKlxuICAgKiBleHBvcnQgdGhlIG1vZHVsZSB2aWEgQU1ELCBDb21tb25KUyBvciBhcyBhIGJyb3dzZXIgZ2xvYmFsXG4gICAqIEV4cG9ydCBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gICAqL1xuICA7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgZGVmaW5lKGZhY3RvcnkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgKiBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICogbGlrZSBOb2RlLlxuICAgICAgICovXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgcm9vdC5lbGFzdGljbHVuciA9IGZhY3RvcnkoKVxuICAgIH1cbiAgfSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogSnVzdCByZXR1cm4gYSB2YWx1ZSB0byBkZWZpbmUgdGhlIG1vZHVsZSBleHBvcnQuXG4gICAgICogVGhpcyBleGFtcGxlIHJldHVybnMgYW4gb2JqZWN0LCBidXQgdGhlIG1vZHVsZVxuICAgICAqIGNhbiByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgZXhwb3J0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgcmV0dXJuIGVsYXN0aWNsdW5yXG4gIH0pKVxufSkoKTtcbiJdLCJuYW1lcyI6WyJlbGFzdGljbHVuciIsImNvbmZpZyIsImlkeCIsIkluZGV4IiwicGlwZWxpbmUiLCJhZGQiLCJ0cmltbWVyIiwic3RvcFdvcmRGaWx0ZXIiLCJzdGVtbWVyIiwiY2FsbCIsInZlcnNpb24iLCJsdW5yIiwidXRpbHMiLCJ3YXJuIiwiZ2xvYmFsIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ0b1N0cmluZyIsIm9iaiIsIkV2ZW50RW1pdHRlciIsImV2ZW50cyIsInByb3RvdHlwZSIsImFkZExpc3RlbmVyIiwiYXJncyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJmbiIsInBvcCIsIm5hbWVzIiwiVHlwZUVycm9yIiwiZm9yRWFjaCIsIm5hbWUiLCJoYXNIYW5kbGVyIiwicHVzaCIsInJlbW92ZUxpc3RlbmVyIiwiZm5JbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJsZW5ndGgiLCJlbWl0IiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJ0b2tlbml6ZXIiLCJzdHIiLCJpc0FycmF5IiwiYXJyIiwiZmlsdGVyIiwidG9rZW4iLCJtYXAiLCJ0IiwidG9Mb3dlckNhc2UiLCJvdXQiLCJpdGVtIiwidG9rZW5zIiwic3BsaXQiLCJzZXBlcmF0b3IiLCJjb25jYXQiLCJ0cmltIiwiZGVmYXVsdFNlcGVyYXRvciIsInNldFNlcGVyYXRvciIsInNlcCIsInJlc2V0U2VwZXJhdG9yIiwiZ2V0U2VwZXJhdG9yIiwiUGlwZWxpbmUiLCJfcXVldWUiLCJyZWdpc3RlcmVkRnVuY3Rpb25zIiwicmVnaXN0ZXJGdW5jdGlvbiIsImxhYmVsIiwiZ2V0UmVnaXN0ZXJlZEZ1bmN0aW9uIiwid2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkIiwiaXNSZWdpc3RlcmVkIiwibG9hZCIsInNlcmlhbGlzZWQiLCJmbk5hbWUiLCJFcnJvciIsImZucyIsImFmdGVyIiwiZXhpc3RpbmdGbiIsIm5ld0ZuIiwicG9zIiwiYmVmb3JlIiwicmVtb3ZlIiwicnVuIiwidG9rZW5MZW5ndGgiLCJwaXBlbGluZUxlbmd0aCIsImkiLCJqIiwicmVzZXQiLCJnZXQiLCJ0b0pTT04iLCJfZmllbGRzIiwiX3JlZiIsImRvY3VtZW50U3RvcmUiLCJEb2N1bWVudFN0b3JlIiwiaW5kZXgiLCJldmVudEVtaXR0ZXIiLCJfaWRmQ2FjaGUiLCJvbiIsImJpbmQiLCJvZmYiLCJzZXJpYWxpc2VkRGF0YSIsImZpZWxkcyIsInJlZiIsImZpZWxkIiwiSW52ZXJ0ZWRJbmRleCIsImFkZEZpZWxkIiwiZmllbGROYW1lIiwic2V0UmVmIiwicmVmTmFtZSIsInNhdmVEb2N1bWVudCIsInNhdmUiLCJhZGREb2MiLCJkb2MiLCJlbWl0RXZlbnQiLCJkb2NSZWYiLCJmaWVsZFRva2VucyIsImFkZEZpZWxkTGVuZ3RoIiwidG9rZW5Db3VudCIsInRlcm1GcmVxdWVuY3kiLCJNYXRoIiwic3FydCIsImFkZFRva2VuIiwidGYiLCJyZW1vdmVEb2NCeVJlZiIsImlzRG9jU3RvcmVkIiwiaGFzRG9jIiwiZ2V0RG9jIiwicmVtb3ZlRG9jIiwicmVtb3ZlVG9rZW4iLCJ1cGRhdGVEb2MiLCJpZGYiLCJ0ZXJtIiwiY2FjaGVLZXkiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImRmIiwiZ2V0RG9jRnJlcSIsImxvZyIsImdldEZpZWxkcyIsInNlYXJjaCIsInF1ZXJ5IiwidXNlckNvbmZpZyIsImNvbmZpZ1N0ciIsIkpTT04iLCJzdHJpbmdpZnkiLCJDb25maWd1cmF0aW9uIiwicXVlcnlUb2tlbnMiLCJxdWVyeVJlc3VsdHMiLCJmaWVsZFNlYXJjaFJlc3VsdHMiLCJmaWVsZFNlYXJjaCIsImZpZWxkQm9vc3QiLCJib29zdCIsInJlc3VsdHMiLCJzY29yZSIsInNvcnQiLCJhIiwiYiIsImJvb2xlYW5UeXBlIiwiYm9vbCIsImV4cGFuZCIsInNjb3JlcyIsImRvY1Rva2VucyIsImV4cGFuZFRva2VuIiwicXVlcnlUb2tlblNjb3JlcyIsImtleSIsImRvY3MiLCJnZXREb2NzIiwiZmlsdGVyZWREb2NzIiwiZmllbGRTZWFyY2hTdGF0cyIsImdldFRlcm1GcmVxdWVuY3kiLCJmaWVsZExlbmd0aCIsImdldEZpZWxkTGVuZ3RoIiwiZmllbGRMZW5ndGhOb3JtIiwicGVuYWxpdHkiLCJtZXJnZVNjb3JlcyIsImNvb3JkTm9ybSIsImFjY3VtU2NvcmVzIiwib3AiLCJpbnRlcnNlY3Rpb24iLCJuIiwiaW5kZXhKc29uIiwidXNlIiwicGx1Z2luIiwidW5zaGlmdCIsIl9zYXZlIiwiZG9jSW5mbyIsInN0b3JlIiwiY2xvbmUiLCJ1cGRhdGVGaWVsZExlbmd0aCIsImNvcHkiLCJjb25zdHJ1Y3RvciIsImF0dHIiLCJzdGVwMmxpc3QiLCJzdGVwM2xpc3QiLCJjIiwidiIsIkMiLCJWIiwibWdyMCIsIm1lcTEiLCJtZ3IxIiwic192IiwicmVfbWdyMCIsIlJlZ0V4cCIsInJlX21ncjEiLCJyZV9tZXExIiwicmVfc192IiwicmVfMWEiLCJyZTJfMWEiLCJyZV8xYiIsInJlMl8xYiIsInJlXzFiXzIiLCJyZTJfMWJfMiIsInJlM18xYl8yIiwicmU0XzFiXzIiLCJyZV8xYyIsInJlXzIiLCJyZV8zIiwicmVfNCIsInJlMl80IiwicmVfNSIsInJlXzVfMSIsInJlM181IiwicG9ydGVyU3RlbW1lciIsInciLCJzdGVtIiwic3VmZml4IiwiZmlyc3RjaCIsInJlIiwicmUyIiwicmUzIiwicmU0Iiwic3Vic3RyIiwidG9VcHBlckNhc2UiLCJ0ZXN0IiwicmVwbGFjZSIsImZwIiwiZXhlYyIsInN0b3BXb3JkcyIsImNsZWFyU3RvcFdvcmRzIiwiYWRkU3RvcFdvcmRzIiwid29yZHMiLCJ3b3JkIiwicmVzZXRTdG9wV29yZHMiLCJkZWZhdWx0U3RvcFdvcmRzIiwicm9vdCIsInRva2VuSW5mbyIsImhhc1Rva2VuIiwibm9kZSIsImdldE5vZGUiLCJtZW1vIiwicGFyc2UiLCJidWlsZFVzZXJDb25maWciLCJlcnJvciIsImJ1aWxkRGVmYXVsdENvbmZpZyIsImdsb2JhbF9ib29sIiwiZ2xvYmFsX2V4cGFuZCIsImZpZWxkX2NvbmZpZyIsImZpZWxkX2V4cGFuZCIsImFkZEFsbEZpZWxkczJVc2VyQ29uZmlnIiwiU29ydGVkU2V0IiwiZWxlbWVudHMiLCJzZXQiLCJlbGVtZW50IiwibG9jYXRpb25Gb3IiLCJ0b0FycmF5IiwiY3R4IiwiZWxlbSIsInN0YXJ0IiwiZW5kIiwic2VjdGlvbkxlbmd0aCIsInBpdm90IiwiZmxvb3IiLCJwaXZvdEVsZW0iLCJpbnRlcnNlY3QiLCJvdGhlclNldCIsImludGVyc2VjdFNldCIsImFfbGVuIiwiYl9sZW4iLCJ1bmlvbiIsImxvbmdTZXQiLCJzaG9ydFNldCIsInVuaW9uU2V0Iiwic2hvcnRTZXRFbGVtZW50cyIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/elasticlunr/elasticlunr.js\n");

/***/ })

};
;